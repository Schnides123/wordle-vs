{"version":3,"names":[],"sources":["../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/unicode/utf8/utf8.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/panic.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/reflect/value.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/reflect/type.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/chan.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/hashmap.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/gc_conservative.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/gc_stack_portable.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/gc_globals_conservative.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/arch_tinygowasm.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/runtime_tinygowasm.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/interface.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/reflect/sidetables.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/errors/errors.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/internal/task/gc_stack_chain.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/internal/task/queue.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/internal/task/task_asyncify.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/scheduler.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/sync/mutex.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/sync/once.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/sync/atomic/value.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/print.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/string.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/slice.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/time/format.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/syscall/js/js.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/os/file.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/fmt/errors.go","../../../../pkg/mod/nhooyr.io/websocket@v1.8.7/close.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/net/url/url.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/time/zoneinfo.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/context/context.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/time/time.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/bytes/buffer.go","../../../../pkg/mod/nhooyr.io/websocket@v1.8.7/stringer.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/fmt/print.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/internal/reflectlite/reflect.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/runtime.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/runtime_wasm_js.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/scheduler_any.go","cmd/web/web.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/os/tempfile.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/internal/testlog/log.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/runtime/runtime_wasm_js_scheduler.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/syscall/js/func.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/time/zoneinfo_js.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/time/sleep.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/internal/fmtsort/sort.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/math/bits/bits.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strings/builder.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strings/strings.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/internal/bytealg/bytealg.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/os/file_other.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strconv/quote.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strconv/decimal.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strconv/itoa.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/math/unsafe.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strconv/ftoa.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strconv/ftoaryu.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/strconv/atoi.go","../../../../../../../usr/local/Cellar/go/1.17.3/libexec/src/fmt/format.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/sync/pool.go","../../../../pkg/mod/nhooyr.io/websocket@v1.8.7/internal/wsjs/wsjs_js.go","../../../../pkg/mod/nhooyr.io/websocket@v1.8.7/ws_js.go","../../../../pkg/mod/nhooyr.io/websocket@v1.8.7/internal/xsync/int64.go","../../../../../../../usr/local/Cellar/tinygo/0.22.0/src/internal/task/task_asyncify_wasm.S","libc-top-half/musl/src/string/memcpy.c","libc-top-half/musl/src/string/memmove.c","libc-top-half/musl/src/string/memset.c","libc-top-half/musl/src/exit/exit.c"],"sourcesContent":["// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package utf8 implements functions and constants to support text encoded in\n// UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.\n// See https://en.wikipedia.org/wiki/UTF-8\npackage utf8\n\n// The conditions RuneError==unicode.ReplacementChar and\n// MaxRune==unicode.MaxRune are verified in the tests.\n// Defining them locally avoids this package depending on package unicode.\n\n// Numbers fundamental to the encoding.\nconst (\n\tRuneError = '\\uFFFD'     // the \"error\" Rune or \"Unicode replacement character\"\n\tRuneSelf  = 0x80         // characters below RuneSelf are represented as themselves in a single byte.\n\tMaxRune   = '\\U0010FFFF' // Maximum valid Unicode code point.\n\tUTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.\n)\n\n// Code points in the surrogate range are not valid for UTF-8.\nconst (\n\tsurrogateMin = 0xD800\n\tsurrogateMax = 0xDFFF\n)\n\nconst (\n\tt1 = 0b00000000\n\ttx = 0b10000000\n\tt2 = 0b11000000\n\tt3 = 0b11100000\n\tt4 = 0b11110000\n\tt5 = 0b11111000\n\n\tmaskx = 0b00111111\n\tmask2 = 0b00011111\n\tmask3 = 0b00001111\n\tmask4 = 0b00000111\n\n\trune1Max = 1<<7 - 1\n\trune2Max = 1<<11 - 1\n\trune3Max = 1<<16 - 1\n\n\t// The default lowest and highest continuation byte.\n\tlocb = 0b10000000\n\thicb = 0b10111111\n\n\t// These names of these constants are chosen to give nice alignment in the\n\t// table below. The first nibble is an index into acceptRanges or F for\n\t// special one-byte cases. The second nibble is the Rune length or the\n\t// Status for the special one-byte case.\n\txx = 0xF1 // invalid: size 1\n\tas = 0xF0 // ASCII: size 1\n\ts1 = 0x02 // accept 0, size 2\n\ts2 = 0x13 // accept 1, size 3\n\ts3 = 0x03 // accept 0, size 3\n\ts4 = 0x23 // accept 2, size 3\n\ts5 = 0x34 // accept 3, size 4\n\ts6 = 0x04 // accept 0, size 4\n\ts7 = 0x44 // accept 4, size 4\n)\n\n// first is information about the first byte in a UTF-8 sequence.\nvar first = [256]uint8{\n\t//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F\n\tas, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F\n\t//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n\txx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F\n\txx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F\n\txx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF\n\txx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF\n\txx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF\n\ts1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF\n\ts2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF\n\ts5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF\n}\n\n// acceptRange gives the range of valid values for the second byte in a UTF-8\n// sequence.\ntype acceptRange struct {\n\tlo uint8 // lowest value for second byte.\n\thi uint8 // highest value for second byte.\n}\n\n// acceptRanges has size 16 to avoid bounds checks in the code that uses it.\nvar acceptRanges = [16]acceptRange{\n\t0: {locb, hicb},\n\t1: {0xA0, hicb},\n\t2: {locb, 0x9F},\n\t3: {0x90, hicb},\n\t4: {locb, 0x8F},\n}\n\n// FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\n// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\nfunc FullRune(p []byte) bool {\n\tn := len(p)\n\tif n == 0 {\n\t\treturn false\n\t}\n\tx := first[p[0]]\n\tif n >= int(x&7) {\n\t\treturn true // ASCII, invalid or valid.\n\t}\n\t// Must be short or invalid.\n\taccept := acceptRanges[x>>4]\n\tif n > 1 && (p[1] < accept.lo || accept.hi < p[1]) {\n\t\treturn true\n\t} else if n > 2 && (p[2] < locb || hicb < p[2]) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// FullRuneInString is like FullRune but its input is a string.\nfunc FullRuneInString(s string) bool {\n\tn := len(s)\n\tif n == 0 {\n\t\treturn false\n\t}\n\tx := first[s[0]]\n\tif n >= int(x&7) {\n\t\treturn true // ASCII, invalid, or valid.\n\t}\n\t// Must be short or invalid.\n\taccept := acceptRanges[x>>4]\n\tif n > 1 && (s[1] < accept.lo || accept.hi < s[1]) {\n\t\treturn true\n\t} else if n > 2 && (s[2] < locb || hicb < s[2]) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\n// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\n// the encoding is invalid, it returns (RuneError, 1). Both are impossible\n// results for correct, non-empty UTF-8.\n//\n// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is\n// out of range, or is not the shortest possible UTF-8 encoding for the\n// value. No other validation is performed.\nfunc DecodeRune(p []byte) (r rune, size int) {\n\tn := len(p)\n\tif n < 1 {\n\t\treturn RuneError, 0\n\t}\n\tp0 := p[0]\n\tx := first[p0]\n\tif x >= as {\n\t\t// The following code simulates an additional check for x == xx and\n\t\t// handling the ASCII and invalid cases accordingly. This mask-and-or\n\t\t// approach prevents an additional branch.\n\t\tmask := rune(x) << 31 >> 31 // Create 0x0000 or 0xFFFF.\n\t\treturn rune(p[0])&^mask | RuneError&mask, 1\n\t}\n\tsz := int(x & 7)\n\taccept := acceptRanges[x>>4]\n\tif n < sz {\n\t\treturn RuneError, 1\n\t}\n\tb1 := p[1]\n\tif b1 < accept.lo || accept.hi < b1 {\n\t\treturn RuneError, 1\n\t}\n\tif sz <= 2 { // <= instead of == to help the compiler eliminate some bounds checks\n\t\treturn rune(p0&mask2)<<6 | rune(b1&maskx), 2\n\t}\n\tb2 := p[2]\n\tif b2 < locb || hicb < b2 {\n\t\treturn RuneError, 1\n\t}\n\tif sz <= 3 {\n\t\treturn rune(p0&mask3)<<12 | rune(b1&maskx)<<6 | rune(b2&maskx), 3\n\t}\n\tb3 := p[3]\n\tif b3 < locb || hicb < b3 {\n\t\treturn RuneError, 1\n\t}\n\treturn rune(p0&mask4)<<18 | rune(b1&maskx)<<12 | rune(b2&maskx)<<6 | rune(b3&maskx), 4\n}\n\n// DecodeRuneInString is like DecodeRune but its input is a string. If s is\n// empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\n// returns (RuneError, 1). Both are impossible results for correct, non-empty\n// UTF-8.\n//\n// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is\n// out of range, or is not the shortest possible UTF-8 encoding for the\n// value. No other validation is performed.\nfunc DecodeRuneInString(s string) (r rune, size int) {\n\tn := len(s)\n\tif n < 1 {\n\t\treturn RuneError, 0\n\t}\n\ts0 := s[0]\n\tx := first[s0]\n\tif x >= as {\n\t\t// The following code simulates an additional check for x == xx and\n\t\t// handling the ASCII and invalid cases accordingly. This mask-and-or\n\t\t// approach prevents an additional branch.\n\t\tmask := rune(x) << 31 >> 31 // Create 0x0000 or 0xFFFF.\n\t\treturn rune(s[0])&^mask | RuneError&mask, 1\n\t}\n\tsz := int(x & 7)\n\taccept := acceptRanges[x>>4]\n\tif n < sz {\n\t\treturn RuneError, 1\n\t}\n\ts1 := s[1]\n\tif s1 < accept.lo || accept.hi < s1 {\n\t\treturn RuneError, 1\n\t}\n\tif sz <= 2 { // <= instead of == to help the compiler eliminate some bounds checks\n\t\treturn rune(s0&mask2)<<6 | rune(s1&maskx), 2\n\t}\n\ts2 := s[2]\n\tif s2 < locb || hicb < s2 {\n\t\treturn RuneError, 1\n\t}\n\tif sz <= 3 {\n\t\treturn rune(s0&mask3)<<12 | rune(s1&maskx)<<6 | rune(s2&maskx), 3\n\t}\n\ts3 := s[3]\n\tif s3 < locb || hicb < s3 {\n\t\treturn RuneError, 1\n\t}\n\treturn rune(s0&mask4)<<18 | rune(s1&maskx)<<12 | rune(s2&maskx)<<6 | rune(s3&maskx), 4\n}\n\n// DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\n// its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\n// the encoding is invalid, it returns (RuneError, 1). Both are impossible\n// results for correct, non-empty UTF-8.\n//\n// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is\n// out of range, or is not the shortest possible UTF-8 encoding for the\n// value. No other validation is performed.\nfunc DecodeLastRune(p []byte) (r rune, size int) {\n\tend := len(p)\n\tif end == 0 {\n\t\treturn RuneError, 0\n\t}\n\tstart := end - 1\n\tr = rune(p[start])\n\tif r < RuneSelf {\n\t\treturn r, 1\n\t}\n\t// guard against O(n^2) behavior when traversing\n\t// backwards through strings with long sequences of\n\t// invalid UTF-8.\n\tlim := end - UTFMax\n\tif lim < 0 {\n\t\tlim = 0\n\t}\n\tfor start--; start >= lim; start-- {\n\t\tif RuneStart(p[start]) {\n\t\t\tbreak\n\t\t}\n\t}\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tr, size = DecodeRune(p[start:end])\n\tif start+size != end {\n\t\treturn RuneError, 1\n\t}\n\treturn r, size\n}\n\n// DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\n// s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\n// it returns (RuneError, 1). Both are impossible results for correct,\n// non-empty UTF-8.\n//\n// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is\n// out of range, or is not the shortest possible UTF-8 encoding for the\n// value. No other validation is performed.\nfunc DecodeLastRuneInString(s string) (r rune, size int) {\n\tend := len(s)\n\tif end == 0 {\n\t\treturn RuneError, 0\n\t}\n\tstart := end - 1\n\tr = rune(s[start])\n\tif r < RuneSelf {\n\t\treturn r, 1\n\t}\n\t// guard against O(n^2) behavior when traversing\n\t// backwards through strings with long sequences of\n\t// invalid UTF-8.\n\tlim := end - UTFMax\n\tif lim < 0 {\n\t\tlim = 0\n\t}\n\tfor start--; start >= lim; start-- {\n\t\tif RuneStart(s[start]) {\n\t\t\tbreak\n\t\t}\n\t}\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tr, size = DecodeRuneInString(s[start:end])\n\tif start+size != end {\n\t\treturn RuneError, 1\n\t}\n\treturn r, size\n}\n\n// RuneLen returns the number of bytes required to encode the rune.\n// It returns -1 if the rune is not a valid value to encode in UTF-8.\nfunc RuneLen(r rune) int {\n\tswitch {\n\tcase r < 0:\n\t\treturn -1\n\tcase r <= rune1Max:\n\t\treturn 1\n\tcase r <= rune2Max:\n\t\treturn 2\n\tcase surrogateMin <= r && r <= surrogateMax:\n\t\treturn -1\n\tcase r <= rune3Max:\n\t\treturn 3\n\tcase r <= MaxRune:\n\t\treturn 4\n\t}\n\treturn -1\n}\n\n// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\n// If the rune is out of range, it writes the encoding of RuneError.\n// It returns the number of bytes written.\nfunc EncodeRune(p []byte, r rune) int {\n\t// Negative values are erroneous. Making it unsigned addresses the problem.\n\tswitch i := uint32(r); {\n\tcase i <= rune1Max:\n\t\tp[0] = byte(r)\n\t\treturn 1\n\tcase i <= rune2Max:\n\t\t_ = p[1] // eliminate bounds checks\n\t\tp[0] = t2 | byte(r>>6)\n\t\tp[1] = tx | byte(r)&maskx\n\t\treturn 2\n\tcase i > MaxRune, surrogateMin <= i && i <= surrogateMax:\n\t\tr = RuneError\n\t\tfallthrough\n\tcase i <= rune3Max:\n\t\t_ = p[2] // eliminate bounds checks\n\t\tp[0] = t3 | byte(r>>12)\n\t\tp[1] = tx | byte(r>>6)&maskx\n\t\tp[2] = tx | byte(r)&maskx\n\t\treturn 3\n\tdefault:\n\t\t_ = p[3] // eliminate bounds checks\n\t\tp[0] = t4 | byte(r>>18)\n\t\tp[1] = tx | byte(r>>12)&maskx\n\t\tp[2] = tx | byte(r>>6)&maskx\n\t\tp[3] = tx | byte(r)&maskx\n\t\treturn 4\n\t}\n}\n\n// RuneCount returns the number of runes in p. Erroneous and short\n// encodings are treated as single runes of width 1 byte.\nfunc RuneCount(p []byte) int {\n\tnp := len(p)\n\tvar n int\n\tfor i := 0; i < np; {\n\t\tn++\n\t\tc := p[i]\n\t\tif c < RuneSelf {\n\t\t\t// ASCII fast path\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tx := first[c]\n\t\tif x == xx {\n\t\t\ti++ // invalid.\n\t\t\tcontinue\n\t\t}\n\t\tsize := int(x & 7)\n\t\tif i+size > np {\n\t\t\ti++ // Short or invalid.\n\t\t\tcontinue\n\t\t}\n\t\taccept := acceptRanges[x>>4]\n\t\tif c := p[i+1]; c < accept.lo || accept.hi < c {\n\t\t\tsize = 1\n\t\t} else if size == 2 {\n\t\t} else if c := p[i+2]; c < locb || hicb < c {\n\t\t\tsize = 1\n\t\t} else if size == 3 {\n\t\t} else if c := p[i+3]; c < locb || hicb < c {\n\t\t\tsize = 1\n\t\t}\n\t\ti += size\n\t}\n\treturn n\n}\n\n// RuneCountInString is like RuneCount but its input is a string.\nfunc RuneCountInString(s string) (n int) {\n\tns := len(s)\n\tfor i := 0; i < ns; n++ {\n\t\tc := s[i]\n\t\tif c < RuneSelf {\n\t\t\t// ASCII fast path\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tx := first[c]\n\t\tif x == xx {\n\t\t\ti++ // invalid.\n\t\t\tcontinue\n\t\t}\n\t\tsize := int(x & 7)\n\t\tif i+size > ns {\n\t\t\ti++ // Short or invalid.\n\t\t\tcontinue\n\t\t}\n\t\taccept := acceptRanges[x>>4]\n\t\tif c := s[i+1]; c < accept.lo || accept.hi < c {\n\t\t\tsize = 1\n\t\t} else if size == 2 {\n\t\t} else if c := s[i+2]; c < locb || hicb < c {\n\t\t\tsize = 1\n\t\t} else if size == 3 {\n\t\t} else if c := s[i+3]; c < locb || hicb < c {\n\t\t\tsize = 1\n\t\t}\n\t\ti += size\n\t}\n\treturn n\n}\n\n// RuneStart reports whether the byte could be the first byte of an encoded,\n// possibly invalid rune. Second and subsequent bytes always have the top two\n// bits set to 10.\nfunc RuneStart(b byte) bool { return b&0xC0 != 0x80 }\n\n// Valid reports whether p consists entirely of valid UTF-8-encoded runes.\nfunc Valid(p []byte) bool {\n\t// Fast path. Check for and skip 8 bytes of ASCII characters per iteration.\n\tfor len(p) >= 8 {\n\t\t// Combining two 32 bit loads allows the same code to be used\n\t\t// for 32 and 64 bit platforms.\n\t\t// The compiler can generate a 32bit load for first32 and second32\n\t\t// on many platforms. See test/codegen/memcombine.go.\n\t\tfirst32 := uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24\n\t\tsecond32 := uint32(p[4]) | uint32(p[5])<<8 | uint32(p[6])<<16 | uint32(p[7])<<24\n\t\tif (first32|second32)&0x80808080 != 0 {\n\t\t\t// Found a non ASCII byte (>= RuneSelf).\n\t\t\tbreak\n\t\t}\n\t\tp = p[8:]\n\t}\n\tn := len(p)\n\tfor i := 0; i < n; {\n\t\tpi := p[i]\n\t\tif pi < RuneSelf {\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tx := first[pi]\n\t\tif x == xx {\n\t\t\treturn false // Illegal starter byte.\n\t\t}\n\t\tsize := int(x & 7)\n\t\tif i+size > n {\n\t\t\treturn false // Short or invalid.\n\t\t}\n\t\taccept := acceptRanges[x>>4]\n\t\tif c := p[i+1]; c < accept.lo || accept.hi < c {\n\t\t\treturn false\n\t\t} else if size == 2 {\n\t\t} else if c := p[i+2]; c < locb || hicb < c {\n\t\t\treturn false\n\t\t} else if size == 3 {\n\t\t} else if c := p[i+3]; c < locb || hicb < c {\n\t\t\treturn false\n\t\t}\n\t\ti += size\n\t}\n\treturn true\n}\n\n// ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\nfunc ValidString(s string) bool {\n\t// Fast path. Check for and skip 8 bytes of ASCII characters per iteration.\n\tfor len(s) >= 8 {\n\t\t// Combining two 32 bit loads allows the same code to be used\n\t\t// for 32 and 64 bit platforms.\n\t\t// The compiler can generate a 32bit load for first32 and second32\n\t\t// on many platforms. See test/codegen/memcombine.go.\n\t\tfirst32 := uint32(s[0]) | uint32(s[1])<<8 | uint32(s[2])<<16 | uint32(s[3])<<24\n\t\tsecond32 := uint32(s[4]) | uint32(s[5])<<8 | uint32(s[6])<<16 | uint32(s[7])<<24\n\t\tif (first32|second32)&0x80808080 != 0 {\n\t\t\t// Found a non ASCII byte (>= RuneSelf).\n\t\t\tbreak\n\t\t}\n\t\ts = s[8:]\n\t}\n\tn := len(s)\n\tfor i := 0; i < n; {\n\t\tsi := s[i]\n\t\tif si < RuneSelf {\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tx := first[si]\n\t\tif x == xx {\n\t\t\treturn false // Illegal starter byte.\n\t\t}\n\t\tsize := int(x & 7)\n\t\tif i+size > n {\n\t\t\treturn false // Short or invalid.\n\t\t}\n\t\taccept := acceptRanges[x>>4]\n\t\tif c := s[i+1]; c < accept.lo || accept.hi < c {\n\t\t\treturn false\n\t\t} else if size == 2 {\n\t\t} else if c := s[i+2]; c < locb || hicb < c {\n\t\t\treturn false\n\t\t} else if size == 3 {\n\t\t} else if c := s[i+3]; c < locb || hicb < c {\n\t\t\treturn false\n\t\t}\n\t\ti += size\n\t}\n\treturn true\n}\n\n// ValidRune reports whether r can be legally encoded as UTF-8.\n// Code points that are out of range or a surrogate half are illegal.\nfunc ValidRune(r rune) bool {\n\tswitch {\n\tcase 0 <= r && r < surrogateMin:\n\t\treturn true\n\tcase surrogateMax < r && r <= MaxRune:\n\t\treturn true\n\t}\n\treturn false\n}\n","package runtime\n\n// trap is a compiler hint that this function cannot be executed. It is\n// translated into either a trap instruction or a call to abort().\n//export llvm.trap\nfunc trap()\n\n// Builtin function panic(msg), used as a compiler intrinsic.\nfunc _panic(message interface{}) {\n\tprintstring(\"panic: \")\n\tprintitf(message)\n\tprintnl()\n\tabort()\n}\n\n// Cause a runtime panic, which is (currently) always a string.\nfunc runtimePanic(msg string) {\n\tprintstring(\"panic: runtime error: \")\n\tprintln(msg)\n\tabort()\n}\n\n// Try to recover a panicking goroutine.\nfunc _recover() interface{} {\n\t// Deferred functions are currently not executed during panic, so there is\n\t// no way this can return anything besides nil.\n\treturn nil\n}\n\n// Panic when trying to dereference a nil pointer.\nfunc nilPanic() {\n\truntimePanic(\"nil pointer dereference\")\n}\n\n// Panic when trying to acces an array or slice out of bounds.\nfunc lookupPanic() {\n\truntimePanic(\"index out of range\")\n}\n\n// Panic when trying to slice a slice out of bounds.\nfunc slicePanic() {\n\truntimePanic(\"slice out of range\")\n}\n\n// Panic when trying to convert a slice to an array pointer (Go 1.17+) and the\n// slice is shorter than the array.\nfunc sliceToArrayPointerPanic() {\n\truntimePanic(\"slice smaller than array\")\n}\n\n// Panic when calling unsafe.Slice() (Go 1.17+) with a len that's too large\n// (which includes if the ptr is nil and len is nonzero).\nfunc unsafeSlicePanic() {\n\truntimePanic(\"unsafe.Slice: len out of range\")\n}\n\n// Panic when trying to create a new channel that is too big.\nfunc chanMakePanic() {\n\truntimePanic(\"new channel is too big\")\n}\n\n// Panic when a shift value is negative.\nfunc negativeShiftPanic() {\n\truntimePanic(\"negative shift\")\n}\n\n// Panic when there is a divide by zero.\nfunc divideByZeroPanic() {\n\truntimePanic(\"divide by zero\")\n}\n\nfunc blockingPanic() {\n\truntimePanic(\"trying to do blocking operation in exported function\")\n}\n","package reflect\n\nimport (\n\t\"unsafe\"\n)\n\ntype valueFlags uint8\n\n// Flags list some useful flags that contain some extra information not\n// contained in an interface{} directly, like whether this value was exported at\n// all (it is possible to read unexported fields using reflection, but it is not\n// possible to modify them).\nconst (\n\tvalueFlagIndirect valueFlags = 1 << iota\n\tvalueFlagExported\n)\n\ntype Value struct {\n\ttypecode rawType\n\tvalue    unsafe.Pointer\n\tflags    valueFlags\n}\n\n// isIndirect returns whether the value pointer in this Value is always a\n// pointer to the value. If it is false, it is only a pointer to the value if\n// the value is bigger than a pointer.\nfunc (v Value) isIndirect() bool {\n\treturn v.flags&valueFlagIndirect != 0\n}\n\n// isExported returns whether the value represented by this Value could be\n// accessed without violating type system constraints. For example, it is not\n// set for unexported struct fields.\nfunc (v Value) isExported() bool {\n\treturn v.flags&valueFlagExported != 0\n}\n\nfunc Indirect(v Value) Value {\n\tif v.Kind() != Ptr {\n\t\treturn v\n\t}\n\treturn v.Elem()\n}\n\n//go:linkname composeInterface runtime.composeInterface\nfunc composeInterface(rawType, unsafe.Pointer) interface{}\n\n//go:linkname decomposeInterface runtime.decomposeInterface\nfunc decomposeInterface(i interface{}) (rawType, unsafe.Pointer)\n\nfunc ValueOf(i interface{}) Value {\n\ttypecode, value := decomposeInterface(i)\n\treturn Value{\n\t\ttypecode: typecode,\n\t\tvalue:    value,\n\t\tflags:    valueFlagExported,\n\t}\n}\n\nfunc (v Value) Interface() interface{} {\n\tif !v.isExported() {\n\t\tpanic(\"(reflect.Value).Interface: unexported\")\n\t}\n\treturn valueInterfaceUnsafe(v)\n}\n\n// valueInterfaceUnsafe is used by the runtime to hash map keys. It should not\n// be subject to the isExported check.\nfunc valueInterfaceUnsafe(v Value) interface{} {\n\tif v.typecode.Kind() == Interface {\n\t\t// The value itself is an interface. This can happen when getting the\n\t\t// value of a struct field of interface type, like this:\n\t\t//     type T struct {\n\t\t//         X interface{}\n\t\t//     }\n\t\treturn *(*interface{})(v.value)\n\t}\n\tif v.isIndirect() && v.typecode.Size() <= unsafe.Sizeof(uintptr(0)) {\n\t\t// Value was indirect but must be put back directly in the interface\n\t\t// value.\n\t\tvar value uintptr\n\t\tfor j := v.typecode.Size(); j != 0; j-- {\n\t\t\tvalue = (value << 8) | uintptr(*(*uint8)(unsafe.Pointer(uintptr(v.value) + j - 1)))\n\t\t}\n\t\tv.value = unsafe.Pointer(value)\n\t}\n\treturn composeInterface(v.typecode, v.value)\n}\n\nfunc (v Value) Type() Type {\n\treturn v.typecode\n}\n\n// Internal function only, do not use.\n//\n// RawType returns the raw, underlying type code. It is used in the runtime\n// package and needs to be exported for the runtime package to access it.\nfunc (v Value) RawType() rawType {\n\treturn v.typecode\n}\n\nfunc (v Value) Kind() Kind {\n\treturn v.typecode.Kind()\n}\n\n// IsNil returns whether the value is the nil value. It panics if the value Kind\n// is not a channel, map, pointer, function, slice, or interface.\nfunc (v Value) IsNil() bool {\n\tswitch v.Kind() {\n\tcase Chan, Map, Ptr:\n\t\treturn v.pointer() == nil\n\tcase Func:\n\t\tif v.value == nil {\n\t\t\treturn true\n\t\t}\n\t\tfn := (*funcHeader)(v.value)\n\t\treturn fn.Code == nil\n\tcase Slice:\n\t\tif v.value == nil {\n\t\t\treturn true\n\t\t}\n\t\tslice := (*sliceHeader)(v.value)\n\t\treturn slice.data == nil\n\tcase Interface:\n\t\tif v.value == nil {\n\t\t\treturn true\n\t\t}\n\t\t_, val := decomposeInterface(*(*interface{})(v.value))\n\t\treturn val == nil\n\tdefault:\n\t\tpanic(&ValueError{\"IsNil\"})\n\t}\n}\n\n// Pointer returns the underlying pointer of the given value for the following\n// types: chan, map, pointer, unsafe.Pointer, slice, func.\nfunc (v Value) Pointer() uintptr {\n\tswitch v.Kind() {\n\tcase Chan, Map, Ptr, UnsafePointer:\n\t\treturn uintptr(v.pointer())\n\tcase Slice:\n\t\tslice := (*sliceHeader)(v.value)\n\t\treturn uintptr(slice.data)\n\tcase Func:\n\t\tpanic(\"unimplemented: (reflect.Value).Pointer()\")\n\tdefault: // not implemented: Func\n\t\tpanic(&ValueError{\"Pointer\"})\n\t}\n}\n\n// pointer returns the underlying pointer represented by v.\n// v.Kind() must be Ptr, Map, Chan, or UnsafePointer\nfunc (v Value) pointer() unsafe.Pointer {\n\tif v.isIndirect() {\n\t\treturn *(*unsafe.Pointer)(v.value)\n\t}\n\treturn v.value\n}\n\nfunc (v Value) IsValid() bool {\n\treturn v.typecode != 0\n}\n\nfunc (v Value) CanInterface() bool {\n\t// No Value types of private data can be constructed at the moment.\n\treturn true\n}\n\nfunc (v Value) CanAddr() bool {\n\treturn v.flags&(valueFlagIndirect) == valueFlagIndirect\n}\n\nfunc (v Value) Addr() Value {\n\tpanic(\"unimplemented: (reflect.Value).Addr()\")\n}\n\nfunc (v Value) CanSet() bool {\n\treturn v.flags&(valueFlagExported|valueFlagIndirect) == valueFlagExported|valueFlagIndirect\n}\n\nfunc (v Value) Bool() bool {\n\tswitch v.Kind() {\n\tcase Bool:\n\t\tif v.isIndirect() {\n\t\t\treturn *((*bool)(v.value))\n\t\t} else {\n\t\t\treturn uintptr(v.value) != 0\n\t\t}\n\tdefault:\n\t\tpanic(&ValueError{\"Bool\"})\n\t}\n}\n\nfunc (v Value) Int() int64 {\n\tswitch v.Kind() {\n\tcase Int:\n\t\tif v.isIndirect() || unsafe.Sizeof(int(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\treturn int64(*(*int)(v.value))\n\t\t} else {\n\t\t\treturn int64(int(uintptr(v.value)))\n\t\t}\n\tcase Int8:\n\t\tif v.isIndirect() {\n\t\t\treturn int64(*(*int8)(v.value))\n\t\t} else {\n\t\t\treturn int64(int8(uintptr(v.value)))\n\t\t}\n\tcase Int16:\n\t\tif v.isIndirect() {\n\t\t\treturn int64(*(*int16)(v.value))\n\t\t} else {\n\t\t\treturn int64(int16(uintptr(v.value)))\n\t\t}\n\tcase Int32:\n\t\tif v.isIndirect() || unsafe.Sizeof(int32(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\treturn int64(*(*int32)(v.value))\n\t\t} else {\n\t\t\treturn int64(int32(uintptr(v.value)))\n\t\t}\n\tcase Int64:\n\t\tif v.isIndirect() || unsafe.Sizeof(int64(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\treturn int64(*(*int64)(v.value))\n\t\t} else {\n\t\t\treturn int64(int64(uintptr(v.value)))\n\t\t}\n\tdefault:\n\t\tpanic(&ValueError{\"Int\"})\n\t}\n}\n\nfunc (v Value) Uint() uint64 {\n\tswitch v.Kind() {\n\tcase Uintptr:\n\t\tif v.isIndirect() {\n\t\t\treturn uint64(*(*uintptr)(v.value))\n\t\t} else {\n\t\t\treturn uint64(uintptr(v.value))\n\t\t}\n\tcase Uint8:\n\t\tif v.isIndirect() {\n\t\t\treturn uint64(*(*uint8)(v.value))\n\t\t} else {\n\t\t\treturn uint64(uintptr(v.value))\n\t\t}\n\tcase Uint16:\n\t\tif v.isIndirect() {\n\t\t\treturn uint64(*(*uint16)(v.value))\n\t\t} else {\n\t\t\treturn uint64(uintptr(v.value))\n\t\t}\n\tcase Uint:\n\t\tif v.isIndirect() || unsafe.Sizeof(uint(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\treturn uint64(*(*uint)(v.value))\n\t\t} else {\n\t\t\treturn uint64(uintptr(v.value))\n\t\t}\n\tcase Uint32:\n\t\tif v.isIndirect() || unsafe.Sizeof(uint32(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\treturn uint64(*(*uint32)(v.value))\n\t\t} else {\n\t\t\treturn uint64(uintptr(v.value))\n\t\t}\n\tcase Uint64:\n\t\tif v.isIndirect() || unsafe.Sizeof(uint64(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\treturn uint64(*(*uint64)(v.value))\n\t\t} else {\n\t\t\treturn uint64(uintptr(v.value))\n\t\t}\n\tdefault:\n\t\tpanic(&ValueError{\"Uint\"})\n\t}\n}\n\nfunc (v Value) Float() float64 {\n\tswitch v.Kind() {\n\tcase Float32:\n\t\tif v.isIndirect() || unsafe.Sizeof(float32(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\t// The float is stored as an external value on systems with 16-bit\n\t\t\t// pointers.\n\t\t\treturn float64(*(*float32)(v.value))\n\t\t} else {\n\t\t\t// The float is directly stored in the interface value on systems\n\t\t\t// with 32-bit and 64-bit pointers.\n\t\t\treturn float64(*(*float32)(unsafe.Pointer(&v.value)))\n\t\t}\n\tcase Float64:\n\t\tif v.isIndirect() || unsafe.Sizeof(float64(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\t// For systems with 16-bit and 32-bit pointers.\n\t\t\treturn *(*float64)(v.value)\n\t\t} else {\n\t\t\t// The float is directly stored in the interface value on systems\n\t\t\t// with 64-bit pointers.\n\t\t\treturn *(*float64)(unsafe.Pointer(&v.value))\n\t\t}\n\tdefault:\n\t\tpanic(&ValueError{\"Float\"})\n\t}\n}\n\nfunc (v Value) Complex() complex128 {\n\tswitch v.Kind() {\n\tcase Complex64:\n\t\tif v.isIndirect() || unsafe.Sizeof(complex64(0)) > unsafe.Sizeof(uintptr(0)) {\n\t\t\t// The complex number is stored as an external value on systems with\n\t\t\t// 16-bit and 32-bit pointers.\n\t\t\treturn complex128(*(*complex64)(v.value))\n\t\t} else {\n\t\t\t// The complex number is directly stored in the interface value on\n\t\t\t// systems with 64-bit pointers.\n\t\t\treturn complex128(*(*complex64)(unsafe.Pointer(&v.value)))\n\t\t}\n\tcase Complex128:\n\t\t// This is a 128-bit value, which is always stored as an external value.\n\t\t// It may be stored in the pointer directly on very uncommon\n\t\t// architectures with 128-bit pointers, however.\n\t\treturn *(*complex128)(v.value)\n\tdefault:\n\t\tpanic(&ValueError{\"Complex\"})\n\t}\n}\n\nfunc (v Value) String() string {\n\tswitch v.Kind() {\n\tcase String:\n\t\t// A string value is always bigger than a pointer as it is made of a\n\t\t// pointer and a length.\n\t\treturn *(*string)(v.value)\n\tdefault:\n\t\t// Special case because of the special treatment of .String() in Go.\n\t\treturn \"<T>\"\n\t}\n}\n\nfunc (v Value) Bytes() []byte {\n\tpanic(\"unimplemented: (reflect.Value).Bytes()\")\n}\n\nfunc (v Value) Slice(i, j int) Value {\n\tpanic(\"unimplemented: (reflect.Value).Slice()\")\n}\n\n//go:linkname maplen runtime.hashmapLenUnsafePointer\nfunc maplen(p unsafe.Pointer) int\n\n//go:linkname chanlen runtime.chanLenUnsafePointer\nfunc chanlen(p unsafe.Pointer) int\n\n// Len returns the length of this value for slices, strings, arrays, channels,\n// and maps. For other types, it panics.\nfunc (v Value) Len() int {\n\tswitch v.typecode.Kind() {\n\tcase Array:\n\t\treturn v.typecode.Len()\n\tcase Chan:\n\t\treturn chanlen(v.pointer())\n\tcase Map:\n\t\treturn maplen(v.pointer())\n\tcase Slice:\n\t\treturn int((*sliceHeader)(v.value).len)\n\tcase String:\n\t\treturn int((*stringHeader)(v.value).len)\n\tdefault:\n\t\tpanic(&ValueError{\"Len\"})\n\t}\n}\n\n//go:linkname chancap runtime.chanCapUnsafePointer\nfunc chancap(p unsafe.Pointer) int\n\n// Cap returns the capacity of this value for arrays, channels and slices.\n// For other types, it panics.\nfunc (v Value) Cap() int {\n\tswitch v.typecode.Kind() {\n\tcase Array:\n\t\treturn v.typecode.Len()\n\tcase Chan:\n\t\treturn chancap(v.pointer())\n\tcase Slice:\n\t\treturn int((*sliceHeader)(v.value).cap)\n\tdefault:\n\t\tpanic(&ValueError{\"Cap\"})\n\t}\n}\n\n// NumField returns the number of fields of this struct. It panics for other\n// value types.\nfunc (v Value) NumField() int {\n\treturn v.typecode.NumField()\n}\n\nfunc (v Value) Elem() Value {\n\tswitch v.Kind() {\n\tcase Ptr:\n\t\tptr := v.pointer()\n\t\tif ptr == nil {\n\t\t\treturn Value{}\n\t\t}\n\t\treturn Value{\n\t\t\ttypecode: v.typecode.elem(),\n\t\t\tvalue:    ptr,\n\t\t\tflags:    v.flags | valueFlagIndirect,\n\t\t}\n\tcase Interface:\n\t\ttypecode, value := decomposeInterface(*(*interface{})(v.value))\n\t\treturn Value{\n\t\t\ttypecode: typecode,\n\t\t\tvalue:    value,\n\t\t\tflags:    v.flags &^ valueFlagIndirect,\n\t\t}\n\tdefault:\n\t\tpanic(&ValueError{\"Elem\"})\n\t}\n}\n\n// Field returns the value of the i'th field of this struct.\nfunc (v Value) Field(i int) Value {\n\tstructField := v.typecode.rawField(i)\n\tflags := v.flags\n\tif structField.PkgPath != \"\" {\n\t\t// The fact that PkgPath is present means that this field is not\n\t\t// exported.\n\t\tflags &^= valueFlagExported\n\t}\n\n\tsize := v.typecode.Size()\n\tfieldType := structField.Type\n\tfieldSize := fieldType.Size()\n\tif v.isIndirect() || fieldSize > unsafe.Sizeof(uintptr(0)) {\n\t\t// v.value was already a pointer to the value and it should stay that\n\t\t// way.\n\t\treturn Value{\n\t\t\tflags:    flags,\n\t\t\ttypecode: fieldType,\n\t\t\tvalue:    unsafe.Pointer(uintptr(v.value) + structField.Offset),\n\t\t}\n\t}\n\n\t// The fieldSize is smaller than uintptr, which means that the value will\n\t// have to be stored directly in the interface value.\n\n\tif fieldSize == 0 {\n\t\t// The struct field is zero sized.\n\t\t// This is a rare situation, but because it's undefined behavior\n\t\t// to shift the size of the value (zeroing the value), handle this\n\t\t// situation explicitly.\n\t\treturn Value{\n\t\t\tflags:    flags,\n\t\t\ttypecode: fieldType,\n\t\t\tvalue:    unsafe.Pointer(uintptr(0)),\n\t\t}\n\t}\n\n\tif size > unsafe.Sizeof(uintptr(0)) {\n\t\t// The value was not stored in the interface before but will be\n\t\t// afterwards, so load the value (from the correct offset) and return\n\t\t// it.\n\t\tptr := unsafe.Pointer(uintptr(v.value) + structField.Offset)\n\t\tvalue := unsafe.Pointer(loadValue(ptr, fieldSize))\n\t\treturn Value{\n\t\t\tflags:    0,\n\t\t\ttypecode: fieldType,\n\t\t\tvalue:    value,\n\t\t}\n\t}\n\n\t// The value was already stored directly in the interface and it still\n\t// is. Cut out the part of the value that we need.\n\tvalue := maskAndShift(uintptr(v.value), structField.Offset, fieldSize)\n\treturn Value{\n\t\tflags:    flags,\n\t\ttypecode: fieldType,\n\t\tvalue:    unsafe.Pointer(value),\n\t}\n}\n\nfunc (v Value) Index(i int) Value {\n\tswitch v.Kind() {\n\tcase Slice:\n\t\t// Extract an element from the slice.\n\t\tslice := *(*sliceHeader)(v.value)\n\t\tif uint(i) >= uint(slice.len) {\n\t\t\tpanic(\"reflect: slice index out of range\")\n\t\t}\n\t\telem := Value{\n\t\t\ttypecode: v.typecode.elem(),\n\t\t\tflags:    v.flags | valueFlagIndirect,\n\t\t}\n\t\taddr := uintptr(slice.data) + elem.typecode.Size()*uintptr(i) // pointer to new value\n\t\telem.value = unsafe.Pointer(addr)\n\t\treturn elem\n\tcase String:\n\t\t// Extract a character from a string.\n\t\t// A string is never stored directly in the interface, but always as a\n\t\t// pointer to the string value.\n\t\ts := *(*stringHeader)(v.value)\n\t\tif uint(i) >= uint(s.len) {\n\t\t\tpanic(\"reflect: string index out of range\")\n\t\t}\n\t\treturn Value{\n\t\t\ttypecode: Uint8.basicType(),\n\t\t\tvalue:    unsafe.Pointer(uintptr(*(*uint8)(unsafe.Pointer(uintptr(s.data) + uintptr(i))))),\n\t\t}\n\tcase Array:\n\t\t// Extract an element from the array.\n\t\telemType := v.typecode.elem()\n\t\telemSize := elemType.Size()\n\t\tsize := v.typecode.Size()\n\t\tif size == 0 {\n\t\t\t// The element size is 0 and/or the length of the array is 0.\n\t\t\treturn Value{\n\t\t\t\ttypecode: v.typecode.elem(),\n\t\t\t\tflags:    v.flags,\n\t\t\t}\n\t\t}\n\t\tif elemSize > unsafe.Sizeof(uintptr(0)) {\n\t\t\t// The resulting value doesn't fit in a pointer so must be\n\t\t\t// indirect. Also, because size != 0 this implies that the array\n\t\t\t// length must be != 0, and thus that the total size is at least\n\t\t\t// elemSize.\n\t\t\taddr := uintptr(v.value) + elemSize*uintptr(i) // pointer to new value\n\t\t\treturn Value{\n\t\t\t\ttypecode: v.typecode.elem(),\n\t\t\t\tflags:    v.flags,\n\t\t\t\tvalue:    unsafe.Pointer(addr),\n\t\t\t}\n\t\t}\n\n\t\tif size > unsafe.Sizeof(uintptr(0)) || v.isIndirect() {\n\t\t\t// The element fits in a pointer, but the array is not stored in the pointer directly.\n\t\t\t// Load the value from the pointer.\n\t\t\taddr := unsafe.Pointer(uintptr(v.value) + elemSize*uintptr(i)) // pointer to new value\n\t\t\tvalue := addr\n\t\t\tif !v.isIndirect() {\n\t\t\t\t// Use a pointer to the value (don't load the value) if the\n\t\t\t\t// 'indirect' flag is set.\n\t\t\t\tvalue = unsafe.Pointer(loadValue(addr, elemSize))\n\t\t\t}\n\t\t\treturn Value{\n\t\t\t\ttypecode: v.typecode.elem(),\n\t\t\t\tflags:    v.flags,\n\t\t\t\tvalue:    value,\n\t\t\t}\n\t\t}\n\n\t\t// The value fits in a pointer, so extract it with some shifting and\n\t\t// masking.\n\t\toffset := elemSize * uintptr(i)\n\t\tvalue := maskAndShift(uintptr(v.value), offset, elemSize)\n\t\treturn Value{\n\t\t\ttypecode: v.typecode.elem(),\n\t\t\tflags:    v.flags,\n\t\t\tvalue:    unsafe.Pointer(value),\n\t\t}\n\tdefault:\n\t\tpanic(&ValueError{\"Index\"})\n\t}\n}\n\n// loadValue loads a value that may or may not be word-aligned. The number of\n// bytes given in size are loaded. The biggest possible size it can load is that\n// of an uintptr.\nfunc loadValue(ptr unsafe.Pointer, size uintptr) uintptr {\n\tloadedValue := uintptr(0)\n\tshift := uintptr(0)\n\tfor i := uintptr(0); i < size; i++ {\n\t\tloadedValue |= uintptr(*(*byte)(ptr)) << shift\n\t\tshift += 8\n\t\tptr = unsafe.Pointer(uintptr(ptr) + 1)\n\t}\n\treturn loadedValue\n}\n\n// maskAndShift cuts out a part of a uintptr. Note that the offset may not be 0.\nfunc maskAndShift(value, offset, size uintptr) uintptr {\n\tmask := ^uintptr(0) >> ((unsafe.Sizeof(uintptr(0)) - size) * 8)\n\treturn (uintptr(value) >> (offset * 8)) & mask\n}\n\nfunc (v Value) NumMethod() int {\n\treturn v.typecode.NumMethod()\n}\n\nfunc (v Value) OverflowFloat(x float64) bool {\n\tpanic(\"unimplemented: (reflect.Value).OverflowFloat()\")\n}\n\nfunc (v Value) MapKeys() []Value {\n\tpanic(\"unimplemented: (reflect.Value).MapKeys()\")\n}\n\nfunc (v Value) MapIndex(key Value) Value {\n\tpanic(\"unimplemented: (reflect.Value).MapIndex()\")\n}\n\nfunc (v Value) MapRange() *MapIter {\n\tpanic(\"unimplemented: (reflect.Value).MapRange()\")\n}\n\ntype MapIter struct {\n}\n\nfunc (it *MapIter) Key() Value {\n\tpanic(\"unimplemented: (*reflect.MapIter).Key()\")\n}\n\nfunc (it *MapIter) Value() Value {\n\tpanic(\"unimplemented: (*reflect.MapIter).Value()\")\n}\n\nfunc (it *MapIter) Next() bool {\n\tpanic(\"unimplemented: (*reflect.MapIter).Next()\")\n}\n\nfunc (v Value) Set(x Value) {\n\tv.checkAddressable()\n\tif !v.typecode.AssignableTo(x.typecode) {\n\t\tpanic(\"reflect: cannot set\")\n\t}\n\tsize := v.typecode.Size()\n\txptr := x.value\n\tif size <= unsafe.Sizeof(uintptr(0)) && !x.isIndirect() {\n\t\tvalue := x.value\n\t\txptr = unsafe.Pointer(&value)\n\t}\n\tmemcpy(v.value, xptr, size)\n}\n\nfunc (v Value) SetBool(x bool) {\n\tv.checkAddressable()\n\tswitch v.Kind() {\n\tcase Bool:\n\t\t*(*bool)(v.value) = x\n\tdefault:\n\t\tpanic(&ValueError{\"SetBool\"})\n\t}\n}\n\nfunc (v Value) SetInt(x int64) {\n\tv.checkAddressable()\n\tswitch v.Kind() {\n\tcase Int:\n\t\t*(*int)(v.value) = int(x)\n\tcase Int8:\n\t\t*(*int8)(v.value) = int8(x)\n\tcase Int16:\n\t\t*(*int16)(v.value) = int16(x)\n\tcase Int32:\n\t\t*(*int32)(v.value) = int32(x)\n\tcase Int64:\n\t\t*(*int64)(v.value) = x\n\tdefault:\n\t\tpanic(&ValueError{\"SetInt\"})\n\t}\n}\n\nfunc (v Value) SetUint(x uint64) {\n\tv.checkAddressable()\n\tswitch v.Kind() {\n\tcase Uint:\n\t\t*(*uint)(v.value) = uint(x)\n\tcase Uint8:\n\t\t*(*uint8)(v.value) = uint8(x)\n\tcase Uint16:\n\t\t*(*uint16)(v.value) = uint16(x)\n\tcase Uint32:\n\t\t*(*uint32)(v.value) = uint32(x)\n\tcase Uint64:\n\t\t*(*uint64)(v.value) = x\n\tcase Uintptr:\n\t\t*(*uintptr)(v.value) = uintptr(x)\n\tdefault:\n\t\tpanic(&ValueError{\"SetUint\"})\n\t}\n}\n\nfunc (v Value) SetFloat(x float64) {\n\tv.checkAddressable()\n\tswitch v.Kind() {\n\tcase Float32:\n\t\t*(*float32)(v.value) = float32(x)\n\tcase Float64:\n\t\t*(*float64)(v.value) = x\n\tdefault:\n\t\tpanic(&ValueError{\"SetFloat\"})\n\t}\n}\n\nfunc (v Value) SetComplex(x complex128) {\n\tv.checkAddressable()\n\tswitch v.Kind() {\n\tcase Complex64:\n\t\t*(*complex64)(v.value) = complex64(x)\n\tcase Complex128:\n\t\t*(*complex128)(v.value) = x\n\tdefault:\n\t\tpanic(&ValueError{\"SetComplex\"})\n\t}\n}\n\nfunc (v Value) SetString(x string) {\n\tv.checkAddressable()\n\tswitch v.Kind() {\n\tcase String:\n\t\t*(*string)(v.value) = x\n\tdefault:\n\t\tpanic(&ValueError{\"SetString\"})\n\t}\n}\n\nfunc (v Value) SetBytes(x []byte) {\n\tpanic(\"unimplemented: (reflect.Value).SetBytes()\")\n}\n\nfunc (v Value) SetCap(n int) {\n\tpanic(\"unimplemented: (reflect.Value).SetCap()\")\n}\n\nfunc (v Value) SetLen(n int) {\n\tpanic(\"unimplemented: (reflect.Value).SetLen()\")\n}\n\nfunc (v Value) checkAddressable() {\n\tif !v.isIndirect() {\n\t\tpanic(\"reflect: value is not addressable\")\n\t}\n}\n\nfunc (v Value) OverflowInt(x int64) bool {\n\tpanic(\"unimplemented: reflect.OverflowInt()\")\n}\n\nfunc (v Value) OverflowUint(x uint64) bool {\n\tpanic(\"unimplemented: reflect.OverflowUint()\")\n}\n\nfunc (v Value) Convert(t Type) Value {\n\tpanic(\"unimplemented: (reflect.Value).Convert()\")\n}\n\nfunc MakeSlice(typ Type, len, cap int) Value {\n\tpanic(\"unimplemented: reflect.MakeSlice()\")\n}\n\nfunc Zero(typ Type) Value {\n\tpanic(\"unimplemented: reflect.Zero()\")\n}\n\n// New is the reflect equivalent of the new(T) keyword, returning a pointer to a\n// new value of the given type.\nfunc New(typ Type) Value {\n\treturn Value{\n\t\ttypecode: PtrTo(typ).(rawType),\n\t\tvalue:    alloc(typ.Size(), nil),\n\t\tflags:    valueFlagExported,\n\t}\n}\n\ntype funcHeader struct {\n\tContext unsafe.Pointer\n\tCode    unsafe.Pointer\n}\n\ntype SliceHeader struct {\n\tData uintptr\n\tLen  uintptr\n\tCap  uintptr\n}\n\n// Slice header that matches the underlying structure. Used for when we switch\n// to a precise GC, which needs to know exactly where pointers live.\ntype sliceHeader struct {\n\tdata unsafe.Pointer\n\tlen  uintptr\n\tcap  uintptr\n}\n\ntype StringHeader struct {\n\tData uintptr\n\tLen  uintptr\n}\n\n// Like sliceHeader, this type is used internally to make sure pointer and\n// non-pointer fields match those of actual strings.\ntype stringHeader struct {\n\tdata unsafe.Pointer\n\tlen  uintptr\n}\n\ntype ValueError struct {\n\tMethod string\n}\n\nfunc (e *ValueError) Error() string {\n\treturn \"reflect: call of reflect.Value.\" + e.Method + \" on invalid type\"\n}\n\n// Calls to this function are converted to LLVM intrinsic calls such as\n// llvm.memcpy.p0i8.p0i8.i32().\nfunc memcpy(dst, src unsafe.Pointer, size uintptr)\n\n//go:linkname alloc runtime.alloc\nfunc alloc(size uintptr, layout unsafe.Pointer) unsafe.Pointer\n\n//go:linkname sliceAppend runtime.sliceAppend\nfunc sliceAppend(srcBuf, elemsBuf unsafe.Pointer, srcLen, srcCap, elemsLen uintptr, elemSize uintptr) (unsafe.Pointer, uintptr, uintptr)\n\n// Copy copies the contents of src into dst until either\n// dst has been filled or src has been exhausted.\nfunc Copy(dst, src Value) int {\n\tpanic(\"unimplemented: reflect.Copy()\")\n}\n\n// Append appends the values x to a slice s and returns the resulting slice.\n// As in Go, each x's value must be assignable to the slice's element type.\nfunc Append(s Value, x ...Value) Value {\n\tpanic(\"unimplemented: reflect.Append()\")\n}\n\n// AppendSlice appends a slice t to a slice s and returns the resulting slice.\n// The slices s and t must have the same element type.\nfunc AppendSlice(s, t Value) Value {\n\tif s.typecode.Kind() != Slice || t.typecode.Kind() != Slice || s.typecode != t.typecode {\n\t\t// Not a very helpful error message, but shortened to just one error to\n\t\t// keep code size down.\n\t\tpanic(\"reflect.AppendSlice: invalid types\")\n\t}\n\tif !s.isExported() || !t.isExported() {\n\t\t// One of the sides was not exported, so can't access the data.\n\t\tpanic(\"reflect.AppendSlice: unexported\")\n\t}\n\tsSlice := (*sliceHeader)(s.value)\n\ttSlice := (*sliceHeader)(t.value)\n\telemSize := s.typecode.elem().Size()\n\tptr, len, cap := sliceAppend(sSlice.data, tSlice.data, sSlice.len, sSlice.cap, tSlice.len, elemSize)\n\tresult := &sliceHeader{\n\t\tdata: ptr,\n\t\tlen:  len,\n\t\tcap:  cap,\n\t}\n\treturn Value{\n\t\ttypecode: s.typecode,\n\t\tvalue:    unsafe.Pointer(result),\n\t\tflags:    valueFlagExported,\n\t}\n}\n\nfunc (v Value) SetMapIndex(key, elem Value) {\n\tpanic(\"unimplemented: (reflect.Value).SetMapIndex()\")\n}\n\n// FieldByIndex returns the nested field corresponding to index.\nfunc (v Value) FieldByIndex(index []int) Value {\n\tpanic(\"unimplemented: (reflect.Value).FieldByIndex()\")\n}\n\nfunc (v Value) FieldByName(name string) Value {\n\tpanic(\"unimplemented: (reflect.Value).FieldByName()\")\n}\n\n// MakeMap creates a new map with the specified type.\nfunc MakeMap(typ Type) Value {\n\tpanic(\"unimplemented: reflect.MakeMap()\")\n}\n\nfunc (v Value) Call(in []Value) []Value {\n\tpanic(\"unimplemented: (reflect.Value).Call()\")\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage reflect\n\nimport (\n\t\"unsafe\"\n)\n\n// The compiler uses a compact encoding to store type information. Unlike the\n// main Go compiler, most of the types are stored directly in the type code.\n//\n// Type code bit allocation:\n// xxxxx0: basic types, where xxxxx is the basic type number (never 0).\n//         The higher bits indicate the named type, if any.\n//  nxxx1: complex types, where n indicates whether this is a named type (named\n//         if set) and xxx contains the type kind number:\n//             0 (0001): Chan\n//             1 (0011): Interface\n//             2 (0101): Ptr\n//             3 (0111): Slice\n//             4 (1001): Array\n//             5 (1011): Func\n//             6 (1101): Map\n//             7 (1111): Struct\n//         The higher bits are either the contents of the type depending on the\n//         type (if n is clear) or indicate the number of the named type (if n\n//         is set).\n\ntype Kind uintptr\n\n// Copied from reflect/type.go\n// https://golang.org/src/reflect/type.go?s=8302:8316#L217\nconst (\n\tInvalid Kind = iota\n\tBool\n\tInt\n\tInt8\n\tInt16\n\tInt32\n\tInt64\n\tUint\n\tUint8\n\tUint16\n\tUint32\n\tUint64\n\tUintptr\n\tFloat32\n\tFloat64\n\tComplex64\n\tComplex128\n\tString\n\tUnsafePointer\n\tChan\n\tInterface\n\tPtr\n\tSlice\n\tArray\n\tFunc\n\tMap\n\tStruct\n)\n\nfunc (k Kind) String() string {\n\tswitch k {\n\tcase Bool:\n\t\treturn \"bool\"\n\tcase Int:\n\t\treturn \"int\"\n\tcase Int8:\n\t\treturn \"int8\"\n\tcase Int16:\n\t\treturn \"int16\"\n\tcase Int32:\n\t\treturn \"int32\"\n\tcase Int64:\n\t\treturn \"int64\"\n\tcase Uint:\n\t\treturn \"uint\"\n\tcase Uint8:\n\t\treturn \"uint8\"\n\tcase Uint16:\n\t\treturn \"uint16\"\n\tcase Uint32:\n\t\treturn \"uint32\"\n\tcase Uint64:\n\t\treturn \"uint64\"\n\tcase Uintptr:\n\t\treturn \"uintptr\"\n\tcase Float32:\n\t\treturn \"float32\"\n\tcase Float64:\n\t\treturn \"float64\"\n\tcase Complex64:\n\t\treturn \"complex64\"\n\tcase Complex128:\n\t\treturn \"complex128\"\n\tcase String:\n\t\treturn \"string\"\n\tcase UnsafePointer:\n\t\treturn \"unsafe.Pointer\"\n\tcase Chan:\n\t\treturn \"chan\"\n\tcase Interface:\n\t\treturn \"interface\"\n\tcase Ptr:\n\t\treturn \"ptr\"\n\tcase Slice:\n\t\treturn \"slice\"\n\tcase Array:\n\t\treturn \"array\"\n\tcase Func:\n\t\treturn \"func\"\n\tcase Map:\n\t\treturn \"map\"\n\tcase Struct:\n\t\treturn \"struct\"\n\tdefault:\n\t\treturn \"invalid\"\n\t}\n}\n\n// basicType returns a new Type for this kind if Kind is a basic type.\nfunc (k Kind) basicType() rawType {\n\treturn rawType(k << 1)\n}\n\n// The following Type type has been copied almost entirely from\n// https://github.com/golang/go/blob/go1.15/src/reflect/type.go#L27-L212.\n// Some methods have been commented out as they haven't yet been implemented.\n\n// Type is the representation of a Go type.\n//\n// Not all methods apply to all kinds of types. Restrictions,\n// if any, are noted in the documentation for each method.\n// Use the Kind method to find out the kind of type before\n// calling kind-specific methods. Calling a method\n// inappropriate to the kind of type causes a run-time panic.\n//\n// Type values are comparable, such as with the == operator,\n// so they can be used as map keys.\n// Two Type values are equal if they represent identical types.\ntype Type interface {\n\t// Methods applicable to all types.\n\n\t// Align returns the alignment in bytes of a value of\n\t// this type when allocated in memory.\n\tAlign() int\n\n\t// FieldAlign returns the alignment in bytes of a value of\n\t// this type when used as a field in a struct.\n\tFieldAlign() int\n\n\t// Method returns the i'th method in the type's method set.\n\t// It panics if i is not in the range [0, NumMethod()).\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\t//\n\t// Only exported methods are accessible and they are sorted in\n\t// lexicographic order.\n\t//Method(int) Method\n\n\t// MethodByName returns the method with that name in the type's\n\t// method set and a boolean indicating if the method was found.\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\t//MethodByName(string) (Method, bool)\n\n\t// NumMethod returns the number of exported methods in the type's method set.\n\tNumMethod() int\n\n\t// Name returns the type's name within its package for a defined type.\n\t// For other (non-defined) types it returns the empty string.\n\tName() string\n\n\t// PkgPath returns a defined type's package path, that is, the import path\n\t// that uniquely identifies the package, such as \"encoding/base64\".\n\t// If the type was predeclared (string, error) or not defined (*T, struct{},\n\t// []int, or A where A is an alias for a non-defined type), the package path\n\t// will be the empty string.\n\t//PkgPath() string\n\n\t// Size returns the number of bytes needed to store\n\t// a value of the given type; it is analogous to unsafe.Sizeof.\n\tSize() uintptr\n\n\t// String returns a string representation of the type.\n\t// The string representation may use shortened package names\n\t// (e.g., base64 instead of \"encoding/base64\") and is not\n\t// guaranteed to be unique among types. To test for type identity,\n\t// compare the Types directly.\n\tString() string\n\n\t// Kind returns the specific kind of this type.\n\tKind() Kind\n\n\t// Implements reports whether the type implements the interface type u.\n\tImplements(u Type) bool\n\n\t// AssignableTo reports whether a value of the type is assignable to type u.\n\tAssignableTo(u Type) bool\n\n\t// ConvertibleTo reports whether a value of the type is convertible to type u.\n\tConvertibleTo(u Type) bool\n\n\t// Comparable reports whether values of this type are comparable.\n\tComparable() bool\n\n\t// Methods applicable only to some types, depending on Kind.\n\t// The methods allowed for each kind are:\n\t//\n\t//\tInt*, Uint*, Float*, Complex*: Bits\n\t//\tArray: Elem, Len\n\t//\tChan: ChanDir, Elem\n\t//\tFunc: In, NumIn, Out, NumOut, IsVariadic.\n\t//\tMap: Key, Elem\n\t//\tPtr: Elem\n\t//\tSlice: Elem\n\t//\tStruct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField\n\n\t// Bits returns the size of the type in bits.\n\t// It panics if the type's Kind is not one of the\n\t// sized or unsized Int, Uint, Float, or Complex kinds.\n\tBits() int\n\n\t// ChanDir returns a channel type's direction.\n\t// It panics if the type's Kind is not Chan.\n\t//ChanDir() ChanDir\n\n\t// IsVariadic reports whether a function type's final input parameter\n\t// is a \"...\" parameter. If so, t.In(t.NumIn() - 1) returns the parameter's\n\t// implicit actual type []T.\n\t//\n\t// For concreteness, if t represents func(x int, y ... float64), then\n\t//\n\t//\tt.NumIn() == 2\n\t//\tt.In(0) is the reflect.Type for \"int\"\n\t//\tt.In(1) is the reflect.Type for \"[]float64\"\n\t//\tt.IsVariadic() == true\n\t//\n\t// IsVariadic panics if the type's Kind is not Func.\n\t//IsVariadic() bool\n\n\t// Elem returns a type's element type.\n\t// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.\n\tElem() Type\n\n\t// Field returns a struct type's i'th field.\n\t// It panics if the type's Kind is not Struct.\n\t// It panics if i is not in the range [0, NumField()).\n\tField(i int) StructField\n\n\t// FieldByIndex returns the nested field corresponding\n\t// to the index sequence. It is equivalent to calling Field\n\t// successively for each index i.\n\t// It panics if the type's Kind is not Struct.\n\t//FieldByIndex(index []int) StructField\n\n\t// FieldByName returns the struct field with the given name\n\t// and a boolean indicating if the field was found.\n\t//FieldByName(name string) (StructField, bool)\n\n\t// FieldByNameFunc returns the struct field with a name\n\t// that satisfies the match function and a boolean indicating if\n\t// the field was found.\n\t//\n\t// FieldByNameFunc considers the fields in the struct itself\n\t// and then the fields in any embedded structs, in breadth first order,\n\t// stopping at the shallowest nesting depth containing one or more\n\t// fields satisfying the match function. If multiple fields at that depth\n\t// satisfy the match function, they cancel each other\n\t// and FieldByNameFunc returns no match.\n\t// This behavior mirrors Go's handling of name lookup in\n\t// structs containing embedded fields.\n\t//FieldByNameFunc(match func(string) bool) (StructField, bool)\n\n\t// In returns the type of a function type's i'th input parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumIn()).\n\t//In(i int) Type\n\n\t// Key returns a map type's key type.\n\t// It panics if the type's Kind is not Map.\n\tKey() Type\n\n\t// Len returns an array type's length.\n\t// It panics if the type's Kind is not Array.\n\tLen() int\n\n\t// NumField returns a struct type's field count.\n\t// It panics if the type's Kind is not Struct.\n\tNumField() int\n\n\t// NumIn returns a function type's input parameter count.\n\t// It panics if the type's Kind is not Func.\n\t//NumIn() int\n\n\t// NumOut returns a function type's output parameter count.\n\t// It panics if the type's Kind is not Func.\n\t//NumOut() int\n\n\t// Out returns the type of a function type's i'th output parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumOut()).\n\t//Out(i int) Type\n}\n\n// The typecode as used in an interface{}.\ntype rawType uintptr\n\nfunc TypeOf(i interface{}) Type {\n\treturn ValueOf(i).typecode\n}\n\nfunc PtrTo(t Type) Type {\n\tif t.Kind() == Ptr {\n\t\tpanic(\"reflect: cannot make **T type\")\n\t}\n\tptrType := t.(rawType)<<5 | 5 // 0b0101 == 5\n\tif ptrType>>5 != t {\n\t\tpanic(\"reflect: PtrTo type does not fit\")\n\t}\n\treturn ptrType\n}\n\nfunc (t rawType) String() string {\n\treturn \"T\"\n}\n\nfunc (t rawType) Kind() Kind {\n\tif t%2 == 0 {\n\t\t// basic type\n\t\treturn Kind((t >> 1) % 32)\n\t} else {\n\t\treturn Kind(t>>1)%8 + 19\n\t}\n}\n\n// Elem returns the element type for channel, slice and array types, the\n// pointed-to value for pointer types, and the key type for map types.\nfunc (t rawType) Elem() Type {\n\treturn t.elem()\n}\n\nfunc (t rawType) elem() rawType {\n\tswitch t.Kind() {\n\tcase Chan, Ptr, Slice:\n\t\treturn t.stripPrefix()\n\tcase Array:\n\t\tindex := t.stripPrefix()\n\t\telem, _ := readVarint(unsafe.Pointer(uintptr(unsafe.Pointer(&arrayTypesSidetable)) + uintptr(index)))\n\t\treturn rawType(elem)\n\tdefault: // not implemented: Map\n\t\tpanic(\"unimplemented: (reflect.Type).Elem()\")\n\t}\n}\n\n// stripPrefix removes the \"prefix\" (the low 5 bits of the type code) from\n// the type code. If this is a named type, it will resolve the underlying type\n// (which is the data for this named type). If it is not, the lower bits are\n// simply shifted off.\n//\n// The behavior is only defined for non-basic types.\nfunc (t rawType) stripPrefix() rawType {\n\t// Look at the 'n' bit in the type code (see the top of this file) to see\n\t// whether this is a named type.\n\tif (t>>4)%2 != 0 {\n\t\t// This is a named type. The data is stored in a sidetable.\n\t\tnamedTypeNum := t >> 5\n\t\tn := *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&namedNonBasicTypesSidetable)) + uintptr(namedTypeNum)*unsafe.Sizeof(uintptr(0))))\n\t\treturn rawType(n)\n\t}\n\t// Not a named type, so the value is stored directly in the type code.\n\treturn t >> 5\n}\n\n// Field returns the type of the i'th field of this struct type. It panics if t\n// is not a struct type.\nfunc (t rawType) Field(i int) StructField {\n\tfield := t.rawField(i)\n\treturn StructField{\n\t\tName:      field.Name,\n\t\tPkgPath:   field.PkgPath,\n\t\tType:      field.Type, // note: converts rawType to Type\n\t\tTag:       field.Tag,\n\t\tAnonymous: field.Anonymous,\n\t\tOffset:    field.Offset,\n\t}\n}\n\n// rawField returns nearly the same value as Field but without converting the\n// Type member to an interface.\n//\n// For internal use only.\nfunc (t rawType) rawField(i int) rawStructField {\n\tif t.Kind() != Struct {\n\t\tpanic(&TypeError{\"Field\"})\n\t}\n\tstructIdentifier := t.stripPrefix()\n\n\tnumField, p := readVarint(unsafe.Pointer(uintptr(unsafe.Pointer(&structTypesSidetable)) + uintptr(structIdentifier)))\n\tif uint(i) >= uint(numField) {\n\t\tpanic(\"reflect: field index out of range\")\n\t}\n\n\t// Iterate over every field in the struct and update the StructField each\n\t// time, until the target field has been reached. This is very much not\n\t// efficient, but it is easy to implement.\n\t// Adding a jump table at the start to jump to the field directly would\n\t// make this much faster, but that would also impact code size.\n\tfield := rawStructField{}\n\toffset := uintptr(0)\n\tfor fieldNum := 0; fieldNum <= i; fieldNum++ {\n\t\t// Read some flags of this field, like whether the field is an\n\t\t// embedded field.\n\t\tflagsByte := *(*uint8)(p)\n\t\tp = unsafe.Pointer(uintptr(p) + 1)\n\n\t\t// Read the type of this struct field.\n\t\tvar fieldTypeVal uintptr\n\t\tfieldTypeVal, p = readVarint(p)\n\t\tfieldType := rawType(fieldTypeVal)\n\t\tfield.Type = fieldType\n\n\t\t// Move Offset forward to align it to this field's alignment.\n\t\t// Assume alignment is a power of two.\n\t\toffset = align(offset, uintptr(fieldType.Align()))\n\t\tfield.Offset = offset\n\t\toffset += fieldType.Size() // starting (unaligned) offset for next field\n\n\t\t// Read the field name.\n\t\tvar nameNum uintptr\n\t\tnameNum, p = readVarint(p)\n\t\tfield.Name = readStringSidetable(unsafe.Pointer(&structNamesSidetable), nameNum)\n\n\t\t// The first bit in the flagsByte indicates whether this is an embedded\n\t\t// field.\n\t\tfield.Anonymous = flagsByte&1 != 0\n\n\t\t// The second bit indicates whether there is a tag.\n\t\tif flagsByte&2 != 0 {\n\t\t\t// There is a tag.\n\t\t\tvar tagNum uintptr\n\t\t\ttagNum, p = readVarint(p)\n\t\t\tfield.Tag = StructTag(readStringSidetable(unsafe.Pointer(&structNamesSidetable), tagNum))\n\t\t} else {\n\t\t\t// There is no tag.\n\t\t\tfield.Tag = \"\"\n\t\t}\n\n\t\t// The third bit indicates whether this field is exported.\n\t\tif flagsByte&4 != 0 {\n\t\t\t// This field is exported.\n\t\t\tfield.PkgPath = \"\"\n\t\t} else {\n\t\t\t// This field is unexported.\n\t\t\t// TODO: list the real package path here. Storing it should not\n\t\t\t// significantly impact binary size as there is only a limited\n\t\t\t// number of packages in any program.\n\t\t\tfield.PkgPath = \"<unimplemented>\"\n\t\t}\n\t}\n\n\treturn field\n}\n\n// Bits returns the number of bits that this type uses. It is only valid for\n// arithmetic types (integers, floats, and complex numbers). For other types, it\n// will panic.\nfunc (t rawType) Bits() int {\n\tkind := t.Kind()\n\tif kind >= Int && kind <= Complex128 {\n\t\treturn int(t.Size()) * 8\n\t}\n\tpanic(TypeError{\"Bits\"})\n}\n\n// Len returns the number of elements in this array. It panics of the type kind\n// is not Array.\nfunc (t rawType) Len() int {\n\tif t.Kind() != Array {\n\t\tpanic(TypeError{\"Len\"})\n\t}\n\n\t// skip past the element type\n\tarrayIdentifier := t.stripPrefix()\n\t_, p := readVarint(unsafe.Pointer(uintptr(unsafe.Pointer(&arrayTypesSidetable)) + uintptr(arrayIdentifier)))\n\n\t// Read the array length.\n\tarrayLen, _ := readVarint(p)\n\treturn int(arrayLen)\n}\n\n// NumField returns the number of fields of a struct type. It panics for other\n// type kinds.\nfunc (t rawType) NumField() int {\n\tif t.Kind() != Struct {\n\t\tpanic(&TypeError{\"NumField\"})\n\t}\n\tstructIdentifier := t.stripPrefix()\n\tn, _ := readVarint(unsafe.Pointer(uintptr(unsafe.Pointer(&structTypesSidetable)) + uintptr(structIdentifier)))\n\treturn int(n)\n}\n\n// Size returns the size in bytes of a given type. It is similar to\n// unsafe.Sizeof.\nfunc (t rawType) Size() uintptr {\n\tswitch t.Kind() {\n\tcase Bool, Int8, Uint8:\n\t\treturn 1\n\tcase Int16, Uint16:\n\t\treturn 2\n\tcase Int32, Uint32:\n\t\treturn 4\n\tcase Int64, Uint64:\n\t\treturn 8\n\tcase Int, Uint:\n\t\treturn unsafe.Sizeof(int(0))\n\tcase Uintptr:\n\t\treturn unsafe.Sizeof(uintptr(0))\n\tcase Float32:\n\t\treturn 4\n\tcase Float64:\n\t\treturn 8\n\tcase Complex64:\n\t\treturn 8\n\tcase Complex128:\n\t\treturn 16\n\tcase String:\n\t\treturn unsafe.Sizeof(\"\")\n\tcase UnsafePointer, Chan, Map, Ptr:\n\t\treturn unsafe.Sizeof(uintptr(0))\n\tcase Slice:\n\t\treturn unsafe.Sizeof([]int{})\n\tcase Interface:\n\t\treturn unsafe.Sizeof(interface{}(nil))\n\tcase Func:\n\t\tvar f func()\n\t\treturn unsafe.Sizeof(f)\n\tcase Array:\n\t\treturn t.elem().Size() * uintptr(t.Len())\n\tcase Struct:\n\t\tnumField := t.NumField()\n\t\tif numField == 0 {\n\t\t\treturn 0\n\t\t}\n\t\tlastField := t.rawField(numField - 1)\n\t\treturn align(lastField.Offset+lastField.Type.Size(), uintptr(t.Align()))\n\tdefault:\n\t\tpanic(\"unimplemented: size of type\")\n\t}\n}\n\n// Align returns the alignment of this type. It is similar to calling\n// unsafe.Alignof.\nfunc (t rawType) Align() int {\n\tswitch t.Kind() {\n\tcase Bool, Int8, Uint8:\n\t\treturn int(unsafe.Alignof(int8(0)))\n\tcase Int16, Uint16:\n\t\treturn int(unsafe.Alignof(int16(0)))\n\tcase Int32, Uint32:\n\t\treturn int(unsafe.Alignof(int32(0)))\n\tcase Int64, Uint64:\n\t\treturn int(unsafe.Alignof(int64(0)))\n\tcase Int, Uint:\n\t\treturn int(unsafe.Alignof(int(0)))\n\tcase Uintptr:\n\t\treturn int(unsafe.Alignof(uintptr(0)))\n\tcase Float32:\n\t\treturn int(unsafe.Alignof(float32(0)))\n\tcase Float64:\n\t\treturn int(unsafe.Alignof(float64(0)))\n\tcase Complex64:\n\t\treturn int(unsafe.Alignof(complex64(0)))\n\tcase Complex128:\n\t\treturn int(unsafe.Alignof(complex128(0)))\n\tcase String:\n\t\treturn int(unsafe.Alignof(\"\"))\n\tcase UnsafePointer, Chan, Map, Ptr:\n\t\treturn int(unsafe.Alignof(uintptr(0)))\n\tcase Slice:\n\t\treturn int(unsafe.Alignof([]int(nil)))\n\tcase Interface:\n\t\treturn int(unsafe.Alignof(interface{}(nil)))\n\tcase Func:\n\t\tvar f func()\n\t\treturn int(unsafe.Alignof(f))\n\tcase Struct:\n\t\tnumField := t.NumField()\n\t\talignment := 1\n\t\tfor i := 0; i < numField; i++ {\n\t\t\tfieldAlignment := t.rawField(i).Type.Align()\n\t\t\tif fieldAlignment > alignment {\n\t\t\t\talignment = fieldAlignment\n\t\t\t}\n\t\t}\n\t\treturn alignment\n\tcase Array:\n\t\treturn t.elem().Align()\n\tdefault:\n\t\tpanic(\"unimplemented: alignment of type\")\n\t}\n}\n\n// FieldAlign returns the alignment if this type is used in a struct field. It\n// is currently an alias for Align() but this might change in the future.\nfunc (t rawType) FieldAlign() int {\n\treturn t.Align()\n}\n\n// AssignableTo returns whether a value of type t can be assigned to a variable\n// of type u.\nfunc (t rawType) AssignableTo(u Type) bool {\n\tif t == u.(rawType) {\n\t\treturn true\n\t}\n\tif u.Kind() == Interface {\n\t\tpanic(\"reflect: unimplemented: AssignableTo with interface\")\n\t}\n\treturn false\n}\n\nfunc (t rawType) Implements(u Type) bool {\n\tif u.Kind() != Interface {\n\t\tpanic(\"reflect: non-interface type passed to Type.Implements\")\n\t}\n\treturn t.AssignableTo(u)\n}\n\n// Comparable returns whether values of this type can be compared to each other.\nfunc (t rawType) Comparable() bool {\n\tswitch t.Kind() {\n\tcase Bool, Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:\n\t\treturn true\n\tcase Float32, Float64, Complex64, Complex128:\n\t\treturn true\n\tcase String:\n\t\treturn true\n\tcase UnsafePointer:\n\t\treturn true\n\tcase Chan:\n\t\treturn true\n\tcase Interface:\n\t\treturn true\n\tcase Ptr:\n\t\treturn true\n\tcase Slice:\n\t\treturn false\n\tcase Array:\n\t\treturn t.elem().Comparable()\n\tcase Func:\n\t\treturn false\n\tcase Map:\n\t\treturn false\n\tcase Struct:\n\t\tnumField := t.NumField()\n\t\tfor i := 0; i < numField; i++ {\n\t\t\tif !t.rawField(i).Type.Comparable() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tpanic(TypeError{\"Comparable\"})\n\t}\n}\n\nfunc (t rawType) ConvertibleTo(u Type) bool {\n\tpanic(\"unimplemented: (reflect.Type).ConvertibleTo()\")\n}\n\nfunc (t rawType) NumMethod() int {\n\tpanic(\"unimplemented: (reflect.Type).NumMethod()\")\n}\n\nfunc (t rawType) Name() string {\n\tpanic(\"unimplemented: (reflect.Type).Name()\")\n}\n\nfunc (t rawType) Key() Type {\n\tpanic(\"unimplemented: (reflect.Type).Key()\")\n}\n\n// A StructField describes a single field in a struct.\ntype StructField struct {\n\t// Name indicates the field name.\n\tName string\n\n\t// PkgPath is the package path where the struct containing this field is\n\t// declared for unexported fields, or the empty string for exported fields.\n\tPkgPath string\n\n\tType      Type\n\tTag       StructTag // field tag string\n\tAnonymous bool\n\tOffset    uintptr\n}\n\n// IsExported reports whether the field is exported.\nfunc (f StructField) IsExported() bool {\n\treturn f.PkgPath == \"\"\n}\n\n// rawStructField is the same as StructField but with the Type member replaced\n// with rawType. For internal use only. Avoiding this conversion to the Type\n// interface improves code size in many cases.\ntype rawStructField struct {\n\tName      string\n\tPkgPath   string\n\tType      rawType\n\tTag       StructTag\n\tAnonymous bool\n\tOffset    uintptr\n}\n\n// A StructTag is the tag string in a struct field.\ntype StructTag string\n\n// TODO: it would be feasible to do the key/value splitting at compile time,\n// avoiding the code size cost of doing it at runtime\n\n// Get returns the value associated with key in the tag string.\nfunc (tag StructTag) Get(key string) string {\n\tv, _ := tag.Lookup(key)\n\treturn v\n}\n\n// Lookup returns the value associated with key in the tag string.\nfunc (tag StructTag) Lookup(key string) (value string, ok bool) {\n\tfor tag != \"\" {\n\t\t// Skip leading space.\n\t\ti := 0\n\t\tfor i < len(tag) && tag[i] == ' ' {\n\t\t\ti++\n\t\t}\n\t\ttag = tag[i:]\n\t\tif tag == \"\" {\n\t\t\tbreak\n\t\t}\n\n\t\t// Scan to colon. A space, a quote or a control character is a syntax error.\n\t\t// Strictly speaking, control chars include the range [0x7f, 0x9f], not just\n\t\t// [0x00, 0x1f], but in practice, we ignore the multi-byte control characters\n\t\t// as it is simpler to inspect the tag's bytes than the tag's runes.\n\t\ti = 0\n\t\tfor i < len(tag) && tag[i] > ' ' && tag[i] != ':' && tag[i] != '\"' && tag[i] != 0x7f {\n\t\t\ti++\n\t\t}\n\t\tif i == 0 || i+1 >= len(tag) || tag[i] != ':' || tag[i+1] != '\"' {\n\t\t\tbreak\n\t\t}\n\t\tname := string(tag[:i])\n\t\ttag = tag[i+1:]\n\n\t\t// Scan quoted string to find value.\n\t\ti = 1\n\t\tfor i < len(tag) && tag[i] != '\"' {\n\t\t\tif tag[i] == '\\\\' {\n\t\t\t\ti++\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\tif i >= len(tag) {\n\t\t\tbreak\n\t\t}\n\t\tqvalue := string(tag[:i+1])\n\t\ttag = tag[i+1:]\n\n\t\tif key == name {\n\t\t\tvalue, err := unquote(qvalue)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn value, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// TypeError is the error that is used in a panic when invoking a method on a\n// type that is not applicable to that type.\ntype TypeError struct {\n\tMethod string\n}\n\nfunc (e *TypeError) Error() string {\n\treturn \"reflect: call of reflect.Type.\" + e.Method + \" on invalid type\"\n}\n\nfunc align(offset uintptr, alignment uintptr) uintptr {\n\treturn (offset + alignment - 1) &^ (alignment - 1)\n}\n","package runtime\n\n// This file implements the 'chan' type and send/receive/select operations.\n\n// A channel can be in one of the following states:\n//     empty:\n//       No goroutine is waiting on a send or receive operation. The 'blocked'\n//       member is nil.\n//     recv:\n//       A goroutine tries to receive from the channel. This goroutine is stored\n//       in the 'blocked' member.\n//     send:\n//       The reverse of send. A goroutine tries to send to the channel. This\n//       goroutine is stored in the 'blocked' member.\n//     closed:\n//       The channel is closed. Sends will panic, receives will get a zero value\n//       plus optionally the indication that the channel is zero (with the\n//       comma-ok value in the task).\n//\n// A send/recv transmission is completed by copying from the data element of the\n// sending task to the data element of the receiving task, and setting\n// the 'comma-ok' value to true.\n// A receive operation on a closed channel is completed by zeroing the data\n// element of the receiving task and setting the 'comma-ok' value to false.\n\nimport (\n\t\"internal/task\"\n\t\"runtime/interrupt\"\n\t\"unsafe\"\n)\n\nfunc chanDebug(ch *channel) {\n\tif schedulerDebug {\n\t\tif ch.bufSize > 0 {\n\t\t\tprintln(\"--- channel update:\", ch, ch.state.String(), ch.bufSize, ch.bufUsed)\n\t\t} else {\n\t\t\tprintln(\"--- channel update:\", ch, ch.state.String())\n\t\t}\n\t}\n}\n\n// channelBlockedList is a list of channel operations on a specific channel which are currently blocked.\ntype channelBlockedList struct {\n\t// next is a pointer to the next blocked channel operation on the same channel.\n\tnext *channelBlockedList\n\n\t// t is the task associated with this channel operation.\n\t// If this channel operation is not part of a select, then the pointer field of the state holds the data buffer.\n\t// If this channel operation is part of a select, then the pointer field of the state holds the recieve buffer.\n\t// If this channel operation is a receive, then the data field should be set to zero when resuming due to channel closure.\n\tt *task.Task\n\n\t// s is a pointer to the channel select state corresponding to this operation.\n\t// This will be nil if and only if this channel operation is not part of a select statement.\n\t// If this is a send operation, then the send buffer can be found in this select state.\n\ts *chanSelectState\n\n\t// allSelectOps is a slice containing all of the channel operations involved with this select statement.\n\t// Before resuming the task, all other channel operations on this select statement should be canceled by removing them from their corresponding lists.\n\tallSelectOps []channelBlockedList\n}\n\n// remove takes the current list of blocked channel operations and removes the specified operation.\n// This returns the resulting list, or nil if the resulting list is empty.\n// A nil receiver is treated as an empty list.\nfunc (b *channelBlockedList) remove(old *channelBlockedList) *channelBlockedList {\n\tif b == old {\n\t\treturn b.next\n\t}\n\tc := b\n\tfor ; c != nil && c.next != old; c = c.next {\n\t}\n\tif c != nil {\n\t\tc.next = old.next\n\t}\n\treturn b\n}\n\n// detatch removes all other channel operations that are part of the same select statement.\n// If the input is not part of a select statement, this is a no-op.\n// This must be called before resuming any task blocked on a channel operation in order to ensure that it is not placed on the runqueue twice.\nfunc (b *channelBlockedList) detach() {\n\tif b.allSelectOps == nil {\n\t\t// nothing to do\n\t\treturn\n\t}\n\tfor i, v := range b.allSelectOps {\n\t\t// cancel all other channel operations that are part of this select statement\n\t\tswitch {\n\t\tcase &b.allSelectOps[i] == b:\n\t\t\t// This entry is the one that was already detatched.\n\t\t\tcontinue\n\t\tcase v.t == nil:\n\t\t\t// This entry is not used (nil channel).\n\t\t\tcontinue\n\t\t}\n\t\tv.s.ch.blocked = v.s.ch.blocked.remove(&b.allSelectOps[i])\n\t\tif v.s.ch.blocked == nil {\n\t\t\tif v.s.value == nil {\n\t\t\t\t// recv operation\n\t\t\t\tif v.s.ch.state != chanStateClosed {\n\t\t\t\t\tv.s.ch.state = chanStateEmpty\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// send operation\n\t\t\t\tif v.s.ch.bufUsed == 0 {\n\t\t\t\t\t// unbuffered channel\n\t\t\t\t\tv.s.ch.state = chanStateEmpty\n\t\t\t\t} else {\n\t\t\t\t\t// buffered channel\n\t\t\t\t\tv.s.ch.state = chanStateBuf\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchanDebug(v.s.ch)\n\t}\n}\n\ntype channel struct {\n\telementSize uintptr // the size of one value in this channel\n\tbufSize     uintptr // size of buffer (in elements)\n\tstate       chanState\n\tblocked     *channelBlockedList\n\tbufHead     uintptr        // head index of buffer (next push index)\n\tbufTail     uintptr        // tail index of buffer (next pop index)\n\tbufUsed     uintptr        // number of elements currently in buffer\n\tbuf         unsafe.Pointer // pointer to first element of buffer\n}\n\n// chanMake creates a new channel with the given element size and buffer length in number of elements.\n// This is a compiler intrinsic.\nfunc chanMake(elementSize uintptr, bufSize uintptr) *channel {\n\treturn &channel{\n\t\telementSize: elementSize,\n\t\tbufSize:     bufSize,\n\t\tbuf:         alloc(elementSize*bufSize, nil),\n\t}\n}\n\n// Return the number of entries in this chan, called from the len builtin.\n// A nil chan is defined as having length 0.\n//go:inline\nfunc chanLen(c *channel) int {\n\tif c == nil {\n\t\treturn 0\n\t}\n\treturn int(c.bufUsed)\n}\n\n// wrapper for use in reflect\nfunc chanLenUnsafePointer(p unsafe.Pointer) int {\n\tc := (*channel)(p)\n\treturn chanLen(c)\n}\n\n// Return the capacity of this chan, called from the cap builtin.\n// A nil chan is defined as having capacity 0.\n//go:inline\nfunc chanCap(c *channel) int {\n\tif c == nil {\n\t\treturn 0\n\t}\n\treturn int(c.bufSize)\n}\n\n// wrapper for use in reflect\nfunc chanCapUnsafePointer(p unsafe.Pointer) int {\n\tc := (*channel)(p)\n\treturn chanCap(c)\n}\n\n// resumeRX resumes the next receiver and returns the destination pointer.\n// If the ok value is true, then the caller is expected to store a value into this pointer.\nfunc (ch *channel) resumeRX(ok bool) unsafe.Pointer {\n\t// pop a blocked goroutine off the stack\n\tvar b *channelBlockedList\n\tb, ch.blocked = ch.blocked, ch.blocked.next\n\n\t// get destination pointer\n\tdst := b.t.Ptr\n\n\tif !ok {\n\t\t// the result value is zero\n\t\tmemzero(dst, ch.elementSize)\n\t\tb.t.Data = 0\n\t}\n\n\tif b.s != nil {\n\t\t// tell the select op which case resumed\n\t\tb.t.Ptr = unsafe.Pointer(b.s)\n\n\t\t// detach associated operations\n\t\tb.detach()\n\t}\n\n\t// push task onto runqueue\n\trunqueue.Push(b.t)\n\n\treturn dst\n}\n\n// resumeTX resumes the next sender and returns the source pointer.\n// The caller is expected to read from the value in this pointer before yielding.\nfunc (ch *channel) resumeTX() unsafe.Pointer {\n\t// pop a blocked goroutine off the stack\n\tvar b *channelBlockedList\n\tb, ch.blocked = ch.blocked, ch.blocked.next\n\n\t// get source pointer\n\tsrc := b.t.Ptr\n\n\tif b.s != nil {\n\t\t// use state's source pointer\n\t\tsrc = b.s.value\n\n\t\t// tell the select op which case resumed\n\t\tb.t.Ptr = unsafe.Pointer(b.s)\n\n\t\t// detach associated operations\n\t\tb.detach()\n\t}\n\n\t// push task onto runqueue\n\trunqueue.Push(b.t)\n\n\treturn src\n}\n\n// push value to end of channel if space is available\n// returns whether there was space for the value in the buffer\nfunc (ch *channel) push(value unsafe.Pointer) bool {\n\t// immediately return false if the channel is not buffered\n\tif ch.bufSize == 0 {\n\t\treturn false\n\t}\n\n\t// ensure space is available\n\tif ch.bufUsed == ch.bufSize {\n\t\treturn false\n\t}\n\n\t// copy value to buffer\n\tmemcpy(\n\t\tunsafe.Pointer( // pointer to the base of the buffer + offset = pointer to destination element\n\t\t\tuintptr(ch.buf)+\n\t\t\t\tuintptr( // element size * equivalent slice index = offset\n\t\t\t\t\tch.elementSize* // element size (bytes)\n\t\t\t\t\t\tch.bufHead, // index of first available buffer entry\n\t\t\t\t),\n\t\t),\n\t\tvalue,\n\t\tch.elementSize,\n\t)\n\n\t// update buffer state\n\tch.bufUsed++\n\tch.bufHead++\n\tif ch.bufHead == ch.bufSize {\n\t\tch.bufHead = 0\n\t}\n\n\treturn true\n}\n\n// pop value from channel buffer if one is available\n// returns whether a value was popped or not\n// result is stored into value pointer\nfunc (ch *channel) pop(value unsafe.Pointer) bool {\n\t// channel is empty\n\tif ch.bufUsed == 0 {\n\t\treturn false\n\t}\n\n\t// compute address of source\n\taddr := unsafe.Pointer(uintptr(ch.buf) + (ch.elementSize * ch.bufTail))\n\n\t// copy value from buffer\n\tmemcpy(\n\t\tvalue,\n\t\taddr,\n\t\tch.elementSize,\n\t)\n\n\t// zero buffer element to allow garbage collection of value\n\tmemzero(\n\t\taddr,\n\t\tch.elementSize,\n\t)\n\n\t// update buffer state\n\tch.bufUsed--\n\n\t// move tail up\n\tch.bufTail++\n\tif ch.bufTail == ch.bufSize {\n\t\tch.bufTail = 0\n\t}\n\n\treturn true\n}\n\n// try to send a value to a channel, without actually blocking\n// returns whether the value was sent\n// will panic if channel is closed\nfunc (ch *channel) trySend(value unsafe.Pointer) bool {\n\tif ch == nil {\n\t\t// send to nil channel blocks forever\n\t\t// this is non-blocking, so just say no\n\t\treturn false\n\t}\n\n\ti := interrupt.Disable()\n\n\tswitch ch.state {\n\tcase chanStateEmpty, chanStateBuf:\n\t\t// try to dump the value directly into the buffer\n\t\tif ch.push(value) {\n\t\t\tch.state = chanStateBuf\n\t\t\tinterrupt.Restore(i)\n\t\t\treturn true\n\t\t}\n\t\tinterrupt.Restore(i)\n\t\treturn false\n\tcase chanStateRecv:\n\t\t// unblock reciever\n\t\tdst := ch.resumeRX(true)\n\n\t\t// copy value to reciever\n\t\tmemcpy(dst, value, ch.elementSize)\n\n\t\t// change state to empty if there are no more receivers\n\t\tif ch.blocked == nil {\n\t\t\tch.state = chanStateEmpty\n\t\t}\n\n\t\tinterrupt.Restore(i)\n\t\treturn true\n\tcase chanStateSend:\n\t\t// something else is already waiting to send\n\t\tinterrupt.Restore(i)\n\t\treturn false\n\tcase chanStateClosed:\n\t\tinterrupt.Restore(i)\n\t\truntimePanic(\"send on closed channel\")\n\tdefault:\n\t\tinterrupt.Restore(i)\n\t\truntimePanic(\"invalid channel state\")\n\t}\n\n\tinterrupt.Restore(i)\n\treturn false\n}\n\n// try to recieve a value from a channel, without really blocking\n// returns whether a value was recieved\n// second return is the comma-ok value\nfunc (ch *channel) tryRecv(value unsafe.Pointer) (bool, bool) {\n\tif ch == nil {\n\t\t// recieve from nil channel blocks forever\n\t\t// this is non-blocking, so just say no\n\t\treturn false, false\n\t}\n\n\ti := interrupt.Disable()\n\n\tswitch ch.state {\n\tcase chanStateBuf, chanStateSend:\n\t\t// try to pop the value directly from the buffer\n\t\tif ch.pop(value) {\n\t\t\t// unblock next sender if applicable\n\t\t\tif ch.blocked != nil {\n\t\t\t\tsrc := ch.resumeTX()\n\n\t\t\t\t// push sender's value into buffer\n\t\t\t\tch.push(src)\n\n\t\t\t\tif ch.blocked == nil {\n\t\t\t\t\t// last sender unblocked - update state\n\t\t\t\t\tch.state = chanStateBuf\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ch.bufUsed == 0 {\n\t\t\t\t// channel empty - update state\n\t\t\t\tch.state = chanStateEmpty\n\t\t\t}\n\n\t\t\tinterrupt.Restore(i)\n\t\t\treturn true, true\n\t\t} else if ch.blocked != nil {\n\t\t\t// unblock next sender if applicable\n\t\t\tsrc := ch.resumeTX()\n\n\t\t\t// copy sender's value\n\t\t\tmemcpy(value, src, ch.elementSize)\n\n\t\t\tif ch.blocked == nil {\n\t\t\t\t// last sender unblocked - update state\n\t\t\t\tch.state = chanStateEmpty\n\t\t\t}\n\n\t\t\tinterrupt.Restore(i)\n\t\t\treturn true, true\n\t\t}\n\t\tinterrupt.Restore(i)\n\t\treturn false, false\n\tcase chanStateRecv, chanStateEmpty:\n\t\t// something else is already waiting to recieve\n\t\tinterrupt.Restore(i)\n\t\treturn false, false\n\tcase chanStateClosed:\n\t\tif ch.pop(value) {\n\t\t\tinterrupt.Restore(i)\n\t\t\treturn true, true\n\t\t}\n\n\t\t// channel closed - nothing to recieve\n\t\tmemzero(value, ch.elementSize)\n\t\tinterrupt.Restore(i)\n\t\treturn true, false\n\tdefault:\n\t\truntimePanic(\"invalid channel state\")\n\t}\n\n\truntimePanic(\"unreachable\")\n\treturn false, false\n}\n\ntype chanState uint8\n\nconst (\n\tchanStateEmpty  chanState = iota // nothing in channel, no senders/recievers\n\tchanStateRecv                    // nothing in channel, recievers waiting\n\tchanStateSend                    // senders waiting, buffer full if present\n\tchanStateBuf                     // buffer not empty, no senders waiting\n\tchanStateClosed                  // channel closed\n)\n\nfunc (s chanState) String() string {\n\tswitch s {\n\tcase chanStateEmpty:\n\t\treturn \"empty\"\n\tcase chanStateRecv:\n\t\treturn \"recv\"\n\tcase chanStateSend:\n\t\treturn \"send\"\n\tcase chanStateBuf:\n\t\treturn \"buffered\"\n\tcase chanStateClosed:\n\t\treturn \"closed\"\n\tdefault:\n\t\treturn \"invalid\"\n\t}\n}\n\n// chanSelectState is a single channel operation (send/recv) in a select\n// statement. The value pointer is either nil (for receives) or points to the\n// value to send (for sends).\ntype chanSelectState struct {\n\tch    *channel\n\tvalue unsafe.Pointer\n}\n\n// chanSend sends a single value over the channel.\n// This operation will block unless a value is immediately available.\n// May panic if the channel is closed.\nfunc chanSend(ch *channel, value unsafe.Pointer, blockedlist *channelBlockedList) {\n\ti := interrupt.Disable()\n\n\tif ch.trySend(value) {\n\t\t// value immediately sent\n\t\tchanDebug(ch)\n\t\tinterrupt.Restore(i)\n\t\treturn\n\t}\n\n\tif ch == nil {\n\t\t// A nil channel blocks forever. Do not schedule this goroutine again.\n\t\tinterrupt.Restore(i)\n\t\tdeadlock()\n\t}\n\n\t// wait for reciever\n\tsender := task.Current()\n\tch.state = chanStateSend\n\tsender.Ptr = value\n\t*blockedlist = channelBlockedList{\n\t\tnext: ch.blocked,\n\t\tt:    sender,\n\t}\n\tch.blocked = blockedlist\n\tchanDebug(ch)\n\tinterrupt.Restore(i)\n\ttask.Pause()\n\tsender.Ptr = nil\n}\n\n// chanRecv receives a single value over a channel.\n// It blocks if there is no available value to recieve.\n// The recieved value is copied into the value pointer.\n// Returns the comma-ok value.\nfunc chanRecv(ch *channel, value unsafe.Pointer, blockedlist *channelBlockedList) bool {\n\ti := interrupt.Disable()\n\n\tif rx, ok := ch.tryRecv(value); rx {\n\t\t// value immediately available\n\t\tchanDebug(ch)\n\t\tinterrupt.Restore(i)\n\t\treturn ok\n\t}\n\n\tif ch == nil {\n\t\t// A nil channel blocks forever. Do not schedule this goroutine again.\n\t\tinterrupt.Restore(i)\n\t\tdeadlock()\n\t}\n\n\t// wait for a value\n\treceiver := task.Current()\n\tch.state = chanStateRecv\n\treceiver.Ptr, receiver.Data = value, 1\n\t*blockedlist = channelBlockedList{\n\t\tnext: ch.blocked,\n\t\tt:    receiver,\n\t}\n\tch.blocked = blockedlist\n\tchanDebug(ch)\n\tinterrupt.Restore(i)\n\ttask.Pause()\n\tok := receiver.Data == 1\n\treceiver.Ptr, receiver.Data = nil, 0\n\treturn ok\n}\n\n// chanClose closes the given channel. If this channel has a receiver or is\n// empty, it closes the channel. Else, it panics.\nfunc chanClose(ch *channel) {\n\tif ch == nil {\n\t\t// Not allowed by the language spec.\n\t\truntimePanic(\"close of nil channel\")\n\t}\n\ti := interrupt.Disable()\n\tswitch ch.state {\n\tcase chanStateClosed:\n\t\t// Not allowed by the language spec.\n\t\tinterrupt.Restore(i)\n\t\truntimePanic(\"close of closed channel\")\n\tcase chanStateSend:\n\t\t// This panic should ideally on the sending side, not in this goroutine.\n\t\t// But when a goroutine tries to send while the channel is being closed,\n\t\t// that is clearly invalid: the send should have been completed already\n\t\t// before the close.\n\t\tinterrupt.Restore(i)\n\t\truntimePanic(\"close channel during send\")\n\tcase chanStateRecv:\n\t\t// unblock all receivers with the zero value\n\t\tch.state = chanStateClosed\n\t\tfor ch.blocked != nil {\n\t\t\tch.resumeRX(false)\n\t\t}\n\tcase chanStateEmpty, chanStateBuf:\n\t\t// Easy case. No available sender or receiver.\n\t}\n\tch.state = chanStateClosed\n\tinterrupt.Restore(i)\n\tchanDebug(ch)\n}\n\n// chanSelect is the runtime implementation of the select statement. This is\n// perhaps the most complicated statement in the Go spec. It returns the\n// selected index and the 'comma-ok' value.\n//\n// TODO: do this in a round-robin fashion (as specified in the Go spec) instead\n// of picking the first one that can proceed.\nfunc chanSelect(recvbuf unsafe.Pointer, states []chanSelectState, ops []channelBlockedList) (uintptr, bool) {\n\tistate := interrupt.Disable()\n\n\tif selected, ok := tryChanSelect(recvbuf, states); selected != ^uintptr(0) {\n\t\t// one channel was immediately ready\n\t\tinterrupt.Restore(istate)\n\t\treturn selected, ok\n\t}\n\n\t// construct blocked operations\n\tfor i, v := range states {\n\t\tif v.ch == nil {\n\t\t\t// A nil channel receive will never complete.\n\t\t\t// A nil channel send would have panicked during tryChanSelect.\n\t\t\tops[i] = channelBlockedList{}\n\t\t\tcontinue\n\t\t}\n\n\t\tops[i] = channelBlockedList{\n\t\t\tnext:         v.ch.blocked,\n\t\t\tt:            task.Current(),\n\t\t\ts:            &states[i],\n\t\t\tallSelectOps: ops,\n\t\t}\n\t\tv.ch.blocked = &ops[i]\n\t\tif v.value == nil {\n\t\t\t// recv\n\t\t\tswitch v.ch.state {\n\t\t\tcase chanStateEmpty:\n\t\t\t\tv.ch.state = chanStateRecv\n\t\t\tcase chanStateRecv:\n\t\t\t\t// already in correct state\n\t\t\tdefault:\n\t\t\t\tinterrupt.Restore(istate)\n\t\t\t\truntimePanic(\"invalid channel state\")\n\t\t\t}\n\t\t} else {\n\t\t\t// send\n\t\t\tswitch v.ch.state {\n\t\t\tcase chanStateEmpty:\n\t\t\t\tv.ch.state = chanStateSend\n\t\t\tcase chanStateSend:\n\t\t\t\t// already in correct state\n\t\t\tcase chanStateBuf:\n\t\t\t\t// already in correct state\n\t\t\tdefault:\n\t\t\t\tinterrupt.Restore(istate)\n\t\t\t\truntimePanic(\"invalid channel state\")\n\t\t\t}\n\t\t}\n\t\tchanDebug(v.ch)\n\t}\n\n\t// expose rx buffer\n\tt := task.Current()\n\tt.Ptr = recvbuf\n\tt.Data = 1\n\n\t// wait for one case to fire\n\tinterrupt.Restore(istate)\n\ttask.Pause()\n\n\t// figure out which one fired and return the ok value\n\treturn (uintptr(t.Ptr) - uintptr(unsafe.Pointer(&states[0]))) / unsafe.Sizeof(chanSelectState{}), t.Data != 0\n}\n\n// tryChanSelect is like chanSelect, but it does a non-blocking select operation.\nfunc tryChanSelect(recvbuf unsafe.Pointer, states []chanSelectState) (uintptr, bool) {\n\tistate := interrupt.Disable()\n\n\t// See whether we can receive from one of the channels.\n\tfor i, state := range states {\n\t\tif state.value == nil {\n\t\t\t// A receive operation.\n\t\t\tif rx, ok := state.ch.tryRecv(recvbuf); rx {\n\t\t\t\tchanDebug(state.ch)\n\t\t\t\tinterrupt.Restore(istate)\n\t\t\t\treturn uintptr(i), ok\n\t\t\t}\n\t\t} else {\n\t\t\t// A send operation: state.value is not nil.\n\t\t\tif state.ch.trySend(state.value) {\n\t\t\t\tchanDebug(state.ch)\n\t\t\t\tinterrupt.Restore(istate)\n\t\t\t\treturn uintptr(i), true\n\t\t\t}\n\t\t}\n\t}\n\n\tinterrupt.Restore(istate)\n\treturn ^uintptr(0), false\n}\n","package runtime\n\n// This is a hashmap implementation for the map[T]T type.\n// It is very roughly based on the implementation of the Go hashmap:\n//\n//     https://golang.org/src/runtime/map.go\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\n// The underlying hashmap structure for Go.\ntype hashmap struct {\n\tnext       *hashmap       // hashmap after evacuate (for iterators)\n\tbuckets    unsafe.Pointer // pointer to array of buckets\n\tcount      uintptr\n\tkeySize    uint8 // maybe this can store the key type as well? E.g. keysize == 5 means string?\n\tvalueSize  uint8\n\tbucketBits uint8\n}\n\n// A hashmap bucket. A bucket is a container of 8 key/value pairs: first the\n// following two entries, then the 8 keys, then the 8 values. This somewhat odd\n// ordering is to make sure the keys and values are well aligned when one of\n// them is smaller than the system word size.\ntype hashmapBucket struct {\n\ttophash [8]uint8\n\tnext    *hashmapBucket // next bucket (if there are more than 8 in a chain)\n\t// Followed by the actual keys, and then the actual values. These are\n\t// allocated but as they're of variable size they can't be shown here.\n}\n\ntype hashmapIterator struct {\n\tbucketNumber uintptr\n\tbucket       *hashmapBucket\n\tbucketIndex  uint8\n}\n\n// Get FNV-1a hash of this key.\n//\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\nfunc hashmapHash(ptr unsafe.Pointer, n uintptr) uint32 {\n\tvar result uint32 = 2166136261 // FNV offset basis\n\tfor i := uintptr(0); i < n; i++ {\n\t\tc := *(*uint8)(unsafe.Pointer(uintptr(ptr) + i))\n\t\tresult ^= uint32(c) // XOR with byte\n\t\tresult *= 16777619  // FNV prime\n\t}\n\treturn result\n}\n\n// Get the topmost 8 bits of the hash, without using a special value (like 0).\nfunc hashmapTopHash(hash uint32) uint8 {\n\ttophash := uint8(hash >> 24)\n\tif tophash < 1 {\n\t\t// 0 means empty slot, so make it bigger.\n\t\ttophash += 1\n\t}\n\treturn tophash\n}\n\n// Create a new hashmap with the given keySize and valueSize.\nfunc hashmapMake(keySize, valueSize uint8, sizeHint uintptr) *hashmap {\n\tnumBuckets := sizeHint / 8\n\tbucketBits := uint8(0)\n\tfor numBuckets != 0 {\n\t\tnumBuckets /= 2\n\t\tbucketBits++\n\t}\n\tbucketBufSize := unsafe.Sizeof(hashmapBucket{}) + uintptr(keySize)*8 + uintptr(valueSize)*8\n\tbuckets := alloc(bucketBufSize*(1<<bucketBits), nil)\n\treturn &hashmap{\n\t\tbuckets:    buckets,\n\t\tkeySize:    keySize,\n\t\tvalueSize:  valueSize,\n\t\tbucketBits: bucketBits,\n\t}\n}\n\n// Return the number of entries in this hashmap, called from the len builtin.\n// A nil hashmap is defined as having length 0.\n//go:inline\nfunc hashmapLen(m *hashmap) int {\n\tif m == nil {\n\t\treturn 0\n\t}\n\treturn int(m.count)\n}\n\n// wrapper for use in reflect\nfunc hashmapLenUnsafePointer(p unsafe.Pointer) int {\n\tm := (*hashmap)(p)\n\treturn hashmapLen(m)\n}\n\n// Set a specified key to a given value. Grow the map if necessary.\n//go:nobounds\nfunc hashmapSet(m *hashmap, key unsafe.Pointer, value unsafe.Pointer, hash uint32, keyEqual func(x, y unsafe.Pointer, n uintptr) bool) {\n\ttophash := hashmapTopHash(hash)\n\n\tif m.buckets == nil {\n\t\t// No bucket was allocated yet, do so now.\n\t\tm.buckets = unsafe.Pointer(hashmapInsertIntoNewBucket(m, key, value, tophash))\n\t\treturn\n\t}\n\n\tnumBuckets := uintptr(1) << m.bucketBits\n\tbucketNumber := (uintptr(hash) & (numBuckets - 1))\n\tbucketSize := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*8\n\tbucketAddr := uintptr(m.buckets) + bucketSize*bucketNumber\n\tbucket := (*hashmapBucket)(unsafe.Pointer(bucketAddr))\n\tvar lastBucket *hashmapBucket\n\n\t// See whether the key already exists somewhere.\n\tvar emptySlotKey unsafe.Pointer\n\tvar emptySlotValue unsafe.Pointer\n\tvar emptySlotTophash *byte\n\tfor bucket != nil {\n\t\tfor i := uintptr(0); i < 8; i++ {\n\t\t\tslotKeyOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*uintptr(i)\n\t\t\tslotKey := unsafe.Pointer(uintptr(unsafe.Pointer(bucket)) + slotKeyOffset)\n\t\t\tslotValueOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*uintptr(i)\n\t\t\tslotValue := unsafe.Pointer(uintptr(unsafe.Pointer(bucket)) + slotValueOffset)\n\t\t\tif bucket.tophash[i] == 0 && emptySlotKey == nil {\n\t\t\t\t// Found an empty slot, store it for if we couldn't find an\n\t\t\t\t// existing slot.\n\t\t\t\temptySlotKey = slotKey\n\t\t\t\temptySlotValue = slotValue\n\t\t\t\temptySlotTophash = &bucket.tophash[i]\n\t\t\t}\n\t\t\tif bucket.tophash[i] == tophash {\n\t\t\t\t// Could be an existing key that's the same.\n\t\t\t\tif keyEqual(key, slotKey, uintptr(m.keySize)) {\n\t\t\t\t\t// found same key, replace it\n\t\t\t\t\tmemcpy(slotValue, value, uintptr(m.valueSize))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlastBucket = bucket\n\t\tbucket = bucket.next\n\t}\n\tif emptySlotKey == nil {\n\t\t// Add a new bucket to the bucket chain.\n\t\t// TODO: rebalance if necessary to avoid O(n) insert and lookup time.\n\t\tlastBucket.next = (*hashmapBucket)(hashmapInsertIntoNewBucket(m, key, value, tophash))\n\t\treturn\n\t}\n\tm.count++\n\tmemcpy(emptySlotKey, key, uintptr(m.keySize))\n\tmemcpy(emptySlotValue, value, uintptr(m.valueSize))\n\t*emptySlotTophash = tophash\n}\n\n// hashmapInsertIntoNewBucket creates a new bucket, inserts the given key and\n// value into the bucket, and returns a pointer to this bucket.\nfunc hashmapInsertIntoNewBucket(m *hashmap, key, value unsafe.Pointer, tophash uint8) *hashmapBucket {\n\tbucketBufSize := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*8\n\tbucketBuf := alloc(bucketBufSize, nil)\n\t// Insert into the first slot, which is empty as it has just been allocated.\n\tslotKeyOffset := unsafe.Sizeof(hashmapBucket{})\n\tslotKey := unsafe.Pointer(uintptr(bucketBuf) + slotKeyOffset)\n\tslotValueOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8\n\tslotValue := unsafe.Pointer(uintptr(bucketBuf) + slotValueOffset)\n\tm.count++\n\tmemcpy(slotKey, key, uintptr(m.keySize))\n\tmemcpy(slotValue, value, uintptr(m.valueSize))\n\tbucket := (*hashmapBucket)(bucketBuf)\n\tbucket.tophash[0] = tophash\n\treturn bucket\n}\n\n// Get the value of a specified key, or zero the value if not found.\n//go:nobounds\nfunc hashmapGet(m *hashmap, key, value unsafe.Pointer, valueSize uintptr, hash uint32, keyEqual func(x, y unsafe.Pointer, n uintptr) bool) bool {\n\tif m == nil {\n\t\t// Getting a value out of a nil map is valid. From the spec:\n\t\t// > if the map is nil or does not contain such an entry, a[x] is the\n\t\t// > zero value for the element type of M\n\t\tmemzero(value, uintptr(valueSize))\n\t\treturn false\n\t}\n\tnumBuckets := uintptr(1) << m.bucketBits\n\tbucketNumber := (uintptr(hash) & (numBuckets - 1))\n\tbucketSize := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*8\n\tbucketAddr := uintptr(m.buckets) + bucketSize*bucketNumber\n\tbucket := (*hashmapBucket)(unsafe.Pointer(bucketAddr))\n\n\ttophash := uint8(hash >> 24)\n\tif tophash < 1 {\n\t\t// 0 means empty slot, so make it bigger.\n\t\ttophash += 1\n\t}\n\n\t// Try to find the key.\n\tfor bucket != nil {\n\t\tfor i := uintptr(0); i < 8; i++ {\n\t\t\tslotKeyOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*uintptr(i)\n\t\t\tslotKey := unsafe.Pointer(uintptr(unsafe.Pointer(bucket)) + slotKeyOffset)\n\t\t\tslotValueOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*uintptr(i)\n\t\t\tslotValue := unsafe.Pointer(uintptr(unsafe.Pointer(bucket)) + slotValueOffset)\n\t\t\tif bucket.tophash[i] == tophash {\n\t\t\t\t// This could be the key we're looking for.\n\t\t\t\tif keyEqual(key, slotKey, uintptr(m.keySize)) {\n\t\t\t\t\t// Found the key, copy it.\n\t\t\t\t\tmemcpy(value, slotValue, uintptr(m.valueSize))\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbucket = bucket.next\n\t}\n\n\t// Did not find the key.\n\tmemzero(value, uintptr(m.valueSize))\n\treturn false\n}\n\n// Delete a given key from the map. No-op when the key does not exist in the\n// map.\n//go:nobounds\nfunc hashmapDelete(m *hashmap, key unsafe.Pointer, hash uint32, keyEqual func(x, y unsafe.Pointer, n uintptr) bool) {\n\tif m == nil {\n\t\t// The delete builtin is defined even when the map is nil. From the spec:\n\t\t// > If the map m is nil or the element m[k] does not exist, delete is a\n\t\t// > no-op.\n\t\treturn\n\t}\n\tnumBuckets := uintptr(1) << m.bucketBits\n\tbucketNumber := (uintptr(hash) & (numBuckets - 1))\n\tbucketSize := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*8\n\tbucketAddr := uintptr(m.buckets) + bucketSize*bucketNumber\n\tbucket := (*hashmapBucket)(unsafe.Pointer(bucketAddr))\n\n\ttophash := uint8(hash >> 24)\n\tif tophash < 1 {\n\t\t// 0 means empty slot, so make it bigger.\n\t\ttophash += 1\n\t}\n\n\t// Try to find the key.\n\tfor bucket != nil {\n\t\tfor i := uintptr(0); i < 8; i++ {\n\t\t\tslotKeyOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*uintptr(i)\n\t\t\tslotKey := unsafe.Pointer(uintptr(unsafe.Pointer(bucket)) + slotKeyOffset)\n\t\t\tif bucket.tophash[i] == tophash {\n\t\t\t\t// This could be the key we're looking for.\n\t\t\t\tif keyEqual(key, slotKey, uintptr(m.keySize)) {\n\t\t\t\t\t// Found the key, delete it.\n\t\t\t\t\tbucket.tophash[i] = 0\n\t\t\t\t\tm.count--\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbucket = bucket.next\n\t}\n}\n\n// Iterate over a hashmap.\n//go:nobounds\nfunc hashmapNext(m *hashmap, it *hashmapIterator, key, value unsafe.Pointer) bool {\n\tif m == nil {\n\t\t// Iterating over a nil slice appears to be allowed by the Go spec:\n\t\t// https://groups.google.com/g/golang-nuts/c/gVgVLQU1FFE?pli=1\n\t\t// https://play.golang.org/p/S8jxAMytKDB\n\t\treturn false\n\t}\n\n\tnumBuckets := uintptr(1) << m.bucketBits\n\tfor {\n\t\tif it.bucketIndex >= 8 {\n\t\t\t// end of bucket, move to the next in the chain\n\t\t\tit.bucketIndex = 0\n\t\t\tit.bucket = it.bucket.next\n\t\t}\n\t\tif it.bucket == nil {\n\t\t\tif it.bucketNumber >= numBuckets {\n\t\t\t\t// went through all buckets\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tbucketSize := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*8\n\t\t\tbucketAddr := uintptr(m.buckets) + bucketSize*it.bucketNumber\n\t\t\tit.bucket = (*hashmapBucket)(unsafe.Pointer(bucketAddr))\n\t\t\tit.bucketNumber++ // next bucket\n\t\t}\n\t\tif it.bucket.tophash[it.bucketIndex] == 0 {\n\t\t\t// slot is empty - move on\n\t\t\tit.bucketIndex++\n\t\t\tcontinue\n\t\t}\n\n\t\tbucketAddr := uintptr(unsafe.Pointer(it.bucket))\n\t\tslotKeyOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*uintptr(it.bucketIndex)\n\t\tslotKey := unsafe.Pointer(bucketAddr + slotKeyOffset)\n\t\tslotValueOffset := unsafe.Sizeof(hashmapBucket{}) + uintptr(m.keySize)*8 + uintptr(m.valueSize)*uintptr(it.bucketIndex)\n\t\tslotValue := unsafe.Pointer(bucketAddr + slotValueOffset)\n\t\tmemcpy(key, slotKey, uintptr(m.keySize))\n\t\tmemcpy(value, slotValue, uintptr(m.valueSize))\n\t\tit.bucketIndex++\n\n\t\treturn true\n\t}\n}\n\n// Hashmap with plain binary data keys (not containing strings etc.).\n\nfunc hashmapBinarySet(m *hashmap, key, value unsafe.Pointer) {\n\t// TODO: detect nil map here and throw a better panic message?\n\thash := hashmapHash(key, uintptr(m.keySize))\n\thashmapSet(m, key, value, hash, memequal)\n}\n\nfunc hashmapBinaryGet(m *hashmap, key, value unsafe.Pointer, valueSize uintptr) bool {\n\tif m == nil {\n\t\tmemzero(value, uintptr(valueSize))\n\t\treturn false\n\t}\n\thash := hashmapHash(key, uintptr(m.keySize))\n\treturn hashmapGet(m, key, value, valueSize, hash, memequal)\n}\n\nfunc hashmapBinaryDelete(m *hashmap, key unsafe.Pointer) {\n\tif m == nil {\n\t\treturn\n\t}\n\thash := hashmapHash(key, uintptr(m.keySize))\n\thashmapDelete(m, key, hash, memequal)\n}\n\n// Hashmap with string keys (a common case).\n\nfunc hashmapStringEqual(x, y unsafe.Pointer, n uintptr) bool {\n\treturn *(*string)(x) == *(*string)(y)\n}\n\nfunc hashmapStringHash(s string) uint32 {\n\t_s := (*_string)(unsafe.Pointer(&s))\n\treturn hashmapHash(unsafe.Pointer(_s.ptr), uintptr(_s.length))\n}\n\nfunc hashmapStringSet(m *hashmap, key string, value unsafe.Pointer) {\n\thash := hashmapStringHash(key)\n\thashmapSet(m, unsafe.Pointer(&key), value, hash, hashmapStringEqual)\n}\n\nfunc hashmapStringGet(m *hashmap, key string, value unsafe.Pointer, valueSize uintptr) bool {\n\thash := hashmapStringHash(key)\n\treturn hashmapGet(m, unsafe.Pointer(&key), value, valueSize, hash, hashmapStringEqual)\n}\n\nfunc hashmapStringDelete(m *hashmap, key string) {\n\thash := hashmapStringHash(key)\n\thashmapDelete(m, unsafe.Pointer(&key), hash, hashmapStringEqual)\n}\n\n// Hashmap with interface keys (for everything else).\n\n// This is a method that is intentionally unexported in the reflect package. It\n// is identical to the Interface() method call, except it doesn't check whether\n// a field is exported and thus allows circumventing the type system.\n// The hash function needs it as it also needs to hash unexported struct fields.\n//go:linkname valueInterfaceUnsafe reflect.valueInterfaceUnsafe\nfunc valueInterfaceUnsafe(v reflect.Value) interface{}\n\nfunc hashmapFloat32Hash(ptr unsafe.Pointer) uint32 {\n\tf := *(*uint32)(ptr)\n\tif f == 0x80000000 {\n\t\t// convert -0 to 0 for hashing\n\t\tf = 0\n\t}\n\treturn hashmapHash(unsafe.Pointer(&f), 4)\n}\n\nfunc hashmapFloat64Hash(ptr unsafe.Pointer) uint32 {\n\tf := *(*uint64)(ptr)\n\tif f == 0x8000000000000000 {\n\t\t// convert -0 to 0 for hashing\n\t\tf = 0\n\t}\n\treturn hashmapHash(unsafe.Pointer(&f), 8)\n}\n\nfunc hashmapInterfaceHash(itf interface{}) uint32 {\n\tx := reflect.ValueOf(itf)\n\tif x.RawType() == 0 {\n\t\treturn 0 // nil interface\n\t}\n\n\tvalue := (*_interface)(unsafe.Pointer(&itf)).value\n\tptr := value\n\tif x.RawType().Size() <= unsafe.Sizeof(uintptr(0)) {\n\t\t// Value fits in pointer, so it's directly stored in the pointer.\n\t\tptr = unsafe.Pointer(&value)\n\t}\n\n\tswitch x.RawType().Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn hashmapHash(ptr, x.RawType().Size())\n\tcase reflect.Bool, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn hashmapHash(ptr, x.RawType().Size())\n\tcase reflect.Float32:\n\t\t// It should be possible to just has the contents. However, NaN != NaN\n\t\t// so if you're using lots of NaNs as map keys (you shouldn't) then hash\n\t\t// time may become exponential. To fix that, it would be better to\n\t\t// return a random number instead:\n\t\t// https://research.swtch.com/randhash\n\t\treturn hashmapFloat32Hash(ptr)\n\tcase reflect.Float64:\n\t\treturn hashmapFloat64Hash(ptr)\n\tcase reflect.Complex64:\n\t\trptr, iptr := ptr, unsafe.Pointer(uintptr(ptr)+4)\n\t\treturn hashmapFloat32Hash(rptr) ^ hashmapFloat32Hash(iptr)\n\tcase reflect.Complex128:\n\t\trptr, iptr := ptr, unsafe.Pointer(uintptr(ptr)+8)\n\t\treturn hashmapFloat64Hash(rptr) ^ hashmapFloat64Hash(iptr)\n\tcase reflect.String:\n\t\treturn hashmapStringHash(x.String())\n\tcase reflect.Chan, reflect.Ptr, reflect.UnsafePointer:\n\t\t// It might seem better to just return the pointer, but that won't\n\t\t// result in an evenly distributed hashmap. Instead, hash the pointer\n\t\t// like most other types.\n\t\treturn hashmapHash(ptr, x.RawType().Size())\n\tcase reflect.Array:\n\t\tvar hash uint32\n\t\tfor i := 0; i < x.Len(); i++ {\n\t\t\thash ^= hashmapInterfaceHash(valueInterfaceUnsafe(x.Index(i)))\n\t\t}\n\t\treturn hash\n\tcase reflect.Struct:\n\t\tvar hash uint32\n\t\tfor i := 0; i < x.NumField(); i++ {\n\t\t\thash ^= hashmapInterfaceHash(valueInterfaceUnsafe(x.Field(i)))\n\t\t}\n\t\treturn hash\n\tdefault:\n\t\truntimePanic(\"comparing un-comparable type\")\n\t\treturn 0 // unreachable\n\t}\n}\n\nfunc hashmapInterfaceEqual(x, y unsafe.Pointer, n uintptr) bool {\n\treturn *(*interface{})(x) == *(*interface{})(y)\n}\n\nfunc hashmapInterfaceSet(m *hashmap, key interface{}, value unsafe.Pointer) {\n\thash := hashmapInterfaceHash(key)\n\thashmapSet(m, unsafe.Pointer(&key), value, hash, hashmapInterfaceEqual)\n}\n\nfunc hashmapInterfaceGet(m *hashmap, key interface{}, value unsafe.Pointer, valueSize uintptr) bool {\n\thash := hashmapInterfaceHash(key)\n\treturn hashmapGet(m, unsafe.Pointer(&key), value, valueSize, hash, hashmapInterfaceEqual)\n}\n\nfunc hashmapInterfaceDelete(m *hashmap, key interface{}) {\n\thash := hashmapInterfaceHash(key)\n\thashmapDelete(m, unsafe.Pointer(&key), hash, hashmapInterfaceEqual)\n}\n","//go:build gc.conservative\n// +build gc.conservative\n\npackage runtime\n\n// This memory manager is a textbook mark/sweep implementation, heavily inspired\n// by the MicroPython garbage collector.\n//\n// The memory manager internally uses blocks of 4 pointers big (see\n// bytesPerBlock). Every allocation first rounds up to this size to align every\n// block. It will first try to find a chain of blocks that is big enough to\n// satisfy the allocation. If it finds one, it marks the first one as the \"head\"\n// and the following ones (if any) as the \"tail\" (see below). If it cannot find\n// any free space, it will perform a garbage collection cycle and try again. If\n// it still cannot find any free space, it gives up.\n//\n// Every block has some metadata, which is stored at the beginning of the heap.\n// The four states are \"free\", \"head\", \"tail\", and \"mark\". During normal\n// operation, there are no marked blocks. Every allocated object starts with a\n// \"head\" and is followed by \"tail\" blocks. The reason for this distinction is\n// that this way, the start and end of every object can be found easily.\n//\n// Metadata is stored in a special area at the end of the heap, in the area\n// metadataStart..heapEnd. The actual blocks are stored in\n// heapStart..metadataStart.\n//\n// More information:\n// https://github.com/micropython/micropython/wiki/Memory-Manager\n// \"The Garbage Collection Handbook\" by Richard Jones, Antony Hosking, Eliot\n// Moss.\n\nimport (\n\t\"internal/task\"\n\t\"runtime/interrupt\"\n\t\"unsafe\"\n)\n\n// Set gcDebug to true to print debug information.\nconst (\n\tgcDebug   = false   // print debug info\n\tgcAsserts = gcDebug // perform sanity checks\n)\n\n// Some globals + constants for the entire GC.\n\nconst (\n\twordsPerBlock      = 4 // number of pointers in an allocated block\n\tbytesPerBlock      = wordsPerBlock * unsafe.Sizeof(heapStart)\n\tstateBits          = 2 // how many bits a block state takes (see blockState type)\n\tblocksPerStateByte = 8 / stateBits\n\tmarkStackSize      = 4 * unsafe.Sizeof((*int)(nil)) // number of to-be-marked blocks to queue before forcing a rescan\n)\n\nvar (\n\tmetadataStart unsafe.Pointer // pointer to the start of the heap metadata\n\tnextAlloc     gcBlock        // the next block that should be tried by the allocator\n\tendBlock      gcBlock        // the block just past the end of the available space\n)\n\n// zeroSizedAlloc is just a sentinel that gets returned when allocating 0 bytes.\nvar zeroSizedAlloc uint8\n\n// Provide some abstraction over heap blocks.\n\n// blockState stores the four states in which a block can be. It is two bits in\n// size.\ntype blockState uint8\n\nconst (\n\tblockStateFree blockState = 0 // 00\n\tblockStateHead blockState = 1 // 01\n\tblockStateTail blockState = 2 // 10\n\tblockStateMark blockState = 3 // 11\n\tblockStateMask blockState = 3 // 11\n)\n\n// String returns a human-readable version of the block state, for debugging.\nfunc (s blockState) String() string {\n\tswitch s {\n\tcase blockStateFree:\n\t\treturn \"free\"\n\tcase blockStateHead:\n\t\treturn \"head\"\n\tcase blockStateTail:\n\t\treturn \"tail\"\n\tcase blockStateMark:\n\t\treturn \"mark\"\n\tdefault:\n\t\t// must never happen\n\t\treturn \"!err\"\n\t}\n}\n\n// The block number in the pool.\ntype gcBlock uintptr\n\n// blockFromAddr returns a block given an address somewhere in the heap (which\n// might not be heap-aligned).\nfunc blockFromAddr(addr uintptr) gcBlock {\n\tif gcAsserts && (addr < heapStart || addr >= uintptr(metadataStart)) {\n\t\truntimePanic(\"gc: trying to get block from invalid address\")\n\t}\n\treturn gcBlock((addr - heapStart) / bytesPerBlock)\n}\n\n// Return a pointer to the start of the allocated object.\nfunc (b gcBlock) pointer() unsafe.Pointer {\n\treturn unsafe.Pointer(b.address())\n}\n\n// Return the address of the start of the allocated object.\nfunc (b gcBlock) address() uintptr {\n\treturn heapStart + uintptr(b)*bytesPerBlock\n}\n\n// findHead returns the head (first block) of an object, assuming the block\n// points to an allocated object. It returns the same block if this block\n// already points to the head.\nfunc (b gcBlock) findHead() gcBlock {\n\tfor b.state() == blockStateTail {\n\t\tb--\n\t}\n\tif gcAsserts {\n\t\tif b.state() != blockStateHead && b.state() != blockStateMark {\n\t\t\truntimePanic(\"gc: found tail without head\")\n\t\t}\n\t}\n\treturn b\n}\n\n// findNext returns the first block just past the end of the tail. This may or\n// may not be the head of an object.\nfunc (b gcBlock) findNext() gcBlock {\n\tif b.state() == blockStateHead || b.state() == blockStateMark {\n\t\tb++\n\t}\n\tfor b.state() == blockStateTail {\n\t\tb++\n\t}\n\treturn b\n}\n\n// State returns the current block state.\nfunc (b gcBlock) state() blockState {\n\tstateBytePtr := (*uint8)(unsafe.Pointer(uintptr(metadataStart) + uintptr(b/blocksPerStateByte)))\n\treturn blockState(*stateBytePtr>>((b%blocksPerStateByte)*2)) % 4\n}\n\n// setState sets the current block to the given state, which must contain more\n// bits than the current state. Allowed transitions: from free to any state and\n// from head to mark.\nfunc (b gcBlock) setState(newState blockState) {\n\tstateBytePtr := (*uint8)(unsafe.Pointer(uintptr(metadataStart) + uintptr(b/blocksPerStateByte)))\n\t*stateBytePtr |= uint8(newState << ((b % blocksPerStateByte) * 2))\n\tif gcAsserts && b.state() != newState {\n\t\truntimePanic(\"gc: setState() was not successful\")\n\t}\n}\n\n// markFree sets the block state to free, no matter what state it was in before.\nfunc (b gcBlock) markFree() {\n\tstateBytePtr := (*uint8)(unsafe.Pointer(uintptr(metadataStart) + uintptr(b/blocksPerStateByte)))\n\t*stateBytePtr &^= uint8(blockStateMask << ((b % blocksPerStateByte) * 2))\n\tif gcAsserts && b.state() != blockStateFree {\n\t\truntimePanic(\"gc: markFree() was not successful\")\n\t}\n}\n\n// unmark changes the state of the block from mark to head. It must be marked\n// before calling this function.\nfunc (b gcBlock) unmark() {\n\tif gcAsserts && b.state() != blockStateMark {\n\t\truntimePanic(\"gc: unmark() on a block that is not marked\")\n\t}\n\tclearMask := blockStateMask ^ blockStateHead // the bits to clear from the state\n\tstateBytePtr := (*uint8)(unsafe.Pointer(uintptr(metadataStart) + uintptr(b/blocksPerStateByte)))\n\t*stateBytePtr &^= uint8(clearMask << ((b % blocksPerStateByte) * 2))\n\tif gcAsserts && b.state() != blockStateHead {\n\t\truntimePanic(\"gc: unmark() was not successful\")\n\t}\n}\n\n// Initialize the memory allocator.\n// No memory may be allocated before this is called. That means the runtime and\n// any packages the runtime depends upon may not allocate memory during package\n// initialization.\nfunc initHeap() {\n\tcalculateHeapAddresses()\n\n\t// Set all block states to 'free'.\n\tmetadataSize := heapEnd - uintptr(metadataStart)\n\tmemzero(unsafe.Pointer(metadataStart), metadataSize)\n}\n\n// setHeapEnd is called to expand the heap. The heap can only grow, not shrink.\n// Also, the heap should grow substantially each time otherwise growing the heap\n// will be expensive.\nfunc setHeapEnd(newHeapEnd uintptr) {\n\tif gcAsserts && newHeapEnd <= heapEnd {\n\t\tpanic(\"gc: setHeapEnd didn't grow the heap\")\n\t}\n\n\t// Save some old variables we need later.\n\toldMetadataStart := metadataStart\n\toldMetadataSize := heapEnd - uintptr(metadataStart)\n\n\t// Increase the heap. After setting the new heapEnd, calculateHeapAddresses\n\t// will update metadataStart and the memcpy will copy the metadata to the\n\t// new location.\n\t// The new metadata will be bigger than the old metadata, but a simple\n\t// memcpy is fine as it only copies the old metadata and the new memory will\n\t// have been zero initialized.\n\theapEnd = newHeapEnd\n\tcalculateHeapAddresses()\n\tmemcpy(metadataStart, oldMetadataStart, oldMetadataSize)\n\n\t// Note: the memcpy above assumes the heap grows enough so that the new\n\t// metadata does not overlap the old metadata. If that isn't true, memmove\n\t// should be used to avoid corruption.\n\t// This assert checks whether that's true.\n\tif gcAsserts && uintptr(metadataStart) < uintptr(oldMetadataStart)+oldMetadataSize {\n\t\tpanic(\"gc: heap did not grow enough at once\")\n\t}\n}\n\n// calculateHeapAddresses initializes variables such as metadataStart and\n// numBlock based on heapStart and heapEnd.\n//\n// This function can be called again when the heap size increases. The caller is\n// responsible for copying the metadata to the new location.\nfunc calculateHeapAddresses() {\n\tif GOARCH == \"wasm\" {\n\t\t// This is a workaround for a bug in wasm-ld: wasm-ld doesn't always\n\t\t// align __heap_base and when this memory is shared through an API, it\n\t\t// might result in unaligned memory. For details, see:\n\t\t// https://reviews.llvm.org/D106499\n\t\t// It should be removed once we switch to LLVM 13, where this is fixed.\n\t\theapStart = align(heapStart)\n\t}\n\ttotalSize := heapEnd - heapStart\n\n\t// Allocate some memory to keep 2 bits of information about every block.\n\tmetadataSize := totalSize / (blocksPerStateByte * bytesPerBlock)\n\tmetadataStart = unsafe.Pointer(heapEnd - metadataSize)\n\n\t// Use the rest of the available memory as heap.\n\tnumBlocks := (uintptr(metadataStart) - heapStart) / bytesPerBlock\n\tendBlock = gcBlock(numBlocks)\n\tif gcDebug {\n\t\tprintln(\"heapStart:        \", heapStart)\n\t\tprintln(\"heapEnd:          \", heapEnd)\n\t\tprintln(\"total size:       \", totalSize)\n\t\tprintln(\"metadata size:    \", metadataSize)\n\t\tprintln(\"metadataStart:    \", metadataStart)\n\t\tprintln(\"# of blocks:      \", numBlocks)\n\t\tprintln(\"# of block states:\", metadataSize*blocksPerStateByte)\n\t}\n\tif gcAsserts && metadataSize*blocksPerStateByte < numBlocks {\n\t\t// sanity check\n\t\truntimePanic(\"gc: metadata array is too small\")\n\t}\n}\n\n// alloc tries to find some free space on the heap, possibly doing a garbage\n// collection cycle if needed. If no space is free, it panics.\n//go:noinline\nfunc alloc(size uintptr, layout unsafe.Pointer) unsafe.Pointer {\n\tif size == 0 {\n\t\treturn unsafe.Pointer(&zeroSizedAlloc)\n\t}\n\n\tneededBlocks := (size + (bytesPerBlock - 1)) / bytesPerBlock\n\n\t// Continue looping until a run of free blocks has been found that fits the\n\t// requested size.\n\tindex := nextAlloc\n\tnumFreeBlocks := uintptr(0)\n\theapScanCount := uint8(0)\n\tfor {\n\t\tif index == nextAlloc {\n\t\t\tif heapScanCount == 0 {\n\t\t\t\theapScanCount = 1\n\t\t\t} else if heapScanCount == 1 {\n\t\t\t\t// The entire heap has been searched for free memory, but none\n\t\t\t\t// could be found. Run a garbage collection cycle to reclaim\n\t\t\t\t// free memory and try again.\n\t\t\t\theapScanCount = 2\n\t\t\t\tGC()\n\t\t\t} else {\n\t\t\t\t// Even after garbage collection, no free memory could be found.\n\t\t\t\t// Try to increase heap size.\n\t\t\t\tif growHeap() {\n\t\t\t\t\t// Success, the heap was increased in size. Try again with a\n\t\t\t\t\t// larger heap.\n\t\t\t\t} else {\n\t\t\t\t\t// Unfortunately the heap could not be increased. This\n\t\t\t\t\t// happens on baremetal systems for example (where all\n\t\t\t\t\t// available RAM has already been dedicated to the heap).\n\t\t\t\t\truntimePanic(\"out of memory\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Wrap around the end of the heap.\n\t\tif index == endBlock {\n\t\t\tindex = 0\n\t\t\t// Reset numFreeBlocks as allocations cannot wrap.\n\t\t\tnumFreeBlocks = 0\n\t\t}\n\n\t\t// Is the block we're looking at free?\n\t\tif index.state() != blockStateFree {\n\t\t\t// This block is in use. Try again from this point.\n\t\t\tnumFreeBlocks = 0\n\t\t\tindex++\n\t\t\tcontinue\n\t\t}\n\t\tnumFreeBlocks++\n\t\tindex++\n\n\t\t// Are we finished?\n\t\tif numFreeBlocks == neededBlocks {\n\t\t\t// Found a big enough range of free blocks!\n\t\t\tnextAlloc = index\n\t\t\tthisAlloc := index - gcBlock(neededBlocks)\n\t\t\tif gcDebug {\n\t\t\t\tprintln(\"found memory:\", thisAlloc.pointer(), int(size))\n\t\t\t}\n\n\t\t\t// Set the following blocks as being allocated.\n\t\t\tthisAlloc.setState(blockStateHead)\n\t\t\tfor i := thisAlloc + 1; i != nextAlloc; i++ {\n\t\t\t\ti.setState(blockStateTail)\n\t\t\t}\n\n\t\t\t// Return a pointer to this allocation.\n\t\t\tpointer := thisAlloc.pointer()\n\t\t\tmemzero(pointer, size)\n\t\t\treturn pointer\n\t\t}\n\t}\n}\n\nfunc realloc(ptr unsafe.Pointer, size uintptr) unsafe.Pointer {\n\tif ptr == nil {\n\t\treturn alloc(size, nil)\n\t}\n\n\tptrAddress := uintptr(ptr)\n\tendOfTailAddress := blockFromAddr(ptrAddress).findNext().address()\n\n\t// this might be a few bytes longer than the original size of\n\t// ptr, because we align to full blocks of size bytesPerBlock\n\toldSize := endOfTailAddress - ptrAddress\n\tif size <= oldSize {\n\t\treturn ptr\n\t}\n\n\tnewAlloc := alloc(size, nil)\n\tmemcpy(newAlloc, ptr, oldSize)\n\tfree(ptr)\n\n\treturn newAlloc\n}\n\nfunc free(ptr unsafe.Pointer) {\n\t// TODO: free blocks on request, when the compiler knows they're unused.\n}\n\n// GC performs a garbage collection cycle.\nfunc GC() {\n\tif gcDebug {\n\t\tprintln(\"running collection cycle...\")\n\t}\n\n\t// Mark phase: mark all reachable objects, recursively.\n\tmarkStack()\n\tmarkGlobals()\n\n\tif baremetal && hasScheduler {\n\t\t// Channel operations in interrupts may move task pointers around while we are marking.\n\t\t// Therefore we need to scan the runqueue seperately.\n\t\tvar markedTaskQueue task.Queue\n\trunqueueScan:\n\t\tfor !runqueue.Empty() {\n\t\t\t// Pop the next task off of the runqueue.\n\t\t\tt := runqueue.Pop()\n\n\t\t\t// Mark the task if it has not already been marked.\n\t\t\tmarkRoot(uintptr(unsafe.Pointer(&runqueue)), uintptr(unsafe.Pointer(t)))\n\n\t\t\t// Push the task onto our temporary queue.\n\t\t\tmarkedTaskQueue.Push(t)\n\t\t}\n\n\t\tfinishMark()\n\n\t\t// Restore the runqueue.\n\t\ti := interrupt.Disable()\n\t\tif !runqueue.Empty() {\n\t\t\t// Something new came in while finishing the mark.\n\t\t\tinterrupt.Restore(i)\n\t\t\tgoto runqueueScan\n\t\t}\n\t\trunqueue = markedTaskQueue\n\t\tinterrupt.Restore(i)\n\t} else {\n\t\tfinishMark()\n\t}\n\n\t// Sweep phase: free all non-marked objects and unmark marked objects for\n\t// the next collection cycle.\n\tsweep()\n\n\t// Show how much has been sweeped, for debugging.\n\tif gcDebug {\n\t\tdumpHeap()\n\t}\n}\n\n// markRoots reads all pointers from start to end (exclusive) and if they look\n// like a heap pointer and are unmarked, marks them and scans that object as\n// well (recursively). The start and end parameters must be valid pointers and\n// must be aligned.\nfunc markRoots(start, end uintptr) {\n\tif gcDebug {\n\t\tprintln(\"mark from\", start, \"to\", end, int(end-start))\n\t}\n\tif gcAsserts {\n\t\tif start >= end {\n\t\t\truntimePanic(\"gc: unexpected range to mark\")\n\t\t}\n\t\tif start%unsafe.Alignof(start) != 0 {\n\t\t\truntimePanic(\"gc: unaligned start pointer\")\n\t\t}\n\t\tif end%unsafe.Alignof(end) != 0 {\n\t\t\truntimePanic(\"gc: unaligned end pointer\")\n\t\t}\n\t}\n\n\t// Reduce the end bound to avoid reading too far on platforms where pointer alignment is smaller than pointer size.\n\t// If the size of the range is 0, then end will be slightly below start after this.\n\tend -= unsafe.Sizeof(end) - unsafe.Alignof(end)\n\n\tfor addr := start; addr < end; addr += unsafe.Alignof(addr) {\n\t\troot := *(*uintptr)(unsafe.Pointer(addr))\n\t\tmarkRoot(addr, root)\n\t}\n}\n\n// stackOverflow is a flag which is set when the GC scans too deep while marking.\n// After it is set, all marked allocations must be re-scanned.\nvar stackOverflow bool\n\n// startMark starts the marking process on a root and all of its children.\nfunc startMark(root gcBlock) {\n\tvar stack [markStackSize]gcBlock\n\tstack[0] = root\n\troot.setState(blockStateMark)\n\tstackLen := 1\n\tfor stackLen > 0 {\n\t\t// Pop a block off of the stack.\n\t\tstackLen--\n\t\tblock := stack[stackLen]\n\t\tif gcDebug {\n\t\t\tprintln(\"stack popped, remaining stack:\", stackLen)\n\t\t}\n\n\t\t// Scan all pointers inside the block.\n\t\tstart, end := block.address(), block.findNext().address()\n\t\tfor addr := start; addr != end; addr += unsafe.Alignof(addr) {\n\t\t\t// Load the word.\n\t\t\tword := *(*uintptr)(unsafe.Pointer(addr))\n\n\t\t\tif !looksLikePointer(word) {\n\t\t\t\t// Not a heap pointer.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Find the corresponding memory block.\n\t\t\treferencedBlock := blockFromAddr(word)\n\n\t\t\tif referencedBlock.state() == blockStateFree {\n\t\t\t\t// The to-be-marked object doesn't actually exist.\n\t\t\t\t// This is probably a false positive.\n\t\t\t\tif gcDebug {\n\t\t\t\t\tprintln(\"found reference to free memory:\", word, \"at:\", addr)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Move to the block's head.\n\t\t\treferencedBlock = referencedBlock.findHead()\n\n\t\t\tif referencedBlock.state() == blockStateMark {\n\t\t\t\t// The block has already been marked by something else.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Mark block.\n\t\t\tif gcDebug {\n\t\t\t\tprintln(\"marking block:\", referencedBlock)\n\t\t\t}\n\t\t\treferencedBlock.setState(blockStateMark)\n\n\t\t\tif stackLen == len(stack) {\n\t\t\t\t// The stack is full.\n\t\t\t\t// It is necessary to rescan all marked blocks once we are done.\n\t\t\t\tstackOverflow = true\n\t\t\t\tif gcDebug {\n\t\t\t\t\tprintln(\"gc stack overflowed\")\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Push the pointer onto the stack to be scanned later.\n\t\t\tstack[stackLen] = referencedBlock\n\t\t\tstackLen++\n\t\t}\n\t}\n}\n\n// finishMark finishes the marking process by processing all stack overflows.\nfunc finishMark() {\n\tfor stackOverflow {\n\t\t// Re-mark all blocks.\n\t\tstackOverflow = false\n\t\tfor block := gcBlock(0); block < endBlock; block++ {\n\t\t\tif block.state() != blockStateMark {\n\t\t\t\t// Block is not marked, so we do not need to rescan it.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Re-mark the block.\n\t\t\tstartMark(block)\n\t\t}\n\t}\n}\n\n// mark a GC root at the address addr.\nfunc markRoot(addr, root uintptr) {\n\tif looksLikePointer(root) {\n\t\tblock := blockFromAddr(root)\n\t\tif block.state() == blockStateFree {\n\t\t\t// The to-be-marked object doesn't actually exist.\n\t\t\t// This could either be a dangling pointer (oops!) but most likely\n\t\t\t// just a false positive.\n\t\t\treturn\n\t\t}\n\t\thead := block.findHead()\n\t\tif head.state() != blockStateMark {\n\t\t\tif gcDebug {\n\t\t\t\tprintln(\"found unmarked pointer\", root, \"at address\", addr)\n\t\t\t}\n\t\t\tstartMark(head)\n\t\t}\n\t}\n}\n\n// Sweep goes through all memory and frees unmarked memory.\nfunc sweep() {\n\tfreeCurrentObject := false\n\tfor block := gcBlock(0); block < endBlock; block++ {\n\t\tswitch block.state() {\n\t\tcase blockStateHead:\n\t\t\t// Unmarked head. Free it, including all tail blocks following it.\n\t\t\tblock.markFree()\n\t\t\tfreeCurrentObject = true\n\t\tcase blockStateTail:\n\t\t\tif freeCurrentObject {\n\t\t\t\t// This is a tail object following an unmarked head.\n\t\t\t\t// Free it now.\n\t\t\t\tblock.markFree()\n\t\t\t}\n\t\tcase blockStateMark:\n\t\t\t// This is a marked object. The next tail blocks must not be freed,\n\t\t\t// but the mark bit must be removed so the next GC cycle will\n\t\t\t// collect this object if it is unreferenced then.\n\t\t\tblock.unmark()\n\t\t\tfreeCurrentObject = false\n\t\t}\n\t}\n}\n\n// looksLikePointer returns whether this could be a pointer. Currently, it\n// simply returns whether it lies anywhere in the heap. Go allows interior\n// pointers so we can't check alignment or anything like that.\nfunc looksLikePointer(ptr uintptr) bool {\n\treturn ptr >= heapStart && ptr < uintptr(metadataStart)\n}\n\n// dumpHeap can be used for debugging purposes. It dumps the state of each heap\n// block to standard output.\nfunc dumpHeap() {\n\tprintln(\"heap:\")\n\tfor block := gcBlock(0); block < endBlock; block++ {\n\t\tswitch block.state() {\n\t\tcase blockStateHead:\n\t\t\tprint(\"*\")\n\t\tcase blockStateTail:\n\t\t\tprint(\"-\")\n\t\tcase blockStateMark:\n\t\t\tprint(\"#\")\n\t\tdefault: // free\n\t\t\tprint(\"\u00b7\")\n\t\t}\n\t\tif block%64 == 63 || block+1 == endBlock {\n\t\t\tprintln()\n\t\t}\n\t}\n}\n\nfunc KeepAlive(x interface{}) {\n\t// Unimplemented. Only required with SetFinalizer().\n}\n\nfunc SetFinalizer(obj interface{}, finalizer interface{}) {\n\t// Unimplemented.\n}\n","//go:build gc.conservative && tinygo.wasm\n// +build gc.conservative,tinygo.wasm\n\npackage runtime\n\nimport (\n\t\"unsafe\"\n)\n\n//go:extern runtime.stackChainStart\nvar stackChainStart *stackChainObject\n\ntype stackChainObject struct {\n\tparent   *stackChainObject\n\tnumSlots uintptr\n}\n\n// markStack marks all root pointers found on the stack.\n//\n// This implementation is conservative and relies on the compiler inserting code\n// to manually push/pop stack objects that are stored in a linked list starting\n// with stackChainStart. Manually keeping track of stack values is _much_ more\n// expensive than letting the compiler do it and it inhibits a few important\n// optimizations, but it has the big advantage of being portable to basically\n// any ISA, including WebAssembly.\nfunc markStack() {\n\tstackObject := stackChainStart\n\tfor stackObject != nil {\n\t\tstart := uintptr(unsafe.Pointer(stackObject)) + unsafe.Sizeof(uintptr(0))*2\n\t\tend := start + stackObject.numSlots*unsafe.Alignof(uintptr(0))\n\t\tmarkRoots(start, end)\n\t\tstackObject = stackObject.parent\n\t}\n}\n\n// trackPointer is a stub function call inserted by the compiler during IR\n// construction. Calls to it are later replaced with regular stack bookkeeping\n// code.\nfunc trackPointer(ptr unsafe.Pointer)\n\n// swapStackChain swaps the stack chain.\n// This is called from internal/task when switching goroutines.\nfunc swapStackChain(dst **stackChainObject) {\n\t*dst, stackChainStart = stackChainStart, *dst\n}\n","//go:build gc.conservative && (baremetal || tinygo.wasm)\n// +build gc.conservative\n// +build baremetal tinygo.wasm\n\npackage runtime\n\nimport \"unsafe\"\n\n// markGlobals marks all globals, which are reachable by definition.\n//\n// This implementation marks all globals conservatively and assumes it can use\n// linker-defined symbols for the start and end of the .data section.\nfunc markGlobals() {\n\tend := globalsEnd\n\tif GOARCH == \"wasm\" {\n\t\t// This is a workaround for a bug in wasm-ld: wasm-ld doesn't always\n\t\t// align __heap_base and when this memory is shared through an API, it\n\t\t// might result in unaligned memory. For details, see:\n\t\t// https://reviews.llvm.org/D106499\n\t\t// It should be removed once we switch to LLVM 13, where this is fixed.\n\t\tend = end &^ (unsafe.Alignof(end) - 1)\n\t}\n\tmarkRoots(globalsStart, end)\n}\n","// +build tinygo.wasm\n\npackage runtime\n\nimport (\n\t\"unsafe\"\n)\n\nconst GOARCH = \"wasm\"\n\n// The bitness of the CPU (e.g. 8, 32, 64).\nconst TargetBits = 32\n\n//go:extern __heap_base\nvar heapStartSymbol [0]byte\n\n//go:extern __global_base\nvar globalsStartSymbol [0]byte\n\n//export llvm.wasm.memory.size.i32\nfunc wasm_memory_size(index int32) int32\n\n//export llvm.wasm.memory.grow.i32\nfunc wasm_memory_grow(index int32, delta int32) int32\n\nvar (\n\theapStart    = uintptr(unsafe.Pointer(&heapStartSymbol))\n\theapEnd      = uintptr(wasm_memory_size(0) * wasmPageSize)\n\tglobalsStart = uintptr(unsafe.Pointer(&globalsStartSymbol))\n\tglobalsEnd   = uintptr(unsafe.Pointer(&heapStartSymbol))\n)\n\nconst wasmPageSize = 64 * 1024\n\nfunc align(ptr uintptr) uintptr {\n\t// Align to 16, which is the alignment of max_align_t:\n\t// https://godbolt.org/z/dYqTsWrGq\n\tconst heapAlign = 16\n\treturn (ptr + heapAlign - 1) &^ (heapAlign - 1)\n}\n\nfunc getCurrentStackPointer() uintptr\n\n// growHeap tries to grow the heap size. It returns true if it succeeds, false\n// otherwise.\nfunc growHeap() bool {\n\t// Grow memory by the available size, which means the heap size is doubled.\n\tmemorySize := wasm_memory_size(0)\n\tresult := wasm_memory_grow(0, memorySize)\n\tif result == -1 {\n\t\t// Grow failed.\n\t\treturn false\n\t}\n\n\tsetHeapEnd(uintptr(wasm_memory_size(0) * wasmPageSize))\n\n\t// Heap has grown successfully.\n\treturn true\n}\n\n// The below functions override the default allocator of wasi-libc.\n// Most functions are defined but unimplemented to make sure that if there is\n// any code using them, they will get an error instead of (incorrectly) using\n// the wasi-libc dlmalloc heap implementation instead. If they are needed by any\n// program, they can certainly be implemented.\n\n//export malloc\nfunc libc_malloc(size uintptr) unsafe.Pointer {\n\treturn alloc(size, nil)\n}\n\n//export free\nfunc libc_free(ptr unsafe.Pointer) {\n\tfree(ptr)\n}\n\n//export calloc\nfunc libc_calloc(nmemb, size uintptr) unsafe.Pointer {\n\t// Note: we could be even more correct here and check that nmemb * size\n\t// doesn't overflow. However the current implementation should normally work\n\t// fine.\n\treturn alloc(nmemb*size, nil)\n}\n\n//export realloc\nfunc libc_realloc(ptr unsafe.Pointer, size uintptr) unsafe.Pointer {\n\treturn realloc(ptr, size)\n}\n\n//export posix_memalign\nfunc libc_posix_memalign(memptr *unsafe.Pointer, alignment, size uintptr) int {\n\truntimePanic(\"unimplemented: posix_memalign\")\n\treturn 0\n}\n\n//export aligned_alloc\nfunc libc_aligned_alloc(alignment, bytes uintptr) unsafe.Pointer {\n\truntimePanic(\"unimplemented: aligned_alloc\")\n\treturn nil\n}\n\n//export malloc_usable_size\nfunc libc_malloc_usable_size(ptr unsafe.Pointer) uintptr {\n\truntimePanic(\"unimplemented: malloc_usable_size\")\n\treturn 0\n}\n","// +build tinygo.wasm\n\npackage runtime\n\nimport (\n\t\"unsafe\"\n)\n\n// Implements __wasi_iovec_t.\ntype __wasi_iovec_t struct {\n\tbuf    unsafe.Pointer\n\tbufLen uint\n}\n\n//go:wasm-module wasi_snapshot_preview1\n//export fd_write\nfunc fd_write(id uint32, iovs *__wasi_iovec_t, iovs_len uint, nwritten *uint) (errno uint)\n\n// See:\n// https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#-proc_exitrval-exitcode\n//go:wasm-module wasi_snapshot_preview1\n//export proc_exit\nfunc proc_exit(exitcode uint32)\n\nconst (\n\tputcharBufferSize = 120\n\tstdout            = 1\n)\n\n// Using global variables to avoid heap allocation.\nvar (\n\tputcharBuffer        = [putcharBufferSize]byte{}\n\tputcharPosition uint = 0\n\tputcharIOVec         = __wasi_iovec_t{\n\t\tbuf: unsafe.Pointer(&putcharBuffer[0]),\n\t}\n\tputcharNWritten uint\n)\n\nfunc putchar(c byte) {\n\tputcharBuffer[putcharPosition] = c\n\tputcharPosition++\n\n\tif c == '\\n' || putcharPosition >= putcharBufferSize {\n\t\tputcharIOVec.bufLen = putcharPosition\n\t\tfd_write(stdout, &putcharIOVec, 1, &putcharNWritten)\n\t\tputcharPosition = 0\n\t}\n}\n\n//go:linkname now time.now\nfunc now() (sec int64, nsec int32, mono int64) {\n\tmono = nanotime()\n\tsec = mono / (1000 * 1000 * 1000)\n\tnsec = int32(mono - sec*(1000*1000*1000))\n\treturn\n}\n\n// Abort executes the wasm 'unreachable' instruction.\nfunc abort() {\n\ttrap()\n}\n\n//go:linkname syscall_Exit syscall.Exit\nfunc syscall_Exit(code int) {\n\tproc_exit(uint32(code))\n}\n\n// TinyGo does not yet support any form of parallelism on WebAssembly, so these\n// can be left empty.\n\n//go:linkname procPin sync/atomic.runtime_procPin\nfunc procPin() {\n}\n\n//go:linkname procUnpin sync/atomic.runtime_procUnpin\nfunc procUnpin() {\n}\n","package runtime\n\n// This file implements Go interfaces.\n//\n// Interfaces are represented as a pair of {typecode, value}, where value can be\n// anything (including non-pointers).\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\ntype _interface struct {\n\ttypecode uintptr\n\tvalue    unsafe.Pointer\n}\n\n//go:inline\nfunc composeInterface(typecode uintptr, value unsafe.Pointer) _interface {\n\treturn _interface{typecode, value}\n}\n\n//go:inline\nfunc decomposeInterface(i _interface) (uintptr, unsafe.Pointer) {\n\treturn i.typecode, i.value\n}\n\n// Return true iff both interfaces are equal.\nfunc interfaceEqual(x, y interface{}) bool {\n\treturn reflectValueEqual(reflect.ValueOf(x), reflect.ValueOf(y))\n}\n\nfunc reflectValueEqual(x, y reflect.Value) bool {\n\t// Note: doing a x.Type() == y.Type() comparison would not work here as that\n\t// would introduce an infinite recursion: comparing two reflect.Type values\n\t// is done with this reflectValueEqual runtime call.\n\tif x.RawType() == 0 || y.RawType() == 0 {\n\t\t// One of them is nil.\n\t\treturn x.RawType() == y.RawType()\n\t}\n\n\tif x.RawType() != y.RawType() {\n\t\t// The type is not the same, which means the interfaces are definitely\n\t\t// not the same.\n\t\treturn false\n\t}\n\n\tswitch x.RawType().Kind() {\n\tcase reflect.Bool:\n\t\treturn x.Bool() == y.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn x.Int() == y.Int()\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn x.Uint() == y.Uint()\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn x.Float() == y.Float()\n\tcase reflect.Complex64, reflect.Complex128:\n\t\treturn x.Complex() == y.Complex()\n\tcase reflect.String:\n\t\treturn x.String() == y.String()\n\tcase reflect.Chan, reflect.Ptr, reflect.UnsafePointer:\n\t\treturn x.Pointer() == y.Pointer()\n\tcase reflect.Array:\n\t\tfor i := 0; i < x.Len(); i++ {\n\t\t\tif !reflectValueEqual(x.Index(i), y.Index(i)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase reflect.Struct:\n\t\tfor i := 0; i < x.NumField(); i++ {\n\t\t\tif !reflectValueEqual(x.Field(i), y.Field(i)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase reflect.Interface:\n\t\treturn reflectValueEqual(x.Elem(), y.Elem())\n\tdefault:\n\t\truntimePanic(\"comparing un-comparable type\")\n\t\treturn false // unreachable\n\t}\n}\n\n// interfaceTypeAssert is called when a type assert without comma-ok still\n// returns false.\nfunc interfaceTypeAssert(ok bool) {\n\tif !ok {\n\t\truntimePanic(\"type assert failed\")\n\t}\n}\n\n// The following declarations are only used during IR construction. They are\n// lowered to inline IR in the interface lowering pass.\n// See compiler/interface-lowering.go for details.\n\ntype interfaceMethodInfo struct {\n\tsignature *uint8  // external *i8 with a name identifying the Go function signature\n\tfuncptr   uintptr // bitcast from the actual function pointer\n}\n\ntype typecodeID struct {\n\t// Depending on the type kind of this typecodeID, this pointer is something\n\t// different:\n\t// * basic types: null\n\t// * named type: the underlying type\n\t// * interface: null\n\t// * chan/pointer/slice/array: the element type\n\t// * struct: bitcast of global with structField array\n\t// * func/map: TODO\n\treferences *typecodeID\n\n\t// The array length, for array types.\n\tlength uintptr\n\n\tmethodSet *interfaceMethodInfo // nil or a GEP of an array\n\n\t// The type that's a pointer to this type, nil if it is already a pointer.\n\t// Keeping the type struct alive here is important so that values from\n\t// reflect.New (which uses reflect.PtrTo) can be used in type asserts etc.\n\tptrTo *typecodeID\n\n\t// typeAssert is a ptrtoint of a declared interface assert function.\n\t// It only exists to make the rtcalls pass easier.\n\ttypeAssert uintptr\n}\n\n// structField is used by the compiler to pass information to the interface\n// lowering pass. It is not used in the final binary.\ntype structField struct {\n\ttypecode *typecodeID // type of this struct field\n\tname     *uint8      // pointer to char array\n\ttag      *uint8      // pointer to char array, or nil\n\tembedded bool\n}\n\n// Pseudo function call used during a type assert. It is used during interface\n// lowering, to assign the lowest type numbers to the types with the most type\n// asserts. Also, it is replaced with const false if this type assert can never\n// happen.\nfunc typeAssert(actualType uintptr, assertedType *uint8) bool\n","package reflect\n\nimport (\n\t\"unsafe\"\n)\n\n// This stores a varint for each named type. Named types are identified by their\n// name instead of by their type. The named types stored in this struct are\n// non-basic types: pointer, struct, and channel.\n//go:extern reflect.namedNonBasicTypesSidetable\nvar namedNonBasicTypesSidetable uintptr\n\n//go:extern reflect.structTypesSidetable\nvar structTypesSidetable byte\n\n//go:extern reflect.structNamesSidetable\nvar structNamesSidetable byte\n\n//go:extern reflect.arrayTypesSidetable\nvar arrayTypesSidetable byte\n\n// readStringSidetable reads a string from the given table (like\n// structNamesSidetable) and returns this string. No heap allocation is\n// necessary because it makes the string point directly to the raw bytes of the\n// table.\nfunc readStringSidetable(table unsafe.Pointer, index uintptr) string {\n\tnameLen, namePtr := readVarint(unsafe.Pointer(uintptr(table) + index))\n\treturn *(*string)(unsafe.Pointer(&stringHeader{\n\t\tdata: namePtr,\n\t\tlen:  nameLen,\n\t}))\n}\n\n// readVarint decodes a varint as used in the encoding/binary package.\n// It has an input pointer and returns the read varint and the pointer\n// incremented to the next field in the data structure, just after the varint.\n//\n// Details:\n// https://github.com/golang/go/blob/e37a1b1c/src/encoding/binary/varint.go#L7-L25\nfunc readVarint(buf unsafe.Pointer) (uintptr, unsafe.Pointer) {\n\tvar n uintptr\n\tshift := uintptr(0)\n\tfor {\n\t\t// Read the next byte in the buffer.\n\t\tc := *(*byte)(buf)\n\n\t\t// Decode the bits from this byte and add them to the output number.\n\t\tn |= uintptr(c&0x7f) << shift\n\t\tshift += 7\n\n\t\t// Increment the buf pointer (pointer arithmetic!).\n\t\tbuf = unsafe.Pointer(uintptr(buf) + 1)\n\n\t\t// Check whether this is the last byte of this varint. The upper bit\n\t\t// (msb) indicates whether any bytes follow.\n\t\tif c>>7 == 0 {\n\t\t\treturn n, buf\n\t\t}\n\t}\n}\n","// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package errors implements functions to manipulate errors.\n//\n// The New function creates errors whose only content is a text message.\n//\n// The Unwrap, Is and As functions work on errors that may wrap other errors.\n// An error wraps another error if its type has the method\n//\n//\tUnwrap() error\n//\n// If e.Unwrap() returns a non-nil error w, then we say that e wraps w.\n//\n// Unwrap unpacks wrapped errors. If its argument's type has an\n// Unwrap method, it calls the method once. Otherwise, it returns nil.\n//\n// A simple way to create wrapped errors is to call fmt.Errorf and apply the %w verb\n// to the error argument:\n//\n//\terrors.Unwrap(fmt.Errorf(\"... %w ...\", ..., err, ...))\n//\n// returns err.\n//\n// Is unwraps its first argument sequentially looking for an error that matches the\n// second. It reports whether it finds a match. It should be used in preference to\n// simple equality checks:\n//\n//\tif errors.Is(err, fs.ErrExist)\n//\n// is preferable to\n//\n//\tif err == fs.ErrExist\n//\n// because the former will succeed if err wraps fs.ErrExist.\n//\n// As unwraps its first argument sequentially looking for an error that can be\n// assigned to its second argument, which must be a pointer. If it succeeds, it\n// performs the assignment and returns true. Otherwise, it returns false. The form\n//\n//\tvar perr *fs.PathError\n//\tif errors.As(err, &perr) {\n//\t\tfmt.Println(perr.Path)\n//\t}\n//\n// is preferable to\n//\n//\tif perr, ok := err.(*fs.PathError); ok {\n//\t\tfmt.Println(perr.Path)\n//\t}\n//\n// because the former will succeed if err wraps an *fs.PathError.\npackage errors\n\n// New returns an error that formats as the given text.\n// Each call to New returns a distinct error value even if the text is identical.\nfunc New(text string) error {\n\treturn &errorString{text}\n}\n\n// errorString is a trivial implementation of error.\ntype errorString struct {\n\ts string\n}\n\nfunc (e *errorString) Error() string {\n\treturn e.s\n}\n","//go:build gc.conservative && tinygo.wasm\n// +build gc.conservative,tinygo.wasm\n\npackage task\n\nimport \"unsafe\"\n\n//go:linkname swapStackChain runtime.swapStackChain\nfunc swapStackChain(dst *unsafe.Pointer)\n\ntype gcData struct {\n\tstackChain unsafe.Pointer\n}\n\nfunc (gcd *gcData) swap() {\n\tswapStackChain(&gcd.stackChain)\n}\n","package task\n\nimport \"runtime/interrupt\"\n\nconst asserts = false\n\n// Queue is a FIFO container of tasks.\n// The zero value is an empty queue.\ntype Queue struct {\n\thead, tail *Task\n}\n\n// Push a task onto the queue.\nfunc (q *Queue) Push(t *Task) {\n\ti := interrupt.Disable()\n\tif asserts && t.Next != nil {\n\t\tinterrupt.Restore(i)\n\t\tpanic(\"runtime: pushing a task to a queue with a non-nil Next pointer\")\n\t}\n\tif q.tail != nil {\n\t\tq.tail.Next = t\n\t}\n\tq.tail = t\n\tt.Next = nil\n\tif q.head == nil {\n\t\tq.head = t\n\t}\n\tinterrupt.Restore(i)\n}\n\n// Pop a task off of the queue.\nfunc (q *Queue) Pop() *Task {\n\ti := interrupt.Disable()\n\tt := q.head\n\tif t == nil {\n\t\tinterrupt.Restore(i)\n\t\treturn nil\n\t}\n\tq.head = t.Next\n\tif q.tail == t {\n\t\tq.tail = nil\n\t}\n\tt.Next = nil\n\tinterrupt.Restore(i)\n\treturn t\n}\n\n// Append pops the contents of another queue and pushes them onto the end of this queue.\nfunc (q *Queue) Append(other *Queue) {\n\ti := interrupt.Disable()\n\tif q.head == nil {\n\t\tq.head = other.head\n\t} else {\n\t\tq.tail.Next = other.head\n\t}\n\tq.tail = other.tail\n\tother.head, other.tail = nil, nil\n\tinterrupt.Restore(i)\n}\n\n// Empty checks if the queue is empty.\nfunc (q *Queue) Empty() bool {\n\ti := interrupt.Disable()\n\tempty := q.head == nil\n\tinterrupt.Restore(i)\n\treturn empty\n}\n\n// Stack is a LIFO container of tasks.\n// The zero value is an empty stack.\n// This is slightly cheaper than a queue, so it can be preferable when strict ordering is not necessary.\ntype Stack struct {\n\ttop *Task\n}\n\n// Push a task onto the stack.\nfunc (s *Stack) Push(t *Task) {\n\ti := interrupt.Disable()\n\tif asserts && t.Next != nil {\n\t\tinterrupt.Restore(i)\n\t\tpanic(\"runtime: pushing a task to a stack with a non-nil Next pointer\")\n\t}\n\ts.top, t.Next = t, s.top\n\tinterrupt.Restore(i)\n}\n\n// Pop a task off of the stack.\nfunc (s *Stack) Pop() *Task {\n\ti := interrupt.Disable()\n\tt := s.top\n\tif t != nil {\n\t\ts.top = t.Next\n\t\tt.Next = nil\n\t}\n\tinterrupt.Restore(i)\n\treturn t\n}\n\n// tail follows the chain of tasks.\n// If t is nil, returns nil.\n// Otherwise, returns the task in the chain where the Next field is nil.\nfunc (t *Task) tail() *Task {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tfor t.Next != nil {\n\t\tt = t.Next\n\t}\n\treturn t\n}\n\n// Queue moves the contents of the stack into a queue.\n// Elements can be popped from the queue in the same order that they would be popped from the stack.\nfunc (s *Stack) Queue() Queue {\n\ti := interrupt.Disable()\n\thead := s.top\n\ts.top = nil\n\tq := Queue{\n\t\thead: head,\n\t\ttail: head.tail(),\n\t}\n\tinterrupt.Restore(i)\n\treturn q\n}\n","//go:build scheduler.asyncify\n// +build scheduler.asyncify\n\npackage task\n\nimport (\n\t\"unsafe\"\n)\n\n// Stack canary, to detect a stack overflow. The number is a random number\n// generated by random.org. The bit fiddling dance is necessary because\n// otherwise Go wouldn't allow the cast to a smaller integer size.\nconst stackCanary = uintptr(uint64(0x670c1333b83bf575) & uint64(^uintptr(0)))\n\n//go:linkname runtimePanic runtime.runtimePanic\nfunc runtimePanic(str string)\n\n// state is a structure which holds a reference to the state of the task.\n// When the task is suspended, the stack pointers are saved here.\ntype state struct {\n\t// entry is the entry function of the task.\n\t// This is needed every time the function is invoked so that asyncify knows what to rewind.\n\tentry uintptr\n\n\t// args are a pointer to a struct holding the arguments of the function.\n\targs unsafe.Pointer\n\n\t// stackState is the state of the stack while unwound.\n\tstackState\n\n\tlaunched bool\n}\n\n// stackState is the saved state of a stack while unwound.\n// The stack is arranged with asyncify at the bottom, C stack at the top, and a gap of available stack space between the two.\ntype stackState struct {\n\t// asyncify is the stack pointer of the asyncify stack.\n\t// This starts from the bottom and grows upwards.\n\tasyncifysp uintptr\n\n\t// asyncify is stack pointer of the C stack.\n\t// This starts from the top and grows downwards.\n\tcsp uintptr\n}\n\n// start creates and starts a new goroutine with the given function and arguments.\n// The new goroutine is immediately started.\nfunc start(fn uintptr, args unsafe.Pointer, stackSize uintptr) {\n\tt := &Task{}\n\tt.state.initialize(fn, args, stackSize)\n\trunqueuePushBack(t)\n}\n\n//export tinygo_launch\nfunc (*state) launch()\n\n//go:linkname align runtime.align\nfunc align(p uintptr) uintptr\n\n// initialize the state and prepare to call the specified function with the specified argument bundle.\nfunc (s *state) initialize(fn uintptr, args unsafe.Pointer, stackSize uintptr) {\n\t// Save the entry call.\n\ts.entry = fn\n\ts.args = args\n\n\t// Create a stack.\n\tstack := make([]uintptr, stackSize/unsafe.Sizeof(uintptr(0)))\n\n\t// Calculate stack base addresses.\n\ts.asyncifysp = uintptr(unsafe.Pointer(&stack[0]))\n\ts.csp = uintptr(unsafe.Pointer(&stack[0])) + uintptr(len(stack))*unsafe.Sizeof(uintptr(0))\n\tstack[0] = stackCanary\n}\n\n//go:linkname runqueuePushBack runtime.runqueuePushBack\nfunc runqueuePushBack(*Task)\n\n// currentTask is the current running task, or nil if currently in the scheduler.\nvar currentTask *Task\n\n// Current returns the current active task.\nfunc Current() *Task {\n\treturn currentTask\n}\n\n// Pause suspends the current task and returns to the scheduler.\n// This function may only be called when running on a goroutine stack, not when running on the system stack.\nfunc Pause() {\n\t// This is mildly unsafe but this is also the only place we can do this.\n\tif *(*uintptr)(unsafe.Pointer(currentTask.state.asyncifysp)) != stackCanary {\n\t\truntimePanic(\"stack overflow\")\n\t}\n\n\tcurrentTask.state.unwind()\n\n\t*(*uintptr)(unsafe.Pointer(currentTask.state.asyncifysp)) = stackCanary\n}\n\n//export tinygo_unwind\nfunc (*stackState) unwind()\n\n// Resume the task until it pauses or completes.\n// This may only be called from the scheduler.\nfunc (t *Task) Resume() {\n\t// The current task must be saved and restored because this can nest on WASM with JS.\n\tprevTask := currentTask\n\tt.gcData.swap()\n\tcurrentTask = t\n\tif !t.state.launched {\n\t\tt.state.launch()\n\t\tt.state.launched = true\n\t} else {\n\t\tt.state.rewind()\n\t}\n\tcurrentTask = prevTask\n\tt.gcData.swap()\n\tif t.state.asyncifysp > t.state.csp {\n\t\truntimePanic(\"stack overflow\")\n\t}\n}\n\n//export tinygo_rewind\nfunc (*state) rewind()\n\n// OnSystemStack returns whether the caller is running on the system stack.\nfunc OnSystemStack() bool {\n\t// If there is not an active goroutine, then this must be running on the system stack.\n\treturn Current() == nil\n}\n","package runtime\n\n// This file implements the TinyGo scheduler. This scheduler is a very simple\n// cooperative round robin scheduler, with a runqueue that contains a linked\n// list of goroutines (tasks) that should be run next, in order of when they\n// were added to the queue (first-in, first-out). It also contains a sleep queue\n// with sleeping goroutines in order of when they should be re-activated.\n//\n// The scheduler is used both for the asyncify based scheduler and for the task\n// based scheduler. In both cases, the 'internal/task.Task' type is used to represent one\n// goroutine.\n\nimport (\n\t\"internal/task\"\n)\n\nconst schedulerDebug = false\n\n// On JavaScript, we can't do a blocking sleep. Instead we have to return and\n// queue a new scheduler invocation using setTimeout.\nconst asyncScheduler = GOOS == \"js\"\n\nvar schedulerDone bool\n\n// Queues used by the scheduler.\nvar (\n\trunqueue           task.Queue\n\tsleepQueue         *task.Task\n\tsleepQueueBaseTime timeUnit\n)\n\n// Simple logging, for debugging.\nfunc scheduleLog(msg string) {\n\tif schedulerDebug {\n\t\tprintln(\"---\", msg)\n\t}\n}\n\n// Simple logging with a task pointer, for debugging.\nfunc scheduleLogTask(msg string, t *task.Task) {\n\tif schedulerDebug {\n\t\tprintln(\"---\", msg, t)\n\t}\n}\n\n// Simple logging with a channel and task pointer.\nfunc scheduleLogChan(msg string, ch *channel, t *task.Task) {\n\tif schedulerDebug {\n\t\tprintln(\"---\", msg, ch, t)\n\t}\n}\n\n// deadlock is called when a goroutine cannot proceed any more, but is in theory\n// not exited (so deferred calls won't run). This can happen for example in code\n// like this, that blocks forever:\n//\n//     select{}\n//go:noinline\nfunc deadlock() {\n\t// call yield without requesting a wakeup\n\ttask.Pause()\n\tpanic(\"unreachable\")\n}\n\n// Goexit terminates the currently running goroutine. No other goroutines are affected.\n//\n// Unlike the main Go implementation, no deffered calls will be run.\n//go:inline\nfunc Goexit() {\n\t// its really just a deadlock\n\tdeadlock()\n}\n\n// Add this task to the end of the run queue.\nfunc runqueuePushBack(t *task.Task) {\n\trunqueue.Push(t)\n}\n\n// Add this task to the sleep queue, assuming its state is set to sleeping.\nfunc addSleepTask(t *task.Task, duration timeUnit) {\n\tif schedulerDebug {\n\t\tprintln(\"  set sleep:\", t, duration)\n\t\tif t.Next != nil {\n\t\t\tpanic(\"runtime: addSleepTask: expected next task to be nil\")\n\t\t}\n\t}\n\tt.Data = uint64(duration)\n\tnow := ticks()\n\tif sleepQueue == nil {\n\t\tscheduleLog(\"  -> sleep new queue\")\n\n\t\t// set new base time\n\t\tsleepQueueBaseTime = now\n\t}\n\n\t// Add to sleep queue.\n\tq := &sleepQueue\n\tfor ; *q != nil; q = &(*q).Next {\n\t\tif t.Data < (*q).Data {\n\t\t\t// this will finish earlier than the next - insert here\n\t\t\tbreak\n\t\t} else {\n\t\t\t// this will finish later - adjust delay\n\t\t\tt.Data -= (*q).Data\n\t\t}\n\t}\n\tif *q != nil {\n\t\t// cut delay time between this sleep task and the next\n\t\t(*q).Data -= t.Data\n\t}\n\tt.Next = *q\n\t*q = t\n}\n\n// Run the scheduler until all tasks have finished.\nfunc scheduler() {\n\t// Main scheduler loop.\n\tvar now timeUnit\n\tfor !schedulerDone {\n\t\tscheduleLog(\"\")\n\t\tscheduleLog(\"  schedule\")\n\t\tif sleepQueue != nil {\n\t\t\tnow = ticks()\n\t\t}\n\n\t\t// Add tasks that are done sleeping to the end of the runqueue so they\n\t\t// will be executed soon.\n\t\tif sleepQueue != nil && now-sleepQueueBaseTime >= timeUnit(sleepQueue.Data) {\n\t\t\tt := sleepQueue\n\t\t\tscheduleLogTask(\"  awake:\", t)\n\t\t\tsleepQueueBaseTime += timeUnit(t.Data)\n\t\t\tsleepQueue = t.Next\n\t\t\tt.Next = nil\n\t\t\trunqueue.Push(t)\n\t\t}\n\n\t\tt := runqueue.Pop()\n\t\tif t == nil {\n\t\t\tif sleepQueue == nil {\n\t\t\t\tif asyncScheduler {\n\t\t\t\t\t// JavaScript is treated specially, see below.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twaitForEvents()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttimeLeft := timeUnit(sleepQueue.Data) - (now - sleepQueueBaseTime)\n\t\t\tif schedulerDebug {\n\t\t\t\tprintln(\"  sleeping...\", sleepQueue, uint(timeLeft))\n\t\t\t\tfor t := sleepQueue; t != nil; t = t.Next {\n\t\t\t\t\tprintln(\"    task sleeping:\", t, timeUnit(t.Data))\n\t\t\t\t}\n\t\t\t}\n\t\t\tsleepTicks(timeLeft)\n\t\t\tif asyncScheduler {\n\t\t\t\t// The sleepTicks function above only sets a timeout at which\n\t\t\t\t// point the scheduler will be called again. It does not really\n\t\t\t\t// sleep. So instead of sleeping, we return and expect to be\n\t\t\t\t// called again.\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Run the given task.\n\t\tscheduleLogTask(\"  run:\", t)\n\t\tt.Resume()\n\t}\n}\n\n// This horrible hack exists to make WASM work properly.\n// When a WASM program calls into JS which calls back into WASM, the event with which we called back in needs to be handled before returning.\n// Thus there are two copies of the scheduler running at once.\n// This is a reduced version of the scheduler which does not deal with the timer queue (that is a problem for the outer scheduler).\nfunc minSched() {\n\tscheduleLog(\"start nested scheduler\")\n\tfor !schedulerDone {\n\t\tt := runqueue.Pop()\n\t\tif t == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tscheduleLogTask(\"  run:\", t)\n\t\tt.Resume()\n\t}\n\tscheduleLog(\"stop nested scheduler\")\n}\n\nfunc Gosched() {\n\trunqueue.Push(task.Current())\n\ttask.Pause()\n}\n","package sync\n\nimport (\n\t\"internal/task\"\n\t_ \"unsafe\"\n)\n\ntype Mutex struct {\n\tlocked  bool\n\tblocked task.Stack\n}\n\n//go:linkname scheduleTask runtime.runqueuePushBack\nfunc scheduleTask(*task.Task)\n\nfunc (m *Mutex) Lock() {\n\tif m.locked {\n\t\t// Push self onto stack of blocked tasks, and wait to be resumed.\n\t\tm.blocked.Push(task.Current())\n\t\ttask.Pause()\n\t\treturn\n\t}\n\n\tm.locked = true\n}\n\nfunc (m *Mutex) Unlock() {\n\tif !m.locked {\n\t\tpanic(\"sync: unlock of unlocked Mutex\")\n\t}\n\n\t// Wake up a blocked task, if applicable.\n\tif t := m.blocked.Pop(); t != nil {\n\t\tscheduleTask(t)\n\t} else {\n\t\tm.locked = false\n\t}\n}\n\ntype RWMutex struct {\n\t// waitingWriters are all of the tasks waiting for write locks.\n\twaitingWriters task.Stack\n\n\t// waitingReaders are all of the tasks waiting for a read lock.\n\twaitingReaders task.Stack\n\n\t// state is the current state of the RWMutex.\n\t// Iff the mutex is completely unlocked, it contains rwMutexStateUnlocked (aka 0).\n\t// Iff the mutex is write-locked, it contains rwMutexStateWLocked.\n\t// While the mutex is read-locked, it contains the current number of readers.\n\tstate uint32\n}\n\nconst (\n\trwMutexStateUnlocked = uint32(0)\n\trwMutexStateWLocked  = ^uint32(0)\n\trwMutexMaxReaders    = rwMutexStateWLocked - 1\n)\n\nfunc (rw *RWMutex) Lock() {\n\tif rw.state == 0 {\n\t\t// The mutex is completely unlocked.\n\t\t// Lock without waiting.\n\t\trw.state = rwMutexStateWLocked\n\t\treturn\n\t}\n\n\t// Wait for the lock to be released.\n\trw.waitingWriters.Push(task.Current())\n\ttask.Pause()\n}\n\nfunc (rw *RWMutex) Unlock() {\n\tswitch rw.state {\n\tcase rwMutexStateWLocked:\n\t\t// This is correct.\n\n\tcase rwMutexStateUnlocked:\n\t\t// The mutex is already unlocked.\n\t\tpanic(\"sync: unlock of unlocked RWMutex\")\n\n\tdefault:\n\t\t// The mutex is read-locked instead of write-locked.\n\t\tpanic(\"sync: write-unlock of read-locked RWMutex\")\n\t}\n\n\tswitch {\n\tcase rw.maybeUnblockReaders():\n\t\t// Switched over to read mode.\n\n\tcase rw.maybeUnblockWriter():\n\t\t// Transferred to another writer.\n\n\tdefault:\n\t\t// Nothing is waiting for the lock.\n\t\trw.state = rwMutexStateUnlocked\n\t}\n}\n\nfunc (rw *RWMutex) RLock() {\n\tif rw.state == rwMutexStateWLocked {\n\t\t// Wait for the write lock to be released.\n\t\trw.waitingReaders.Push(task.Current())\n\t\ttask.Pause()\n\t\treturn\n\t}\n\n\tif rw.state == rwMutexMaxReaders {\n\t\tpanic(\"sync: too many readers on RWMutex\")\n\t}\n\n\t// Increase the reader count.\n\trw.state++\n}\n\nfunc (rw *RWMutex) RUnlock() {\n\tswitch rw.state {\n\tcase rwMutexStateUnlocked:\n\t\t// The mutex is already unlocked.\n\t\tpanic(\"sync: unlock of unlocked RWMutex\")\n\n\tcase rwMutexStateWLocked:\n\t\t// The mutex is write-locked instead of read-locked.\n\t\tpanic(\"sync: read-unlock of write-locked RWMutex\")\n\t}\n\n\trw.state--\n\n\tif rw.state == rwMutexStateUnlocked {\n\t\t// This was the last reader.\n\t\t// Try to unblock a writer.\n\t\trw.maybeUnblockWriter()\n\t}\n}\n\nfunc (rw *RWMutex) maybeUnblockReaders() bool {\n\tvar n uint32\n\tfor {\n\t\tt := rw.waitingReaders.Pop()\n\t\tif t == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tn++\n\t\tscheduleTask(t)\n\t}\n\tif n == 0 {\n\t\treturn false\n\t}\n\n\trw.state = n\n\treturn true\n}\n\nfunc (rw *RWMutex) maybeUnblockWriter() bool {\n\tt := rw.waitingWriters.Pop()\n\tif t == nil {\n\t\treturn false\n\t}\n\n\trw.state = rwMutexStateWLocked\n\tscheduleTask(t)\n\n\treturn true\n}\n\ntype Locker interface {\n\tLock()\n\tUnlock()\n}\n\n// RLocker returns a Locker interface that implements\n// the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.\nfunc (rw *RWMutex) RLocker() Locker {\n\treturn (*rlocker)(rw)\n}\n\ntype rlocker RWMutex\n\nfunc (r *rlocker) Lock()   { (*RWMutex)(r).RLock() }\nfunc (r *rlocker) Unlock() { (*RWMutex)(r).RUnlock() }\n","package sync\n\ntype Once struct {\n\tdone bool\n\tm    Mutex\n}\n\nfunc (o *Once) Do(f func()) {\n\to.m.Lock()\n\tdefer o.m.Unlock()\n\tif o.done {\n\t\treturn\n\t}\n\to.done = true\n\tf()\n}\n","// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage atomic\n\nimport (\n\t\"unsafe\"\n)\n\n// A Value provides an atomic load and store of a consistently typed value.\n// The zero value for a Value returns nil from Load.\n// Once Store has been called, a Value must not be copied.\n//\n// A Value must not be copied after first use.\ntype Value struct {\n\tv interface{}\n}\n\n// ifaceWords is interface{} internal representation.\ntype ifaceWords struct {\n\ttyp  unsafe.Pointer\n\tdata unsafe.Pointer\n}\n\n// Load returns the value set by the most recent Store.\n// It returns nil if there has been no call to Store for this Value.\nfunc (v *Value) Load() (val interface{}) {\n\tvp := (*ifaceWords)(unsafe.Pointer(v))\n\ttyp := LoadPointer(&vp.typ)\n\tif typ == nil || uintptr(typ) == ^uintptr(0) {\n\t\t// First store not yet completed.\n\t\treturn nil\n\t}\n\tdata := LoadPointer(&vp.data)\n\tvlp := (*ifaceWords)(unsafe.Pointer(&val))\n\tvlp.typ = typ\n\tvlp.data = data\n\treturn\n}\n\n// Store sets the value of the Value to x.\n// All calls to Store for a given Value must use values of the same concrete type.\n// Store of an inconsistent type panics, as does Store(nil).\nfunc (v *Value) Store(val interface{}) {\n\tif val == nil {\n\t\tpanic(\"sync/atomic: store of nil value into Value\")\n\t}\n\tvp := (*ifaceWords)(unsafe.Pointer(v))\n\tvlp := (*ifaceWords)(unsafe.Pointer(&val))\n\tfor {\n\t\ttyp := LoadPointer(&vp.typ)\n\t\tif typ == nil {\n\t\t\t// Attempt to start first store.\n\t\t\t// Disable preemption so that other goroutines can use\n\t\t\t// active spin wait to wait for completion; and so that\n\t\t\t// GC does not see the fake type accidentally.\n\t\t\truntime_procPin()\n\t\t\tif !CompareAndSwapPointer(&vp.typ, nil, unsafe.Pointer(^uintptr(0))) {\n\t\t\t\truntime_procUnpin()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Complete first store.\n\t\t\tStorePointer(&vp.data, vlp.data)\n\t\t\tStorePointer(&vp.typ, vlp.typ)\n\t\t\truntime_procUnpin()\n\t\t\treturn\n\t\t}\n\t\tif uintptr(typ) == ^uintptr(0) {\n\t\t\t// First store in progress. Wait.\n\t\t\t// Since we disable preemption around the first store,\n\t\t\t// we can wait with active spinning.\n\t\t\tcontinue\n\t\t}\n\t\t// First store completed. Check type and overwrite data.\n\t\tif typ != vlp.typ {\n\t\t\tpanic(\"sync/atomic: store of inconsistently typed value into Value\")\n\t\t}\n\t\tStorePointer(&vp.data, vlp.data)\n\t\treturn\n\t}\n}\n\n// Swap stores new into Value and returns the previous value. It returns nil if\n// the Value is empty.\n//\n// All calls to Swap for a given Value must use values of the same concrete\n// type. Swap of an inconsistent type panics, as does Swap(nil).\nfunc (v *Value) Swap(new interface{}) (old interface{}) {\n\tif new == nil {\n\t\tpanic(\"sync/atomic: swap of nil value into Value\")\n\t}\n\tvp := (*ifaceWords)(unsafe.Pointer(v))\n\tnp := (*ifaceWords)(unsafe.Pointer(&new))\n\tfor {\n\t\ttyp := LoadPointer(&vp.typ)\n\t\tif typ == nil {\n\t\t\t// Attempt to start first store.\n\t\t\t// Disable preemption so that other goroutines can use\n\t\t\t// active spin wait to wait for completion; and so that\n\t\t\t// GC does not see the fake type accidentally.\n\t\t\truntime_procPin()\n\t\t\tif !CompareAndSwapPointer(&vp.typ, nil, unsafe.Pointer(^uintptr(0))) {\n\t\t\t\truntime_procUnpin()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Complete first store.\n\t\t\tStorePointer(&vp.data, np.data)\n\t\t\tStorePointer(&vp.typ, np.typ)\n\t\t\truntime_procUnpin()\n\t\t\treturn nil\n\t\t}\n\t\tif uintptr(typ) == ^uintptr(0) {\n\t\t\t// First store in progress. Wait.\n\t\t\t// Since we disable preemption around the first store,\n\t\t\t// we can wait with active spinning.\n\t\t\tcontinue\n\t\t}\n\t\t// First store completed. Check type and overwrite data.\n\t\tif typ != np.typ {\n\t\t\tpanic(\"sync/atomic: swap of inconsistently typed value into Value\")\n\t\t}\n\t\top := (*ifaceWords)(unsafe.Pointer(&old))\n\t\top.typ, op.data = np.typ, SwapPointer(&vp.data, np.data)\n\t\treturn old\n\t}\n}\n\n// CompareAndSwap executes the compare-and-swap operation for the Value.\n//\n// All calls to CompareAndSwap for a given Value must use values of the same\n// concrete type. CompareAndSwap of an inconsistent type panics, as does\n// CompareAndSwap(old, nil).\nfunc (v *Value) CompareAndSwap(old, new interface{}) (swapped bool) {\n\tif new == nil {\n\t\tpanic(\"sync/atomic: compare and swap of nil value into Value\")\n\t}\n\tvp := (*ifaceWords)(unsafe.Pointer(v))\n\tnp := (*ifaceWords)(unsafe.Pointer(&new))\n\top := (*ifaceWords)(unsafe.Pointer(&old))\n\tif op.typ != nil && np.typ != op.typ {\n\t\tpanic(\"sync/atomic: compare and swap of inconsistently typed values\")\n\t}\n\tfor {\n\t\ttyp := LoadPointer(&vp.typ)\n\t\tif typ == nil {\n\t\t\tif old != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Attempt to start first store.\n\t\t\t// Disable preemption so that other goroutines can use\n\t\t\t// active spin wait to wait for completion; and so that\n\t\t\t// GC does not see the fake type accidentally.\n\t\t\truntime_procPin()\n\t\t\tif !CompareAndSwapPointer(&vp.typ, nil, unsafe.Pointer(^uintptr(0))) {\n\t\t\t\truntime_procUnpin()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Complete first store.\n\t\t\tStorePointer(&vp.data, np.data)\n\t\t\tStorePointer(&vp.typ, np.typ)\n\t\t\truntime_procUnpin()\n\t\t\treturn true\n\t\t}\n\t\tif uintptr(typ) == ^uintptr(0) {\n\t\t\t// First store in progress. Wait.\n\t\t\t// Since we disable preemption around the first store,\n\t\t\t// we can wait with active spinning.\n\t\t\tcontinue\n\t\t}\n\t\t// First store completed. Check type and overwrite data.\n\t\tif typ != np.typ {\n\t\t\tpanic(\"sync/atomic: compare and swap of inconsistently typed value into Value\")\n\t\t}\n\t\t// Compare old and current via runtime equality check.\n\t\t// This allows value types to be compared, something\n\t\t// not offered by the package functions.\n\t\t// CompareAndSwapPointer below only ensures vp.data\n\t\t// has not changed since LoadPointer.\n\t\tdata := LoadPointer(&vp.data)\n\t\tvar i interface{}\n\t\t(*ifaceWords)(unsafe.Pointer(&i)).typ = typ\n\t\t(*ifaceWords)(unsafe.Pointer(&i)).data = data\n\t\tif i != old {\n\t\t\treturn false\n\t\t}\n\t\treturn CompareAndSwapPointer(&vp.data, data, np.data)\n\t}\n}\n\n// Disable/enable preemption, implemented in runtime.\nfunc runtime_procPin()\nfunc runtime_procUnpin()\n","package runtime\n\nimport (\n\t\"unsafe\"\n)\n\ntype stringer interface {\n\tString() string\n}\n\n//go:nobounds\nfunc printstring(s string) {\n\tfor i := 0; i < len(s); i++ {\n\t\tputchar(s[i])\n\t}\n}\n\nfunc printuint8(n uint8) {\n\tif TargetBits >= 32 {\n\t\tprintuint32(uint32(n))\n\t} else {\n\t\tprevdigits := n / 10\n\t\tif prevdigits != 0 {\n\t\t\tprintuint8(prevdigits)\n\t\t}\n\t\tputchar(byte((n % 10) + '0'))\n\t}\n}\n\nfunc printint8(n int8) {\n\tif TargetBits >= 32 {\n\t\tprintint32(int32(n))\n\t} else {\n\t\tif n < 0 {\n\t\t\tputchar('-')\n\t\t\tn = -n\n\t\t}\n\t\tprintuint8(uint8(n))\n\t}\n}\n\nfunc printuint16(n uint16) {\n\tprintuint32(uint32(n))\n}\n\nfunc printint16(n int16) {\n\tprintint32(int32(n))\n}\n\nfunc printuint32(n uint32) {\n\tprintuint64(uint64(n))\n}\n\nfunc printint32(n int32) {\n\t// Print integer in signed big-endian base-10 notation, for humans to\n\t// read.\n\tif n < 0 {\n\t\tputchar('-')\n\t\tn = -n\n\t}\n\tprintuint32(uint32(n))\n}\n\n//go:nobounds\nfunc printuint64(n uint64) {\n\tdigits := [20]byte{} // enough to hold (2^64)-1\n\t// Fill in all 10 digits.\n\tfirstdigit := 19 // digit index that isn't zero (by default, the last to handle '0' correctly)\n\tfor i := 19; i >= 0; i-- {\n\t\tdigit := byte(n%10 + '0')\n\t\tdigits[i] = digit\n\t\tif digit != '0' {\n\t\t\tfirstdigit = i\n\t\t}\n\t\tn /= 10\n\t}\n\t// Print digits without the leading zeroes.\n\tfor i := firstdigit; i < 20; i++ {\n\t\tputchar(digits[i])\n\t}\n}\n\nfunc printint64(n int64) {\n\tif n < 0 {\n\t\tputchar('-')\n\t\tn = -n\n\t}\n\tprintuint64(uint64(n))\n}\n\n// printfloat32() was copied from the relevant source in the original Go\n// implementation and modified to work with float32 instead of float64. It is\n// copyright by the Go authors, licensed under the same BSD 3-clause license.\n// See https://golang.org/LICENSE for details.\n//\n// It is a near-duplicate of printfloat64. This is done so that printing a\n// float32 value doesn't involve float64 routines, which can be unexpected and a\n// problem sometimes. It comes with a possible code size reduction if both\n// printfloat32 and printfloat64 are used, which seems uncommon.\n//\n// Source:\n// https://github.com/golang/go/blob/master/src/runtime/print.go\nfunc printfloat32(v float32) {\n\tswitch {\n\tcase v != v:\n\t\tprintstring(\"NaN\")\n\t\treturn\n\tcase v+v == v && v > 0:\n\t\tprintstring(\"+Inf\")\n\t\treturn\n\tcase v+v == v && v < 0:\n\t\tprintstring(\"-Inf\")\n\t\treturn\n\t}\n\n\tconst n = 7 // digits printed\n\tvar buf [n + 7]byte\n\tbuf[0] = '+'\n\te := 0 // exp\n\tif v == 0 {\n\t\tif 1/v < 0 {\n\t\t\tbuf[0] = '-'\n\t\t}\n\t} else {\n\t\tif v < 0 {\n\t\t\tv = -v\n\t\t\tbuf[0] = '-'\n\t\t}\n\n\t\t// normalize\n\t\tfor v >= 10 {\n\t\t\te++\n\t\t\tv /= 10\n\t\t}\n\t\tfor v < 1 {\n\t\t\te--\n\t\t\tv *= 10\n\t\t}\n\n\t\t// round\n\t\th := float32(5.0)\n\t\tfor i := 0; i < n; i++ {\n\t\t\th /= 10\n\t\t}\n\t\tv += h\n\t\tif v >= 10 {\n\t\t\te++\n\t\t\tv /= 10\n\t\t}\n\t}\n\n\t// format +d.dddd+edd\n\tfor i := 0; i < n; i++ {\n\t\ts := int(v)\n\t\tbuf[i+2] = byte(s + '0')\n\t\tv -= float32(s)\n\t\tv *= 10\n\t}\n\tbuf[1] = buf[2]\n\tbuf[2] = '.'\n\n\tbuf[n+2] = 'e'\n\tbuf[n+3] = '+'\n\tif e < 0 {\n\t\te = -e\n\t\tbuf[n+3] = '-'\n\t}\n\n\tbuf[n+4] = byte(e/100) + '0'\n\tbuf[n+5] = byte(e/10)%10 + '0'\n\tbuf[n+6] = byte(e%10) + '0'\n\tfor _, c := range buf {\n\t\tputchar(c)\n\t}\n}\n\n// printfloat64() was copied from the relevant source in the original Go\n// implementation. It is copyright by the Go authors, licensed under the same\n// BSD 3-clause license. See https://golang.org/LICENSE for details.\n//\n// Source:\n// https://github.com/golang/go/blob/master/src/runtime/print.go\nfunc printfloat64(v float64) {\n\tswitch {\n\tcase v != v:\n\t\tprintstring(\"NaN\")\n\t\treturn\n\tcase v+v == v && v > 0:\n\t\tprintstring(\"+Inf\")\n\t\treturn\n\tcase v+v == v && v < 0:\n\t\tprintstring(\"-Inf\")\n\t\treturn\n\t}\n\n\tconst n = 7 // digits printed\n\tvar buf [n + 7]byte\n\tbuf[0] = '+'\n\te := 0 // exp\n\tif v == 0 {\n\t\tif 1/v < 0 {\n\t\t\tbuf[0] = '-'\n\t\t}\n\t} else {\n\t\tif v < 0 {\n\t\t\tv = -v\n\t\t\tbuf[0] = '-'\n\t\t}\n\n\t\t// normalize\n\t\tfor v >= 10 {\n\t\t\te++\n\t\t\tv /= 10\n\t\t}\n\t\tfor v < 1 {\n\t\t\te--\n\t\t\tv *= 10\n\t\t}\n\n\t\t// round\n\t\th := 5.0\n\t\tfor i := 0; i < n; i++ {\n\t\t\th /= 10\n\t\t}\n\t\tv += h\n\t\tif v >= 10 {\n\t\t\te++\n\t\t\tv /= 10\n\t\t}\n\t}\n\n\t// format +d.dddd+edd\n\tfor i := 0; i < n; i++ {\n\t\ts := int(v)\n\t\tbuf[i+2] = byte(s + '0')\n\t\tv -= float64(s)\n\t\tv *= 10\n\t}\n\tbuf[1] = buf[2]\n\tbuf[2] = '.'\n\n\tbuf[n+2] = 'e'\n\tbuf[n+3] = '+'\n\tif e < 0 {\n\t\te = -e\n\t\tbuf[n+3] = '-'\n\t}\n\n\tbuf[n+4] = byte(e/100) + '0'\n\tbuf[n+5] = byte(e/10)%10 + '0'\n\tbuf[n+6] = byte(e%10) + '0'\n\tfor _, c := range buf {\n\t\tputchar(c)\n\t}\n}\n\nfunc printcomplex64(c complex64) {\n\tputchar('(')\n\tprintfloat32(real(c))\n\tprintfloat32(imag(c))\n\tprintstring(\"i)\")\n}\n\nfunc printcomplex128(c complex128) {\n\tputchar('(')\n\tprintfloat64(real(c))\n\tprintfloat64(imag(c))\n\tprintstring(\"i)\")\n}\n\nfunc printspace() {\n\tputchar(' ')\n}\n\nfunc printnl() {\n\tif baremetal {\n\t\tputchar('\\r')\n\t}\n\tputchar('\\n')\n}\n\nfunc printitf(msg interface{}) {\n\tswitch msg := msg.(type) {\n\tcase bool:\n\t\tprint(msg)\n\tcase int:\n\t\tprint(msg)\n\tcase int8:\n\t\tprint(msg)\n\tcase int16:\n\t\tprint(msg)\n\tcase int32:\n\t\tprint(msg)\n\tcase int64:\n\t\tprint(msg)\n\tcase uint:\n\t\tprint(msg)\n\tcase uint8:\n\t\tprint(msg)\n\tcase uint16:\n\t\tprint(msg)\n\tcase uint32:\n\t\tprint(msg)\n\tcase uint64:\n\t\tprint(msg)\n\tcase uintptr:\n\t\tprint(msg)\n\tcase float32:\n\t\tprint(msg)\n\tcase float64:\n\t\tprint(msg)\n\tcase complex64:\n\t\tprint(msg)\n\tcase complex128:\n\t\tprint(msg)\n\tcase string:\n\t\tprint(msg)\n\tcase error:\n\t\tprint(msg.Error())\n\tcase stringer:\n\t\tprint(msg.String())\n\tdefault:\n\t\t// cast to underlying type\n\t\titf := *(*_interface)(unsafe.Pointer(&msg))\n\t\tputchar('(')\n\t\tswitch unsafe.Sizeof(itf.typecode) {\n\t\tcase 2:\n\t\t\tprintuint16(uint16(itf.typecode))\n\t\tcase 4:\n\t\t\tprintuint32(uint32(itf.typecode))\n\t\tcase 8:\n\t\t\tprintuint64(uint64(itf.typecode))\n\t\t}\n\t\tputchar(':')\n\t\tprint(itf.value)\n\t\tputchar(')')\n\t}\n}\n\nfunc printmap(m *hashmap) {\n\tprint(\"map[\")\n\tif m == nil {\n\t\tprint(\"nil\")\n\t} else {\n\t\tprint(uint(m.count))\n\t}\n\tputchar(']')\n}\n\nfunc printptr(ptr uintptr) {\n\tif ptr == 0 {\n\t\tprint(\"nil\")\n\t\treturn\n\t}\n\tputchar('0')\n\tputchar('x')\n\tfor i := 0; i < int(unsafe.Sizeof(ptr))*2; i++ {\n\t\tnibble := byte(ptr >> (unsafe.Sizeof(ptr)*8 - 4))\n\t\tif nibble < 10 {\n\t\t\tputchar(nibble + '0')\n\t\t} else {\n\t\t\tputchar(nibble - 10 + 'a')\n\t\t}\n\t\tptr <<= 4\n\t}\n}\n\nfunc printbool(b bool) {\n\tif b {\n\t\tprintstring(\"true\")\n\t} else {\n\t\tprintstring(\"false\")\n\t}\n}\n","package runtime\n\n// This file implements functions related to Go strings.\n\nimport (\n\t\"unsafe\"\n)\n\n// The underlying struct for the Go string type.\ntype _string struct {\n\tptr    *byte\n\tlength uintptr\n}\n\n// The iterator state for a range over a string.\ntype stringIterator struct {\n\tbyteindex uintptr\n}\n\n// Return true iff the strings match.\n//go:nobounds\nfunc stringEqual(x, y string) bool {\n\tif len(x) != len(y) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(x); i++ {\n\t\tif x[i] != y[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Return true iff x < y.\n//go:nobounds\nfunc stringLess(x, y string) bool {\n\tl := len(x)\n\tif m := len(y); m < l {\n\t\tl = m\n\t}\n\tfor i := 0; i < l; i++ {\n\t\tif x[i] < y[i] {\n\t\t\treturn true\n\t\t}\n\t\tif x[i] > y[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn len(x) < len(y)\n}\n\n// Add two strings together.\nfunc stringConcat(x, y _string) _string {\n\tif x.length == 0 {\n\t\treturn y\n\t} else if y.length == 0 {\n\t\treturn x\n\t} else {\n\t\tlength := x.length + y.length\n\t\tbuf := alloc(length, nil)\n\t\tmemcpy(buf, unsafe.Pointer(x.ptr), x.length)\n\t\tmemcpy(unsafe.Pointer(uintptr(buf)+x.length), unsafe.Pointer(y.ptr), y.length)\n\t\treturn _string{ptr: (*byte)(buf), length: length}\n\t}\n}\n\n// Create a string from a []byte slice.\nfunc stringFromBytes(x struct {\n\tptr *byte\n\tlen uintptr\n\tcap uintptr\n}) _string {\n\tbuf := alloc(x.len, nil)\n\tmemcpy(buf, unsafe.Pointer(x.ptr), x.len)\n\treturn _string{ptr: (*byte)(buf), length: x.len}\n}\n\n// Convert a string to a []byte slice.\nfunc stringToBytes(x _string) (slice struct {\n\tptr *byte\n\tlen uintptr\n\tcap uintptr\n}) {\n\tbuf := alloc(x.length, nil)\n\tmemcpy(buf, unsafe.Pointer(x.ptr), x.length)\n\tslice.ptr = (*byte)(buf)\n\tslice.len = x.length\n\tslice.cap = x.length\n\treturn\n}\n\n// Convert a []rune slice to a string.\nfunc stringFromRunes(runeSlice []rune) (s _string) {\n\t// Count the number of characters that will be in the string.\n\tfor _, r := range runeSlice {\n\t\t_, numBytes := encodeUTF8(r)\n\t\ts.length += numBytes\n\t}\n\n\t// Allocate memory for the string.\n\ts.ptr = (*byte)(alloc(s.length, nil))\n\n\t// Encode runes to UTF-8 and store the resulting bytes in the string.\n\tindex := uintptr(0)\n\tfor _, r := range runeSlice {\n\t\tarray, numBytes := encodeUTF8(r)\n\t\tfor _, c := range array[:numBytes] {\n\t\t\t*(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(s.ptr)) + index)) = c\n\t\t\tindex++\n\t\t}\n\t}\n\n\treturn\n}\n\n// Convert a string to []rune slice.\nfunc stringToRunes(s string) []rune {\n\tvar n = 0\n\tfor range s {\n\t\tn++\n\t}\n\tvar r = make([]rune, n)\n\tn = 0\n\tfor _, e := range s {\n\t\tr[n] = e\n\t\tn++\n\t}\n\treturn r\n}\n\n// Create a string from a Unicode code point.\nfunc stringFromUnicode(x rune) _string {\n\tarray, length := encodeUTF8(x)\n\t// Array will be heap allocated.\n\t// The heap most likely doesn't work with blocks below 4 bytes, so there's\n\t// no point in allocating a smaller buffer for the string here.\n\treturn _string{ptr: (*byte)(unsafe.Pointer(&array)), length: length}\n}\n\n// Iterate over a string.\n// Returns (ok, key, value).\nfunc stringNext(s string, it *stringIterator) (bool, int, rune) {\n\tif len(s) <= int(it.byteindex) {\n\t\treturn false, 0, 0\n\t}\n\ti := int(it.byteindex)\n\tr, length := decodeUTF8(s, it.byteindex)\n\tit.byteindex += length\n\treturn true, i, r\n}\n\n// Convert a Unicode code point into an array of bytes and its length.\nfunc encodeUTF8(x rune) ([4]byte, uintptr) {\n\t// https://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16\n\t// Note: this code can probably be optimized (in size and speed).\n\tswitch {\n\tcase x <= 0x7f:\n\t\treturn [4]byte{byte(x), 0, 0, 0}, 1\n\tcase x <= 0x7ff:\n\t\tb1 := 0xc0 | byte(x>>6)\n\t\tb2 := 0x80 | byte(x&0x3f)\n\t\treturn [4]byte{b1, b2, 0, 0}, 2\n\tcase 0xd800 <= x && x <= 0xdfff:\n\t\t// utf-16 surrogates are replaced with \"invalid code point\"\n\t\treturn [4]byte{0xef, 0xbf, 0xbd, 0}, 3\n\tcase x <= 0xffff:\n\t\tb1 := 0xe0 | byte(x>>12)\n\t\tb2 := 0x80 | byte((x>>6)&0x3f)\n\t\tb3 := 0x80 | byte((x>>0)&0x3f)\n\t\treturn [4]byte{b1, b2, b3, 0}, 3\n\tcase x <= 0x10ffff:\n\t\tb1 := 0xf0 | byte(x>>18)\n\t\tb2 := 0x80 | byte((x>>12)&0x3f)\n\t\tb3 := 0x80 | byte((x>>6)&0x3f)\n\t\tb4 := 0x80 | byte((x>>0)&0x3f)\n\t\treturn [4]byte{b1, b2, b3, b4}, 4\n\tdefault:\n\t\t// Invalid Unicode code point.\n\t\treturn [4]byte{0xef, 0xbf, 0xbd, 0}, 3\n\t}\n}\n\n// Decode a single UTF-8 character from a string.\n//go:nobounds\nfunc decodeUTF8(s string, index uintptr) (rune, uintptr) {\n\tremaining := uintptr(len(s)) - index // must be >= 1 before calling this function\n\tx := s[index]\n\tswitch {\n\tcase x&0x80 == 0x00: // 0xxxxxxx\n\t\treturn rune(x), 1\n\tcase x&0xe0 == 0xc0: // 110xxxxx\n\t\tif remaining < 2 || !isContinuation(s[index+1]) {\n\t\t\treturn 0xfffd, 1\n\t\t}\n\t\tr := (rune(x&0x1f) << 6) | (rune(s[index+1]) & 0x3f)\n\t\tif r >= 1<<7 {\n\t\t\t// Check whether the rune really needed to be encoded as a two-byte\n\t\t\t// sequence. UTF-8 requires every rune to be encoded in the smallest\n\t\t\t// sequence possible.\n\t\t\treturn r, 2\n\t\t}\n\tcase x&0xf0 == 0xe0: // 1110xxxx\n\t\tif remaining < 3 || !isContinuation(s[index+1]) || !isContinuation(s[index+2]) {\n\t\t\treturn 0xfffd, 1\n\t\t}\n\t\tr := (rune(x&0x0f) << 12) | ((rune(s[index+1]) & 0x3f) << 6) | (rune(s[index+2]) & 0x3f)\n\t\tif r >= 1<<11 && !(r >= 0xD800 && r <= 0xDFFF) {\n\t\t\t// Check whether the rune really needed to be encoded as a\n\t\t\t// three-byte sequence and check that this is not a Unicode\n\t\t\t// surrogate pair (which are not allowed by UTF-8).\n\t\t\treturn r, 3\n\t\t}\n\tcase x&0xf8 == 0xf0: // 11110xxx\n\t\tif remaining < 4 || !isContinuation(s[index+1]) || !isContinuation(s[index+2]) || !isContinuation(s[index+3]) {\n\t\t\treturn 0xfffd, 1\n\t\t}\n\t\tr := (rune(x&0x07) << 18) | ((rune(s[index+1]) & 0x3f) << 12) | ((rune(s[index+2]) & 0x3f) << 6) | (rune(s[index+3]) & 0x3f)\n\t\tif r >= 1<<16 && r <= '\\U0010FFFF' {\n\t\t\t// Check whether this rune really needed to be encoded as a four\n\t\t\t// byte sequence and check that the resulting rune is in the valid\n\t\t\t// range (up to at most U+10FFFF).\n\t\t\treturn r, 4\n\t\t}\n\t}\n\n\t// Failed to decode. Return the Unicode replacement character and a length of 1.\n\treturn 0xfffd, 1\n}\n\n// isContinuation returns true if (and only if) this is a UTF-8 continuation\n// byte.\nfunc isContinuation(b byte) bool {\n\t// Continuation bytes have their topmost bits set to 0b10.\n\treturn b&0xc0 == 0x80\n}\n\n// Functions used in CGo.\n\n// Convert a Go string to a C string.\nfunc cgo_CString(s _string) unsafe.Pointer {\n\tbuf := malloc(s.length + 1)\n\tmemcpy(buf, unsafe.Pointer(s.ptr), s.length)\n\t*(*byte)(unsafe.Pointer(uintptr(buf) + s.length)) = 0 // trailing 0 byte\n\treturn buf\n}\n\n// Convert a C string to a Go string.\nfunc cgo_GoString(cstr unsafe.Pointer) _string {\n\tif cstr == nil {\n\t\treturn _string{}\n\t}\n\treturn makeGoString(cstr, strlen(cstr))\n}\n\n// Convert a C data buffer to a Go string (that possibly contains 0 bytes).\nfunc cgo_GoStringN(cstr unsafe.Pointer, length uintptr) _string {\n\treturn makeGoString(cstr, length)\n}\n\n// Make a Go string given a source buffer and a length.\nfunc makeGoString(cstr unsafe.Pointer, length uintptr) _string {\n\ts := _string{\n\t\tlength: length,\n\t}\n\tif s.length != 0 {\n\t\tbuf := make([]byte, s.length)\n\t\ts.ptr = &buf[0]\n\t\tmemcpy(unsafe.Pointer(s.ptr), cstr, s.length)\n\t}\n\treturn s\n}\n\n// Convert a C data buffer to a Go byte slice.\nfunc cgo_GoBytes(ptr unsafe.Pointer, length uintptr) []byte {\n\t// Note: don't return nil if length is 0, to match the behavior of C.GoBytes\n\t// of upstream Go.\n\tbuf := make([]byte, length)\n\tif length != 0 {\n\t\tmemcpy(unsafe.Pointer(&buf[0]), ptr, uintptr(length))\n\t}\n\treturn buf\n}\n","package runtime\n\n// This file implements compiler builtins for slices: append() and copy().\n\nimport (\n\t\"unsafe\"\n)\n\n// Builtin append(src, elements...) function: append elements to src and return\n// the modified (possibly expanded) slice.\nfunc sliceAppend(srcBuf, elemsBuf unsafe.Pointer, srcLen, srcCap, elemsLen uintptr, elemSize uintptr) (unsafe.Pointer, uintptr, uintptr) {\n\tif elemsLen == 0 {\n\t\t// Nothing to append, return the input slice.\n\t\treturn srcBuf, srcLen, srcCap\n\t}\n\n\tif srcLen+elemsLen > srcCap {\n\t\t// Slice does not fit, allocate a new buffer that's large enough.\n\t\tsrcCap = srcCap * 2\n\t\tif srcCap == 0 { // e.g. zero slice\n\t\t\tsrcCap = 1\n\t\t}\n\t\tfor srcLen+elemsLen > srcCap {\n\t\t\t// This algorithm may be made more memory-efficient: don't multiply\n\t\t\t// by two but by 1.5 or something. As far as I can see, that's\n\t\t\t// allowed by the Go language specification (but may be observed by\n\t\t\t// programs).\n\t\t\tsrcCap *= 2\n\t\t}\n\t\tbuf := alloc(srcCap*elemSize, nil)\n\n\t\t// Copy the old slice to the new slice.\n\t\tif srcLen != 0 {\n\t\t\tmemmove(buf, srcBuf, srcLen*elemSize)\n\t\t}\n\t\tsrcBuf = buf\n\t}\n\n\t// The slice fits (after possibly allocating a new one), append it in-place.\n\tmemmove(unsafe.Pointer(uintptr(srcBuf)+srcLen*elemSize), elemsBuf, elemsLen*elemSize)\n\treturn srcBuf, srcLen + elemsLen, srcCap\n}\n\n// Builtin copy(dst, src) function: copy bytes from dst to src.\nfunc sliceCopy(dst, src unsafe.Pointer, dstLen, srcLen uintptr, elemSize uintptr) int {\n\t// n = min(srcLen, dstLen)\n\tn := srcLen\n\tif n > dstLen {\n\t\tn = dstLen\n\t}\n\tmemmove(dst, src, n*elemSize)\n\treturn int(n)\n}\n","// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage time\n\nimport \"errors\"\n\n// These are predefined layouts for use in Time.Format and time.Parse.\n// The reference time used in these layouts is the specific time stamp:\n//\t01/02 03:04:05PM '06 -0700\n// (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).\n// That value is recorded as the constant named Layout, listed below. As a Unix\n// time, this is 1136239445. Since MST is GMT-0700, the reference would be\n// printed by the Unix date command as:\n//\tMon Jan 2 15:04:05 MST 2006\n// It is a regrettable historic error that the date uses the American convention\n// of putting the numerical month before the day.\n//\n// The example for Time.Format demonstrates the working of the layout string\n// in detail and is a good reference.\n//\n// Note that the RFC822, RFC850, and RFC1123 formats should be applied\n// only to local times. Applying them to UTC times will use \"UTC\" as the\n// time zone abbreviation, while strictly speaking those RFCs require the\n// use of \"GMT\" in that case.\n// In general RFC1123Z should be used instead of RFC1123 for servers\n// that insist on that format, and RFC3339 should be preferred for new protocols.\n// RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\n// when used with time.Parse they do not accept all the time formats\n// permitted by the RFCs and they do accept time formats not formally defined.\n// The RFC3339Nano format removes trailing zeros from the seconds field\n// and thus may not sort correctly once formatted.\n//\n// Most programs can use one of the defined constants as the layout passed to\n// Format or Parse. The rest of this comment can be ignored unless you are\n// creating a custom layout string.\n//\n// To define your own format, write down what the reference time would look like\n// formatted your way; see the values of constants like ANSIC, StampMicro or\n// Kitchen for examples. The model is to demonstrate what the reference time\n// looks like so that the Format and Parse methods can apply the same\n// transformation to a general time value.\n//\n// Here is a summary of the components of a layout string. Each element shows by\n// example the formatting of an element of the reference time. Only these values\n// are recognized. Text in the layout string that is not recognized as part of\n// the reference time is echoed verbatim during Format and expected to appear\n// verbatim in the input to Parse.\n//\n//\tYear: \"2006\" \"06\"\n//\tMonth: \"Jan\" \"January\"\n//\tTextual day of the week: \"Mon\" \"Monday\"\n//\tNumeric day of the month: \"2\" \"_2\" \"02\"\n//\tNumeric day of the year: \"__2\" \"002\"\n//\tHour: \"15\" \"3\" \"03\" (PM or AM)\n//\tMinute: \"4\" \"04\"\n//\tSecond: \"5\" \"05\"\n//\tAM/PM mark: \"PM\"\n//\n// Numeric time zone offsets format as follows:\n//\t\"-0700\"  \u00b1hhmm\n//\t\"-07:00\" \u00b1hh:mm\n//\t\"-07\"    \u00b1hh\n// Replacing the sign in the format with a Z triggers\n// the ISO 8601 behavior of printing Z instead of an\n// offset for the UTC zone. Thus:\n//\t\"Z0700\"  Z or \u00b1hhmm\n//\t\"Z07:00\" Z or \u00b1hh:mm\n//\t\"Z07\"    Z or \u00b1hh\n//\n// Within the format string, the underscores in \"_2\" and \"__2\" represent spaces\n// that may be replaced by digits if the following number has multiple digits,\n// for compatibility with fixed-width Unix time formats. A leading zero represents\n// a zero-padded value.\n//\n// The formats  and 002 are space-padded and zero-padded\n// three-character day of year; there is no unpadded day of year format.\n//\n// A comma or decimal point followed by one or more zeros represents\n// a fractional second, printed to the given number of decimal places.\n// A comma or decimal point followed by one or more nines represents\n// a fractional second, printed to the given number of decimal places, with\n// trailing zeros removed.\n// For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with\n// millisecond precision.\n//\n// Some valid layouts are invalid time values for time.Parse, due to formats\n// such as _ for space padding and Z for zone information.\n//\nconst (\n\tLayout      = \"01/02 03:04:05PM '06 -0700\" // The reference time, in numerical order.\n\tANSIC       = \"Mon Jan _2 15:04:05 2006\"\n\tUnixDate    = \"Mon Jan _2 15:04:05 MST 2006\"\n\tRubyDate    = \"Mon Jan 02 15:04:05 -0700 2006\"\n\tRFC822      = \"02 Jan 06 15:04 MST\"\n\tRFC822Z     = \"02 Jan 06 15:04 -0700\" // RFC822 with numeric zone\n\tRFC850      = \"Monday, 02-Jan-06 15:04:05 MST\"\n\tRFC1123     = \"Mon, 02 Jan 2006 15:04:05 MST\"\n\tRFC1123Z    = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n\tRFC3339     = \"2006-01-02T15:04:05Z07:00\"\n\tRFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"\n\tKitchen     = \"3:04PM\"\n\t// Handy time stamps.\n\tStamp      = \"Jan _2 15:04:05\"\n\tStampMilli = \"Jan _2 15:04:05.000\"\n\tStampMicro = \"Jan _2 15:04:05.000000\"\n\tStampNano  = \"Jan _2 15:04:05.000000000\"\n)\n\nconst (\n\t_                        = iota\n\tstdLongMonth             = iota + stdNeedDate  // \"January\"\n\tstdMonth                                       // \"Jan\"\n\tstdNumMonth                                    // \"1\"\n\tstdZeroMonth                                   // \"01\"\n\tstdLongWeekDay                                 // \"Monday\"\n\tstdWeekDay                                     // \"Mon\"\n\tstdDay                                         // \"2\"\n\tstdUnderDay                                    // \"_2\"\n\tstdZeroDay                                     // \"02\"\n\tstdUnderYearDay                                // \"__2\"\n\tstdZeroYearDay                                 // \"002\"\n\tstdHour                  = iota + stdNeedClock // \"15\"\n\tstdHour12                                      // \"3\"\n\tstdZeroHour12                                  // \"03\"\n\tstdMinute                                      // \"4\"\n\tstdZeroMinute                                  // \"04\"\n\tstdSecond                                      // \"5\"\n\tstdZeroSecond                                  // \"05\"\n\tstdLongYear              = iota + stdNeedDate  // \"2006\"\n\tstdYear                                        // \"06\"\n\tstdPM                    = iota + stdNeedClock // \"PM\"\n\tstdpm                                          // \"pm\"\n\tstdTZ                    = iota                // \"MST\"\n\tstdISO8601TZ                                   // \"Z0700\"  // prints Z for UTC\n\tstdISO8601SecondsTZ                            // \"Z070000\"\n\tstdISO8601ShortTZ                              // \"Z07\"\n\tstdISO8601ColonTZ                              // \"Z07:00\" // prints Z for UTC\n\tstdISO8601ColonSecondsTZ                       // \"Z07:00:00\"\n\tstdNumTZ                                       // \"-0700\"  // always numeric\n\tstdNumSecondsTz                                // \"-070000\"\n\tstdNumShortTZ                                  // \"-07\"    // always numeric\n\tstdNumColonTZ                                  // \"-07:00\" // always numeric\n\tstdNumColonSecondsTZ                           // \"-07:00:00\"\n\tstdFracSecond0                                 // \".0\", \".00\", ... , trailing zeros included\n\tstdFracSecond9                                 // \".9\", \".99\", ..., trailing zeros omitted\n\n\tstdNeedDate       = 1 << 8             // need month, day, year\n\tstdNeedClock      = 2 << 8             // need hour, minute, second\n\tstdArgShift       = 16                 // extra argument in high bits, above low stdArgShift\n\tstdSeparatorShift = 28                 // extra argument in high 4 bits for fractional second separators\n\tstdMask           = 1<<stdArgShift - 1 // mask out argument\n)\n\n// std0x records the std values for \"01\", \"02\", ..., \"06\".\nvar std0x = [...]int{stdZeroMonth, stdZeroDay, stdZeroHour12, stdZeroMinute, stdZeroSecond, stdYear}\n\n// startsWithLowerCase reports whether the string has a lower-case letter at the beginning.\n// Its purpose is to prevent matching strings like \"Month\" when looking for \"Mon\".\nfunc startsWithLowerCase(str string) bool {\n\tif len(str) == 0 {\n\t\treturn false\n\t}\n\tc := str[0]\n\treturn 'a' <= c && c <= 'z'\n}\n\n// nextStdChunk finds the first occurrence of a std string in\n// layout and returns the text before, the std string, and the text after.\nfunc nextStdChunk(layout string) (prefix string, std int, suffix string) {\n\tfor i := 0; i < len(layout); i++ {\n\t\tswitch c := int(layout[i]); c {\n\t\tcase 'J': // January, Jan\n\t\t\tif len(layout) >= i+3 && layout[i:i+3] == \"Jan\" {\n\t\t\t\tif len(layout) >= i+7 && layout[i:i+7] == \"January\" {\n\t\t\t\t\treturn layout[0:i], stdLongMonth, layout[i+7:]\n\t\t\t\t}\n\t\t\t\tif !startsWithLowerCase(layout[i+3:]) {\n\t\t\t\t\treturn layout[0:i], stdMonth, layout[i+3:]\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase 'M': // Monday, Mon, MST\n\t\t\tif len(layout) >= i+3 {\n\t\t\t\tif layout[i:i+3] == \"Mon\" {\n\t\t\t\t\tif len(layout) >= i+6 && layout[i:i+6] == \"Monday\" {\n\t\t\t\t\t\treturn layout[0:i], stdLongWeekDay, layout[i+6:]\n\t\t\t\t\t}\n\t\t\t\t\tif !startsWithLowerCase(layout[i+3:]) {\n\t\t\t\t\t\treturn layout[0:i], stdWeekDay, layout[i+3:]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif layout[i:i+3] == \"MST\" {\n\t\t\t\t\treturn layout[0:i], stdTZ, layout[i+3:]\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase '0': // 01, 02, 03, 04, 05, 06, 002\n\t\t\tif len(layout) >= i+2 && '1' <= layout[i+1] && layout[i+1] <= '6' {\n\t\t\t\treturn layout[0:i], std0x[layout[i+1]-'1'], layout[i+2:]\n\t\t\t}\n\t\t\tif len(layout) >= i+3 && layout[i+1] == '0' && layout[i+2] == '2' {\n\t\t\t\treturn layout[0:i], stdZeroYearDay, layout[i+3:]\n\t\t\t}\n\n\t\tcase '1': // 15, 1\n\t\t\tif len(layout) >= i+2 && layout[i+1] == '5' {\n\t\t\t\treturn layout[0:i], stdHour, layout[i+2:]\n\t\t\t}\n\t\t\treturn layout[0:i], stdNumMonth, layout[i+1:]\n\n\t\tcase '2': // 2006, 2\n\t\t\tif len(layout) >= i+4 && layout[i:i+4] == \"2006\" {\n\t\t\t\treturn layout[0:i], stdLongYear, layout[i+4:]\n\t\t\t}\n\t\t\treturn layout[0:i], stdDay, layout[i+1:]\n\n\t\tcase '_': // _2, _2006, __2\n\t\t\tif len(layout) >= i+2 && layout[i+1] == '2' {\n\t\t\t\t//_2006 is really a literal _, followed by stdLongYear\n\t\t\t\tif len(layout) >= i+5 && layout[i+1:i+5] == \"2006\" {\n\t\t\t\t\treturn layout[0 : i+1], stdLongYear, layout[i+5:]\n\t\t\t\t}\n\t\t\t\treturn layout[0:i], stdUnderDay, layout[i+2:]\n\t\t\t}\n\t\t\tif len(layout) >= i+3 && layout[i+1] == '_' && layout[i+2] == '2' {\n\t\t\t\treturn layout[0:i], stdUnderYearDay, layout[i+3:]\n\t\t\t}\n\n\t\tcase '3':\n\t\t\treturn layout[0:i], stdHour12, layout[i+1:]\n\n\t\tcase '4':\n\t\t\treturn layout[0:i], stdMinute, layout[i+1:]\n\n\t\tcase '5':\n\t\t\treturn layout[0:i], stdSecond, layout[i+1:]\n\n\t\tcase 'P': // PM\n\t\t\tif len(layout) >= i+2 && layout[i+1] == 'M' {\n\t\t\t\treturn layout[0:i], stdPM, layout[i+2:]\n\t\t\t}\n\n\t\tcase 'p': // pm\n\t\t\tif len(layout) >= i+2 && layout[i+1] == 'm' {\n\t\t\t\treturn layout[0:i], stdpm, layout[i+2:]\n\t\t\t}\n\n\t\tcase '-': // -070000, -07:00:00, -0700, -07:00, -07\n\t\t\tif len(layout) >= i+7 && layout[i:i+7] == \"-070000\" {\n\t\t\t\treturn layout[0:i], stdNumSecondsTz, layout[i+7:]\n\t\t\t}\n\t\t\tif len(layout) >= i+9 && layout[i:i+9] == \"-07:00:00\" {\n\t\t\t\treturn layout[0:i], stdNumColonSecondsTZ, layout[i+9:]\n\t\t\t}\n\t\t\tif len(layout) >= i+5 && layout[i:i+5] == \"-0700\" {\n\t\t\t\treturn layout[0:i], stdNumTZ, layout[i+5:]\n\t\t\t}\n\t\t\tif len(layout) >= i+6 && layout[i:i+6] == \"-07:00\" {\n\t\t\t\treturn layout[0:i], stdNumColonTZ, layout[i+6:]\n\t\t\t}\n\t\t\tif len(layout) >= i+3 && layout[i:i+3] == \"-07\" {\n\t\t\t\treturn layout[0:i], stdNumShortTZ, layout[i+3:]\n\t\t\t}\n\n\t\tcase 'Z': // Z070000, Z07:00:00, Z0700, Z07:00,\n\t\t\tif len(layout) >= i+7 && layout[i:i+7] == \"Z070000\" {\n\t\t\t\treturn layout[0:i], stdISO8601SecondsTZ, layout[i+7:]\n\t\t\t}\n\t\t\tif len(layout) >= i+9 && layout[i:i+9] == \"Z07:00:00\" {\n\t\t\t\treturn layout[0:i], stdISO8601ColonSecondsTZ, layout[i+9:]\n\t\t\t}\n\t\t\tif len(layout) >= i+5 && layout[i:i+5] == \"Z0700\" {\n\t\t\t\treturn layout[0:i], stdISO8601TZ, layout[i+5:]\n\t\t\t}\n\t\t\tif len(layout) >= i+6 && layout[i:i+6] == \"Z07:00\" {\n\t\t\t\treturn layout[0:i], stdISO8601ColonTZ, layout[i+6:]\n\t\t\t}\n\t\t\tif len(layout) >= i+3 && layout[i:i+3] == \"Z07\" {\n\t\t\t\treturn layout[0:i], stdISO8601ShortTZ, layout[i+3:]\n\t\t\t}\n\n\t\tcase '.', ',': // ,000, or .000, or ,999, or .999 - repeated digits for fractional seconds.\n\t\t\tif i+1 < len(layout) && (layout[i+1] == '0' || layout[i+1] == '9') {\n\t\t\t\tch := layout[i+1]\n\t\t\t\tj := i + 1\n\t\t\t\tfor j < len(layout) && layout[j] == ch {\n\t\t\t\t\tj++\n\t\t\t\t}\n\t\t\t\t// String of digits must end here - only fractional second is all digits.\n\t\t\t\tif !isDigit(layout, j) {\n\t\t\t\t\tcode := stdFracSecond0\n\t\t\t\t\tif layout[i+1] == '9' {\n\t\t\t\t\t\tcode = stdFracSecond9\n\t\t\t\t\t}\n\t\t\t\t\tstd := stdFracSecond(code, j-(i+1), c)\n\t\t\t\t\treturn layout[0:i], std, layout[j:]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn layout, 0, \"\"\n}\n\nvar longDayNames = []string{\n\t\"Sunday\",\n\t\"Monday\",\n\t\"Tuesday\",\n\t\"Wednesday\",\n\t\"Thursday\",\n\t\"Friday\",\n\t\"Saturday\",\n}\n\nvar shortDayNames = []string{\n\t\"Sun\",\n\t\"Mon\",\n\t\"Tue\",\n\t\"Wed\",\n\t\"Thu\",\n\t\"Fri\",\n\t\"Sat\",\n}\n\nvar shortMonthNames = []string{\n\t\"Jan\",\n\t\"Feb\",\n\t\"Mar\",\n\t\"Apr\",\n\t\"May\",\n\t\"Jun\",\n\t\"Jul\",\n\t\"Aug\",\n\t\"Sep\",\n\t\"Oct\",\n\t\"Nov\",\n\t\"Dec\",\n}\n\nvar longMonthNames = []string{\n\t\"January\",\n\t\"February\",\n\t\"March\",\n\t\"April\",\n\t\"May\",\n\t\"June\",\n\t\"July\",\n\t\"August\",\n\t\"September\",\n\t\"October\",\n\t\"November\",\n\t\"December\",\n}\n\n// match reports whether s1 and s2 match ignoring case.\n// It is assumed s1 and s2 are the same length.\nfunc match(s1, s2 string) bool {\n\tfor i := 0; i < len(s1); i++ {\n\t\tc1 := s1[i]\n\t\tc2 := s2[i]\n\t\tif c1 != c2 {\n\t\t\t// Switch to lower-case; 'a'-'A' is known to be a single bit.\n\t\t\tc1 |= 'a' - 'A'\n\t\t\tc2 |= 'a' - 'A'\n\t\t\tif c1 != c2 || c1 < 'a' || c1 > 'z' {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\nfunc lookup(tab []string, val string) (int, string, error) {\n\tfor i, v := range tab {\n\t\tif len(val) >= len(v) && match(val[0:len(v)], v) {\n\t\t\treturn i, val[len(v):], nil\n\t\t}\n\t}\n\treturn -1, val, errBad\n}\n\n// appendInt appends the decimal form of x to b and returns the result.\n// If the decimal form (excluding sign) is shorter than width, the result is padded with leading 0's.\n// Duplicates functionality in strconv, but avoids dependency.\nfunc appendInt(b []byte, x int, width int) []byte {\n\tu := uint(x)\n\tif x < 0 {\n\t\tb = append(b, '-')\n\t\tu = uint(-x)\n\t}\n\n\t// Assemble decimal in reverse order.\n\tvar buf [20]byte\n\ti := len(buf)\n\tfor u >= 10 {\n\t\ti--\n\t\tq := u / 10\n\t\tbuf[i] = byte('0' + u - q*10)\n\t\tu = q\n\t}\n\ti--\n\tbuf[i] = byte('0' + u)\n\n\t// Add 0-padding.\n\tfor w := len(buf) - i; w < width; w++ {\n\t\tb = append(b, '0')\n\t}\n\n\treturn append(b, buf[i:]...)\n}\n\n// Never printed, just needs to be non-nil for return by atoi.\nvar atoiError = errors.New(\"time: invalid number\")\n\n// Duplicates functionality in strconv, but avoids dependency.\nfunc atoi(s string) (x int, err error) {\n\tneg := false\n\tif s != \"\" && (s[0] == '-' || s[0] == '+') {\n\t\tneg = s[0] == '-'\n\t\ts = s[1:]\n\t}\n\tq, rem, err := leadingInt(s)\n\tx = int(q)\n\tif err != nil || rem != \"\" {\n\t\treturn 0, atoiError\n\t}\n\tif neg {\n\t\tx = -x\n\t}\n\treturn x, nil\n}\n\n// The \"std\" value passed to formatNano contains two packed fields: the number of\n// digits after the decimal and the separator character (period or comma).\n// These functions pack and unpack that variable.\nfunc stdFracSecond(code, n, c int) int {\n\t// Use 0xfff to make the failure case even more absurd.\n\tif c == '.' {\n\t\treturn code | ((n & 0xfff) << stdArgShift)\n\t}\n\treturn code | ((n & 0xfff) << stdArgShift) | 1<<stdSeparatorShift\n}\n\nfunc digitsLen(std int) int {\n\treturn (std >> stdArgShift) & 0xfff\n}\n\nfunc separator(std int) byte {\n\tif (std >> stdSeparatorShift) == 0 {\n\t\treturn '.'\n\t}\n\treturn ','\n}\n\n// formatNano appends a fractional second, as nanoseconds, to b\n// and returns the result.\nfunc formatNano(b []byte, nanosec uint, std int) []byte {\n\tvar (\n\t\tn         = digitsLen(std)\n\t\tseparator = separator(std)\n\t\ttrim      = std&stdMask == stdFracSecond9\n\t)\n\tu := nanosec\n\tvar buf [9]byte\n\tfor start := len(buf); start > 0; {\n\t\tstart--\n\t\tbuf[start] = byte(u%10 + '0')\n\t\tu /= 10\n\t}\n\n\tif n > 9 {\n\t\tn = 9\n\t}\n\tif trim {\n\t\tfor n > 0 && buf[n-1] == '0' {\n\t\t\tn--\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn b\n\t\t}\n\t}\n\tb = append(b, separator)\n\treturn append(b, buf[:n]...)\n}\n\n// String returns the time formatted using the format string\n//\t\"2006-01-02 15:04:05.999999999 -0700 MST\"\n//\n// If the time has a monotonic clock reading, the returned string\n// includes a final field \"m=\u00b1<value>\", where value is the monotonic\n// clock reading formatted as a decimal number of seconds.\n//\n// The returned string is meant for debugging; for a stable serialized\n// representation, use t.MarshalText, t.MarshalBinary, or t.Format\n// with an explicit format string.\nfunc (t Time) String() string {\n\ts := t.Format(\"2006-01-02 15:04:05.999999999 -0700 MST\")\n\n\t// Format monotonic clock reading as m=\u00b1ddd.nnnnnnnnn.\n\tif t.wall&hasMonotonic != 0 {\n\t\tm2 := uint64(t.ext)\n\t\tsign := byte('+')\n\t\tif t.ext < 0 {\n\t\t\tsign = '-'\n\t\t\tm2 = -m2\n\t\t}\n\t\tm1, m2 := m2/1e9, m2%1e9\n\t\tm0, m1 := m1/1e9, m1%1e9\n\t\tvar buf []byte\n\t\tbuf = append(buf, \" m=\"...)\n\t\tbuf = append(buf, sign)\n\t\twid := 0\n\t\tif m0 != 0 {\n\t\t\tbuf = appendInt(buf, int(m0), 0)\n\t\t\twid = 9\n\t\t}\n\t\tbuf = appendInt(buf, int(m1), wid)\n\t\tbuf = append(buf, '.')\n\t\tbuf = appendInt(buf, int(m2), 9)\n\t\ts += string(buf)\n\t}\n\treturn s\n}\n\n// GoString implements fmt.GoStringer and formats t to be printed in Go source\n// code.\nfunc (t Time) GoString() string {\n\tbuf := []byte(\"time.Date(\")\n\tbuf = appendInt(buf, t.Year(), 0)\n\tmonth := t.Month()\n\tif January <= month && month <= December {\n\t\tbuf = append(buf, \", time.\"...)\n\t\tbuf = append(buf, t.Month().String()...)\n\t} else {\n\t\t// It's difficult to construct a time.Time with a date outside the\n\t\t// standard range but we might as well try to handle the case.\n\t\tbuf = appendInt(buf, int(month), 0)\n\t}\n\tbuf = append(buf, \", \"...)\n\tbuf = appendInt(buf, t.Day(), 0)\n\tbuf = append(buf, \", \"...)\n\tbuf = appendInt(buf, t.Hour(), 0)\n\tbuf = append(buf, \", \"...)\n\tbuf = appendInt(buf, t.Minute(), 0)\n\tbuf = append(buf, \", \"...)\n\tbuf = appendInt(buf, t.Second(), 0)\n\tbuf = append(buf, \", \"...)\n\tbuf = appendInt(buf, t.Nanosecond(), 0)\n\tbuf = append(buf, \", \"...)\n\tswitch loc := t.Location(); loc {\n\tcase UTC, nil:\n\t\tbuf = append(buf, \"time.UTC\"...)\n\tcase Local:\n\t\tbuf = append(buf, \"time.Local\"...)\n\tdefault:\n\t\t// there are several options for how we could display this, none of\n\t\t// which are great:\n\t\t//\n\t\t// - use Location(loc.name), which is not technically valid syntax\n\t\t// - use LoadLocation(loc.name), which will cause a syntax error when\n\t\t// embedded and also would require us to escape the string without\n\t\t// importing fmt or strconv\n\t\t// - try to use FixedZone, which would also require escaping the name\n\t\t// and would represent e.g. \"America/Los_Angeles\" daylight saving time\n\t\t// shifts inaccurately\n\t\t// - use the pointer format, which is no worse than you'd get with the\n\t\t// old fmt.Sprintf(\"%#v\", t) format.\n\t\t//\n\t\t// Of these, Location(loc.name) is the least disruptive. This is an edge\n\t\t// case we hope not to hit too often.\n\t\tbuf = append(buf, `time.Location(`...)\n\t\tbuf = append(buf, []byte(quote(loc.name))...)\n\t\tbuf = append(buf, `)`...)\n\t}\n\tbuf = append(buf, ')')\n\treturn string(buf)\n}\n\n// Format returns a textual representation of the time value formatted according\n// to the layout defined by the argument. See the documentation for the\n// constant called Layout to see how to represent the layout format.\n//\n// The executable example for Time.Format demonstrates the working\n// of the layout string in detail and is a good reference.\nfunc (t Time) Format(layout string) string {\n\tconst bufSize = 64\n\tvar b []byte\n\tmax := len(layout) + 10\n\tif max < bufSize {\n\t\tvar buf [bufSize]byte\n\t\tb = buf[:0]\n\t} else {\n\t\tb = make([]byte, 0, max)\n\t}\n\tb = t.AppendFormat(b, layout)\n\treturn string(b)\n}\n\n// AppendFormat is like Format but appends the textual\n// representation to b and returns the extended buffer.\nfunc (t Time) AppendFormat(b []byte, layout string) []byte {\n\tvar (\n\t\tname, offset, abs = t.locabs()\n\n\t\tyear  int = -1\n\t\tmonth Month\n\t\tday   int\n\t\tyday  int\n\t\thour  int = -1\n\t\tmin   int\n\t\tsec   int\n\t)\n\t// Each iteration generates one std value.\n\tfor layout != \"\" {\n\t\tprefix, std, suffix := nextStdChunk(layout)\n\t\tif prefix != \"\" {\n\t\t\tb = append(b, prefix...)\n\t\t}\n\t\tif std == 0 {\n\t\t\tbreak\n\t\t}\n\t\tlayout = suffix\n\n\t\t// Compute year, month, day if needed.\n\t\tif year < 0 && std&stdNeedDate != 0 {\n\t\t\tyear, month, day, yday = absDate(abs, true)\n\t\t\tyday++\n\t\t}\n\n\t\t// Compute hour, minute, second if needed.\n\t\tif hour < 0 && std&stdNeedClock != 0 {\n\t\t\thour, min, sec = absClock(abs)\n\t\t}\n\n\t\tswitch std & stdMask {\n\t\tcase stdYear:\n\t\t\ty := year\n\t\t\tif y < 0 {\n\t\t\t\ty = -y\n\t\t\t}\n\t\t\tb = appendInt(b, y%100, 2)\n\t\tcase stdLongYear:\n\t\t\tb = appendInt(b, year, 4)\n\t\tcase stdMonth:\n\t\t\tb = append(b, month.String()[:3]...)\n\t\tcase stdLongMonth:\n\t\t\tm := month.String()\n\t\t\tb = append(b, m...)\n\t\tcase stdNumMonth:\n\t\t\tb = appendInt(b, int(month), 0)\n\t\tcase stdZeroMonth:\n\t\t\tb = appendInt(b, int(month), 2)\n\t\tcase stdWeekDay:\n\t\t\tb = append(b, absWeekday(abs).String()[:3]...)\n\t\tcase stdLongWeekDay:\n\t\t\ts := absWeekday(abs).String()\n\t\t\tb = append(b, s...)\n\t\tcase stdDay:\n\t\t\tb = appendInt(b, day, 0)\n\t\tcase stdUnderDay:\n\t\t\tif day < 10 {\n\t\t\t\tb = append(b, ' ')\n\t\t\t}\n\t\t\tb = appendInt(b, day, 0)\n\t\tcase stdZeroDay:\n\t\t\tb = appendInt(b, day, 2)\n\t\tcase stdUnderYearDay:\n\t\t\tif yday < 100 {\n\t\t\t\tb = append(b, ' ')\n\t\t\t\tif yday < 10 {\n\t\t\t\t\tb = append(b, ' ')\n\t\t\t\t}\n\t\t\t}\n\t\t\tb = appendInt(b, yday, 0)\n\t\tcase stdZeroYearDay:\n\t\t\tb = appendInt(b, yday, 3)\n\t\tcase stdHour:\n\t\t\tb = appendInt(b, hour, 2)\n\t\tcase stdHour12:\n\t\t\t// Noon is 12PM, midnight is 12AM.\n\t\t\thr := hour % 12\n\t\t\tif hr == 0 {\n\t\t\t\thr = 12\n\t\t\t}\n\t\t\tb = appendInt(b, hr, 0)\n\t\tcase stdZeroHour12:\n\t\t\t// Noon is 12PM, midnight is 12AM.\n\t\t\thr := hour % 12\n\t\t\tif hr == 0 {\n\t\t\t\thr = 12\n\t\t\t}\n\t\t\tb = appendInt(b, hr, 2)\n\t\tcase stdMinute:\n\t\t\tb = appendInt(b, min, 0)\n\t\tcase stdZeroMinute:\n\t\t\tb = appendInt(b, min, 2)\n\t\tcase stdSecond:\n\t\t\tb = appendInt(b, sec, 0)\n\t\tcase stdZeroSecond:\n\t\t\tb = appendInt(b, sec, 2)\n\t\tcase stdPM:\n\t\t\tif hour >= 12 {\n\t\t\t\tb = append(b, \"PM\"...)\n\t\t\t} else {\n\t\t\t\tb = append(b, \"AM\"...)\n\t\t\t}\n\t\tcase stdpm:\n\t\t\tif hour >= 12 {\n\t\t\t\tb = append(b, \"pm\"...)\n\t\t\t} else {\n\t\t\t\tb = append(b, \"am\"...)\n\t\t\t}\n\t\tcase stdISO8601TZ, stdISO8601ColonTZ, stdISO8601SecondsTZ, stdISO8601ShortTZ, stdISO8601ColonSecondsTZ, stdNumTZ, stdNumColonTZ, stdNumSecondsTz, stdNumShortTZ, stdNumColonSecondsTZ:\n\t\t\t// Ugly special case. We cheat and take the \"Z\" variants\n\t\t\t// to mean \"the time zone as formatted for ISO 8601\".\n\t\t\tif offset == 0 && (std == stdISO8601TZ || std == stdISO8601ColonTZ || std == stdISO8601SecondsTZ || std == stdISO8601ShortTZ || std == stdISO8601ColonSecondsTZ) {\n\t\t\t\tb = append(b, 'Z')\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tzone := offset / 60 // convert to minutes\n\t\t\tabsoffset := offset\n\t\t\tif zone < 0 {\n\t\t\t\tb = append(b, '-')\n\t\t\t\tzone = -zone\n\t\t\t\tabsoffset = -absoffset\n\t\t\t} else {\n\t\t\t\tb = append(b, '+')\n\t\t\t}\n\t\t\tb = appendInt(b, zone/60, 2)\n\t\t\tif std == stdISO8601ColonTZ || std == stdNumColonTZ || std == stdISO8601ColonSecondsTZ || std == stdNumColonSecondsTZ {\n\t\t\t\tb = append(b, ':')\n\t\t\t}\n\t\t\tif std != stdNumShortTZ && std != stdISO8601ShortTZ {\n\t\t\t\tb = appendInt(b, zone%60, 2)\n\t\t\t}\n\n\t\t\t// append seconds if appropriate\n\t\t\tif std == stdISO8601SecondsTZ || std == stdNumSecondsTz || std == stdNumColonSecondsTZ || std == stdISO8601ColonSecondsTZ {\n\t\t\t\tif std == stdNumColonSecondsTZ || std == stdISO8601ColonSecondsTZ {\n\t\t\t\t\tb = append(b, ':')\n\t\t\t\t}\n\t\t\t\tb = appendInt(b, absoffset%60, 2)\n\t\t\t}\n\n\t\tcase stdTZ:\n\t\t\tif name != \"\" {\n\t\t\t\tb = append(b, name...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// No time zone known for this time, but we must print one.\n\t\t\t// Use the -0700 format.\n\t\t\tzone := offset / 60 // convert to minutes\n\t\t\tif zone < 0 {\n\t\t\t\tb = append(b, '-')\n\t\t\t\tzone = -zone\n\t\t\t} else {\n\t\t\t\tb = append(b, '+')\n\t\t\t}\n\t\t\tb = appendInt(b, zone/60, 2)\n\t\t\tb = appendInt(b, zone%60, 2)\n\t\tcase stdFracSecond0, stdFracSecond9:\n\t\t\tb = formatNano(b, uint(t.Nanosecond()), std)\n\t\t}\n\t}\n\treturn b\n}\n\nvar errBad = errors.New(\"bad value for field\") // placeholder not passed to user\n\n// ParseError describes a problem parsing a time string.\ntype ParseError struct {\n\tLayout     string\n\tValue      string\n\tLayoutElem string\n\tValueElem  string\n\tMessage    string\n}\n\n// These are borrowed from unicode/utf8 and strconv and replicate behavior in\n// that package, since we can't take a dependency on either.\nconst (\n\tlowerhex  = \"0123456789abcdef\"\n\truneSelf  = 0x80\n\truneError = '\\uFFFD'\n)\n\nfunc quote(s string) string {\n\tbuf := make([]byte, 1, len(s)+2) // slice will be at least len(s) + quotes\n\tbuf[0] = '\"'\n\tfor i, c := range s {\n\t\tif c >= runeSelf || c < ' ' {\n\t\t\t// This means you are asking us to parse a time.Duration or\n\t\t\t// time.Location with unprintable or non-ASCII characters in it.\n\t\t\t// We don't expect to hit this case very often. We could try to\n\t\t\t// reproduce strconv.Quote's behavior with full fidelity but\n\t\t\t// given how rarely we expect to hit these edge cases, speed and\n\t\t\t// conciseness are better.\n\t\t\tvar width int\n\t\t\tif c == runeError {\n\t\t\t\twidth = 1\n\t\t\t\tif i+2 < len(s) && s[i:i+3] == string(runeError) {\n\t\t\t\t\twidth = 3\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twidth = len(string(c))\n\t\t\t}\n\t\t\tfor j := 0; j < width; j++ {\n\t\t\t\tbuf = append(buf, `\\x`...)\n\t\t\t\tbuf = append(buf, lowerhex[s[i+j]>>4])\n\t\t\t\tbuf = append(buf, lowerhex[s[i+j]&0xF])\n\t\t\t}\n\t\t} else {\n\t\t\tif c == '\"' || c == '\\\\' {\n\t\t\t\tbuf = append(buf, '\\\\')\n\t\t\t}\n\t\t\tbuf = append(buf, string(c)...)\n\t\t}\n\t}\n\tbuf = append(buf, '\"')\n\treturn string(buf)\n}\n\n// Error returns the string representation of a ParseError.\nfunc (e *ParseError) Error() string {\n\tif e.Message == \"\" {\n\t\treturn \"parsing time \" +\n\t\t\tquote(e.Value) + \" as \" +\n\t\t\tquote(e.Layout) + \": cannot parse \" +\n\t\t\tquote(e.ValueElem) + \" as \" +\n\t\t\tquote(e.LayoutElem)\n\t}\n\treturn \"parsing time \" +\n\t\tquote(e.Value) + e.Message\n}\n\n// isDigit reports whether s[i] is in range and is a decimal digit.\nfunc isDigit(s string, i int) bool {\n\tif len(s) <= i {\n\t\treturn false\n\t}\n\tc := s[i]\n\treturn '0' <= c && c <= '9'\n}\n\n// getnum parses s[0:1] or s[0:2] (fixed forces s[0:2])\n// as a decimal integer and returns the integer and the\n// remainder of the string.\nfunc getnum(s string, fixed bool) (int, string, error) {\n\tif !isDigit(s, 0) {\n\t\treturn 0, s, errBad\n\t}\n\tif !isDigit(s, 1) {\n\t\tif fixed {\n\t\t\treturn 0, s, errBad\n\t\t}\n\t\treturn int(s[0] - '0'), s[1:], nil\n\t}\n\treturn int(s[0]-'0')*10 + int(s[1]-'0'), s[2:], nil\n}\n\n// getnum3 parses s[0:1], s[0:2], or s[0:3] (fixed forces s[0:3])\n// as a decimal integer and returns the integer and the remainder\n// of the string.\nfunc getnum3(s string, fixed bool) (int, string, error) {\n\tvar n, i int\n\tfor i = 0; i < 3 && isDigit(s, i); i++ {\n\t\tn = n*10 + int(s[i]-'0')\n\t}\n\tif i == 0 || fixed && i != 3 {\n\t\treturn 0, s, errBad\n\t}\n\treturn n, s[i:], nil\n}\n\nfunc cutspace(s string) string {\n\tfor len(s) > 0 && s[0] == ' ' {\n\t\ts = s[1:]\n\t}\n\treturn s\n}\n\n// skip removes the given prefix from value,\n// treating runs of space characters as equivalent.\nfunc skip(value, prefix string) (string, error) {\n\tfor len(prefix) > 0 {\n\t\tif prefix[0] == ' ' {\n\t\t\tif len(value) > 0 && value[0] != ' ' {\n\t\t\t\treturn value, errBad\n\t\t\t}\n\t\t\tprefix = cutspace(prefix)\n\t\t\tvalue = cutspace(value)\n\t\t\tcontinue\n\t\t}\n\t\tif len(value) == 0 || value[0] != prefix[0] {\n\t\t\treturn value, errBad\n\t\t}\n\t\tprefix = prefix[1:]\n\t\tvalue = value[1:]\n\t}\n\treturn value, nil\n}\n\n// Parse parses a formatted string and returns the time value it represents.\n// See the documentation for the constant called Layout to see how to\n// represent the format. The second argument must be parseable using\n// the format string (layout) provided as the first argument.\n//\n// The example for Time.Format demonstrates the working of the layout string\n// in detail and is a good reference.\n//\n// When parsing (only), the input may contain a fractional second\n// field immediately after the seconds field, even if the layout does not\n// signify its presence. In that case either a comma or a decimal point\n// followed by a maximal series of digits is parsed as a fractional second.\n//\n// Elements omitted from the layout are assumed to be zero or, when\n// zero is impossible, one, so parsing \"3:04pm\" returns the time\n// corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n// 0, this time is before the zero Time).\n// Years must be in the range 0000..9999. The day of the week is checked\n// for syntax but it is otherwise ignored.\n//\n// For layouts specifying the two-digit year 06, a value NN >= 69 will be treated\n// as 19NN and a value NN < 69 will be treated as 20NN.\n//\n// The remainder of this comment describes the handling of time zones.\n//\n// In the absence of a time zone indicator, Parse returns a time in UTC.\n//\n// When parsing a time with a zone offset like -0700, if the offset corresponds\n// to a time zone used by the current location (Local), then Parse uses that\n// location and zone in the returned time. Otherwise it records the time as\n// being in a fabricated location with time fixed at the given zone offset.\n//\n// When parsing a time with a zone abbreviation like MST, if the zone abbreviation\n// has a defined offset in the current location, then that offset is used.\n// The zone abbreviation \"UTC\" is recognized as UTC regardless of location.\n// If the zone abbreviation is unknown, Parse records the time as being\n// in a fabricated location with the given zone abbreviation and a zero offset.\n// This choice means that such a time can be parsed and reformatted with the\n// same layout losslessly, but the exact instant used in the representation will\n// differ by the actual zone offset. To avoid such problems, prefer time layouts\n// that use a numeric zone offset, or use ParseInLocation.\nfunc Parse(layout, value string) (Time, error) {\n\treturn parse(layout, value, UTC, Local)\n}\n\n// ParseInLocation is like Parse but differs in two important ways.\n// First, in the absence of time zone information, Parse interprets a time as UTC;\n// ParseInLocation interprets the time as in the given location.\n// Second, when given a zone offset or abbreviation, Parse tries to match it\n// against the Local location; ParseInLocation uses the given location.\nfunc ParseInLocation(layout, value string, loc *Location) (Time, error) {\n\treturn parse(layout, value, loc, loc)\n}\n\nfunc parse(layout, value string, defaultLocation, local *Location) (Time, error) {\n\talayout, avalue := layout, value\n\trangeErrString := \"\" // set if a value is out of range\n\tamSet := false       // do we need to subtract 12 from the hour for midnight?\n\tpmSet := false       // do we need to add 12 to the hour?\n\n\t// Time being constructed.\n\tvar (\n\t\tyear       int\n\t\tmonth      int = -1\n\t\tday        int = -1\n\t\tyday       int = -1\n\t\thour       int\n\t\tmin        int\n\t\tsec        int\n\t\tnsec       int\n\t\tz          *Location\n\t\tzoneOffset int = -1\n\t\tzoneName   string\n\t)\n\n\t// Each iteration processes one std value.\n\tfor {\n\t\tvar err error\n\t\tprefix, std, suffix := nextStdChunk(layout)\n\t\tstdstr := layout[len(prefix) : len(layout)-len(suffix)]\n\t\tvalue, err = skip(value, prefix)\n\t\tif err != nil {\n\t\t\treturn Time{}, &ParseError{alayout, avalue, prefix, value, \"\"}\n\t\t}\n\t\tif std == 0 {\n\t\t\tif len(value) != 0 {\n\t\t\t\treturn Time{}, &ParseError{alayout, avalue, \"\", value, \": extra text: \" + quote(value)}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tlayout = suffix\n\t\tvar p string\n\t\tswitch std & stdMask {\n\t\tcase stdYear:\n\t\t\tif len(value) < 2 {\n\t\t\t\terr = errBad\n\t\t\t\tbreak\n\t\t\t}\n\t\t\thold := value\n\t\t\tp, value = value[0:2], value[2:]\n\t\t\tyear, err = atoi(p)\n\t\t\tif err != nil {\n\t\t\t\tvalue = hold\n\t\t\t} else if year >= 69 { // Unix time starts Dec 31 1969 in some time zones\n\t\t\t\tyear += 1900\n\t\t\t} else {\n\t\t\t\tyear += 2000\n\t\t\t}\n\t\tcase stdLongYear:\n\t\t\tif len(value) < 4 || !isDigit(value, 0) {\n\t\t\t\terr = errBad\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp, value = value[0:4], value[4:]\n\t\t\tyear, err = atoi(p)\n\t\tcase stdMonth:\n\t\t\tmonth, value, err = lookup(shortMonthNames, value)\n\t\t\tmonth++\n\t\tcase stdLongMonth:\n\t\t\tmonth, value, err = lookup(longMonthNames, value)\n\t\t\tmonth++\n\t\tcase stdNumMonth, stdZeroMonth:\n\t\t\tmonth, value, err = getnum(value, std == stdZeroMonth)\n\t\t\tif err == nil && (month <= 0 || 12 < month) {\n\t\t\t\trangeErrString = \"month\"\n\t\t\t}\n\t\tcase stdWeekDay:\n\t\t\t// Ignore weekday except for error checking.\n\t\t\t_, value, err = lookup(shortDayNames, value)\n\t\tcase stdLongWeekDay:\n\t\t\t_, value, err = lookup(longDayNames, value)\n\t\tcase stdDay, stdUnderDay, stdZeroDay:\n\t\t\tif std == stdUnderDay && len(value) > 0 && value[0] == ' ' {\n\t\t\t\tvalue = value[1:]\n\t\t\t}\n\t\t\tday, value, err = getnum(value, std == stdZeroDay)\n\t\t\t// Note that we allow any one- or two-digit day here.\n\t\t\t// The month, day, year combination is validated after we've completed parsing.\n\t\tcase stdUnderYearDay, stdZeroYearDay:\n\t\t\tfor i := 0; i < 2; i++ {\n\t\t\t\tif std == stdUnderYearDay && len(value) > 0 && value[0] == ' ' {\n\t\t\t\t\tvalue = value[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t\tyday, value, err = getnum3(value, std == stdZeroYearDay)\n\t\t\t// Note that we allow any one-, two-, or three-digit year-day here.\n\t\t\t// The year-day, year combination is validated after we've completed parsing.\n\t\tcase stdHour:\n\t\t\thour, value, err = getnum(value, false)\n\t\t\tif hour < 0 || 24 <= hour {\n\t\t\t\trangeErrString = \"hour\"\n\t\t\t}\n\t\tcase stdHour12, stdZeroHour12:\n\t\t\thour, value, err = getnum(value, std == stdZeroHour12)\n\t\t\tif hour < 0 || 12 < hour {\n\t\t\t\trangeErrString = \"hour\"\n\t\t\t}\n\t\tcase stdMinute, stdZeroMinute:\n\t\t\tmin, value, err = getnum(value, std == stdZeroMinute)\n\t\t\tif min < 0 || 60 <= min {\n\t\t\t\trangeErrString = \"minute\"\n\t\t\t}\n\t\tcase stdSecond, stdZeroSecond:\n\t\t\tsec, value, err = getnum(value, std == stdZeroSecond)\n\t\t\tif sec < 0 || 60 <= sec {\n\t\t\t\trangeErrString = \"second\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Special case: do we have a fractional second but no\n\t\t\t// fractional second in the format?\n\t\t\tif len(value) >= 2 && commaOrPeriod(value[0]) && isDigit(value, 1) {\n\t\t\t\t_, std, _ = nextStdChunk(layout)\n\t\t\t\tstd &= stdMask\n\t\t\t\tif std == stdFracSecond0 || std == stdFracSecond9 {\n\t\t\t\t\t// Fractional second in the layout; proceed normally\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t// No fractional second in the layout but we have one in the input.\n\t\t\t\tn := 2\n\t\t\t\tfor ; n < len(value) && isDigit(value, n); n++ {\n\t\t\t\t}\n\t\t\t\tnsec, rangeErrString, err = parseNanoseconds(value, n)\n\t\t\t\tvalue = value[n:]\n\t\t\t}\n\t\tcase stdPM:\n\t\t\tif len(value) < 2 {\n\t\t\t\terr = errBad\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp, value = value[0:2], value[2:]\n\t\t\tswitch p {\n\t\t\tcase \"PM\":\n\t\t\t\tpmSet = true\n\t\t\tcase \"AM\":\n\t\t\t\tamSet = true\n\t\t\tdefault:\n\t\t\t\terr = errBad\n\t\t\t}\n\t\tcase stdpm:\n\t\t\tif len(value) < 2 {\n\t\t\t\terr = errBad\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp, value = value[0:2], value[2:]\n\t\t\tswitch p {\n\t\t\tcase \"pm\":\n\t\t\t\tpmSet = true\n\t\t\tcase \"am\":\n\t\t\t\tamSet = true\n\t\t\tdefault:\n\t\t\t\terr = errBad\n\t\t\t}\n\t\tcase stdISO8601TZ, stdISO8601ColonTZ, stdISO8601SecondsTZ, stdISO8601ShortTZ, stdISO8601ColonSecondsTZ, stdNumTZ, stdNumShortTZ, stdNumColonTZ, stdNumSecondsTz, stdNumColonSecondsTZ:\n\t\t\tif (std == stdISO8601TZ || std == stdISO8601ShortTZ || std == stdISO8601ColonTZ) && len(value) >= 1 && value[0] == 'Z' {\n\t\t\t\tvalue = value[1:]\n\t\t\t\tz = UTC\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tvar sign, hour, min, seconds string\n\t\t\tif std == stdISO8601ColonTZ || std == stdNumColonTZ {\n\t\t\t\tif len(value) < 6 {\n\t\t\t\t\terr = errBad\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif value[3] != ':' {\n\t\t\t\t\terr = errBad\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsign, hour, min, seconds, value = value[0:1], value[1:3], value[4:6], \"00\", value[6:]\n\t\t\t} else if std == stdNumShortTZ || std == stdISO8601ShortTZ {\n\t\t\t\tif len(value) < 3 {\n\t\t\t\t\terr = errBad\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsign, hour, min, seconds, value = value[0:1], value[1:3], \"00\", \"00\", value[3:]\n\t\t\t} else if std == stdISO8601ColonSecondsTZ || std == stdNumColonSecondsTZ {\n\t\t\t\tif len(value) < 9 {\n\t\t\t\t\terr = errBad\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif value[3] != ':' || value[6] != ':' {\n\t\t\t\t\terr = errBad\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsign, hour, min, seconds, value = value[0:1], value[1:3], value[4:6], value[7:9], value[9:]\n\t\t\t} else if std == stdISO8601SecondsTZ || std == stdNumSecondsTz {\n\t\t\t\tif len(value) < 7 {\n\t\t\t\t\terr = errBad\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsign, hour, min, seconds, value = value[0:1], value[1:3], value[3:5], value[5:7], value[7:]\n\t\t\t} else {\n\t\t\t\tif len(value) < 5 {\n\t\t\t\t\terr = errBad\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsign, hour, min, seconds, value = value[0:1], value[1:3], value[3:5], \"00\", value[5:]\n\t\t\t}\n\t\t\tvar hr, mm, ss int\n\t\t\thr, err = atoi(hour)\n\t\t\tif err == nil {\n\t\t\t\tmm, err = atoi(min)\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tss, err = atoi(seconds)\n\t\t\t}\n\t\t\tzoneOffset = (hr*60+mm)*60 + ss // offset is in seconds\n\t\t\tswitch sign[0] {\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\t\tzoneOffset = -zoneOffset\n\t\t\tdefault:\n\t\t\t\terr = errBad\n\t\t\t}\n\t\tcase stdTZ:\n\t\t\t// Does it look like a time zone?\n\t\t\tif len(value) >= 3 && value[0:3] == \"UTC\" {\n\t\t\t\tz = UTC\n\t\t\t\tvalue = value[3:]\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tn, ok := parseTimeZone(value)\n\t\t\tif !ok {\n\t\t\t\terr = errBad\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tzoneName, value = value[:n], value[n:]\n\n\t\tcase stdFracSecond0:\n\t\t\t// stdFracSecond0 requires the exact number of digits as specified in\n\t\t\t// the layout.\n\t\t\tndigit := 1 + digitsLen(std)\n\t\t\tif len(value) < ndigit {\n\t\t\t\terr = errBad\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnsec, rangeErrString, err = parseNanoseconds(value, ndigit)\n\t\t\tvalue = value[ndigit:]\n\n\t\tcase stdFracSecond9:\n\t\t\tif len(value) < 2 || !commaOrPeriod(value[0]) || value[1] < '0' || '9' < value[1] {\n\t\t\t\t// Fractional second omitted.\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Take any number of digits, even more than asked for,\n\t\t\t// because it is what the stdSecond case would do.\n\t\t\ti := 0\n\t\t\tfor i < 9 && i+1 < len(value) && '0' <= value[i+1] && value[i+1] <= '9' {\n\t\t\t\ti++\n\t\t\t}\n\t\t\tnsec, rangeErrString, err = parseNanoseconds(value, 1+i)\n\t\t\tvalue = value[1+i:]\n\t\t}\n\t\tif rangeErrString != \"\" {\n\t\t\treturn Time{}, &ParseError{alayout, avalue, stdstr, value, \": \" + rangeErrString + \" out of range\"}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn Time{}, &ParseError{alayout, avalue, stdstr, value, \"\"}\n\t\t}\n\t}\n\tif pmSet && hour < 12 {\n\t\thour += 12\n\t} else if amSet && hour == 12 {\n\t\thour = 0\n\t}\n\n\t// Convert yday to day, month.\n\tif yday >= 0 {\n\t\tvar d int\n\t\tvar m int\n\t\tif isLeap(year) {\n\t\t\tif yday == 31+29 {\n\t\t\t\tm = int(February)\n\t\t\t\td = 29\n\t\t\t} else if yday > 31+29 {\n\t\t\t\tyday--\n\t\t\t}\n\t\t}\n\t\tif yday < 1 || yday > 365 {\n\t\t\treturn Time{}, &ParseError{alayout, avalue, \"\", value, \": day-of-year out of range\"}\n\t\t}\n\t\tif m == 0 {\n\t\t\tm = (yday-1)/31 + 1\n\t\t\tif int(daysBefore[m]) < yday {\n\t\t\t\tm++\n\t\t\t}\n\t\t\td = yday - int(daysBefore[m-1])\n\t\t}\n\t\t// If month, day already seen, yday's m, d must match.\n\t\t// Otherwise, set them from m, d.\n\t\tif month >= 0 && month != m {\n\t\t\treturn Time{}, &ParseError{alayout, avalue, \"\", value, \": day-of-year does not match month\"}\n\t\t}\n\t\tmonth = m\n\t\tif day >= 0 && day != d {\n\t\t\treturn Time{}, &ParseError{alayout, avalue, \"\", value, \": day-of-year does not match day\"}\n\t\t}\n\t\tday = d\n\t} else {\n\t\tif month < 0 {\n\t\t\tmonth = int(January)\n\t\t}\n\t\tif day < 0 {\n\t\t\tday = 1\n\t\t}\n\t}\n\n\t// Validate the day of the month.\n\tif day < 1 || day > daysIn(Month(month), year) {\n\t\treturn Time{}, &ParseError{alayout, avalue, \"\", value, \": day out of range\"}\n\t}\n\n\tif z != nil {\n\t\treturn Date(year, Month(month), day, hour, min, sec, nsec, z), nil\n\t}\n\n\tif zoneOffset != -1 {\n\t\tt := Date(year, Month(month), day, hour, min, sec, nsec, UTC)\n\t\tt.addSec(-int64(zoneOffset))\n\n\t\t// Look for local zone with the given offset.\n\t\t// If that zone was in effect at the given time, use it.\n\t\tname, offset, _, _, _ := local.lookup(t.unixSec())\n\t\tif offset == zoneOffset && (zoneName == \"\" || name == zoneName) {\n\t\t\tt.setLoc(local)\n\t\t\treturn t, nil\n\t\t}\n\n\t\t// Otherwise create fake zone to record offset.\n\t\tt.setLoc(FixedZone(zoneName, zoneOffset))\n\t\treturn t, nil\n\t}\n\n\tif zoneName != \"\" {\n\t\tt := Date(year, Month(month), day, hour, min, sec, nsec, UTC)\n\t\t// Look for local zone with the given offset.\n\t\t// If that zone was in effect at the given time, use it.\n\t\toffset, ok := local.lookupName(zoneName, t.unixSec())\n\t\tif ok {\n\t\t\tt.addSec(-int64(offset))\n\t\t\tt.setLoc(local)\n\t\t\treturn t, nil\n\t\t}\n\n\t\t// Otherwise, create fake zone with unknown offset.\n\t\tif len(zoneName) > 3 && zoneName[:3] == \"GMT\" {\n\t\t\toffset, _ = atoi(zoneName[3:]) // Guaranteed OK by parseGMT.\n\t\t\toffset *= 3600\n\t\t}\n\t\tt.setLoc(FixedZone(zoneName, offset))\n\t\treturn t, nil\n\t}\n\n\t// Otherwise, fall back to default.\n\treturn Date(year, Month(month), day, hour, min, sec, nsec, defaultLocation), nil\n}\n\n// parseTimeZone parses a time zone string and returns its length. Time zones\n// are human-generated and unpredictable. We can't do precise error checking.\n// On the other hand, for a correct parse there must be a time zone at the\n// beginning of the string, so it's almost always true that there's one\n// there. We look at the beginning of the string for a run of upper-case letters.\n// If there are more than 5, it's an error.\n// If there are 4 or 5 and the last is a T, it's a time zone.\n// If there are 3, it's a time zone.\n// Otherwise, other than special cases, it's not a time zone.\n// GMT is special because it can have an hour offset.\nfunc parseTimeZone(value string) (length int, ok bool) {\n\tif len(value) < 3 {\n\t\treturn 0, false\n\t}\n\t// Special case 1: ChST and MeST are the only zones with a lower-case letter.\n\tif len(value) >= 4 && (value[:4] == \"ChST\" || value[:4] == \"MeST\") {\n\t\treturn 4, true\n\t}\n\t// Special case 2: GMT may have an hour offset; treat it specially.\n\tif value[:3] == \"GMT\" {\n\t\tlength = parseGMT(value)\n\t\treturn length, true\n\t}\n\t// Special Case 3: Some time zones are not named, but have +/-00 format\n\tif value[0] == '+' || value[0] == '-' {\n\t\tlength = parseSignedOffset(value)\n\t\tok := length > 0 // parseSignedOffset returns 0 in case of bad input\n\t\treturn length, ok\n\t}\n\t// How many upper-case letters are there? Need at least three, at most five.\n\tvar nUpper int\n\tfor nUpper = 0; nUpper < 6; nUpper++ {\n\t\tif nUpper >= len(value) {\n\t\t\tbreak\n\t\t}\n\t\tif c := value[nUpper]; c < 'A' || 'Z' < c {\n\t\t\tbreak\n\t\t}\n\t}\n\tswitch nUpper {\n\tcase 0, 1, 2, 6:\n\t\treturn 0, false\n\tcase 5: // Must end in T to match.\n\t\tif value[4] == 'T' {\n\t\t\treturn 5, true\n\t\t}\n\tcase 4:\n\t\t// Must end in T, except one special case.\n\t\tif value[3] == 'T' || value[:4] == \"WITA\" {\n\t\t\treturn 4, true\n\t\t}\n\tcase 3:\n\t\treturn 3, true\n\t}\n\treturn 0, false\n}\n\n// parseGMT parses a GMT time zone. The input string is known to start \"GMT\".\n// The function checks whether that is followed by a sign and a number in the\n// range -23 through +23 excluding zero.\nfunc parseGMT(value string) int {\n\tvalue = value[3:]\n\tif len(value) == 0 {\n\t\treturn 3\n\t}\n\n\treturn 3 + parseSignedOffset(value)\n}\n\n// parseSignedOffset parses a signed timezone offset (e.g. \"+03\" or \"-04\").\n// The function checks for a signed number in the range -23 through +23 excluding zero.\n// Returns length of the found offset string or 0 otherwise\nfunc parseSignedOffset(value string) int {\n\tsign := value[0]\n\tif sign != '-' && sign != '+' {\n\t\treturn 0\n\t}\n\tx, rem, err := leadingInt(value[1:])\n\n\t// fail if nothing consumed by leadingInt\n\tif err != nil || value[1:] == rem {\n\t\treturn 0\n\t}\n\tif sign == '-' {\n\t\tx = -x\n\t}\n\tif x < -23 || 23 < x {\n\t\treturn 0\n\t}\n\treturn len(value) - len(rem)\n}\n\nfunc commaOrPeriod(b byte) bool {\n\treturn b == '.' || b == ','\n}\n\nfunc parseNanoseconds(value string, nbytes int) (ns int, rangeErrString string, err error) {\n\tif !commaOrPeriod(value[0]) {\n\t\terr = errBad\n\t\treturn\n\t}\n\tif ns, err = atoi(value[1:nbytes]); err != nil {\n\t\treturn\n\t}\n\tif ns < 0 || 1e9 <= ns {\n\t\trangeErrString = \"fractional second\"\n\t\treturn\n\t}\n\t// We need nanoseconds, which means scaling by the number\n\t// of missing digits in the format, maximum length 10. If it's\n\t// longer than 10, we won't scale.\n\tscaleDigits := 10 - nbytes\n\tfor i := 0; i < scaleDigits; i++ {\n\t\tns *= 10\n\t}\n\treturn\n}\n\nvar errLeadingInt = errors.New(\"time: bad [0-9]*\") // never printed\n\n// leadingInt consumes the leading [0-9]* from s.\nfunc leadingInt(s string) (x int64, rem string, err error) {\n\ti := 0\n\tfor ; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c < '0' || c > '9' {\n\t\t\tbreak\n\t\t}\n\t\tif x > (1<<63-1)/10 {\n\t\t\t// overflow\n\t\t\treturn 0, \"\", errLeadingInt\n\t\t}\n\t\tx = x*10 + int64(c) - '0'\n\t\tif x < 0 {\n\t\t\t// overflow\n\t\t\treturn 0, \"\", errLeadingInt\n\t\t}\n\t}\n\treturn x, s[i:], nil\n}\n\n// leadingFraction consumes the leading [0-9]* from s.\n// It is used only for fractions, so does not return an error on overflow,\n// it just stops accumulating precision.\nfunc leadingFraction(s string) (x int64, scale float64, rem string) {\n\ti := 0\n\tscale = 1\n\toverflow := false\n\tfor ; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c < '0' || c > '9' {\n\t\t\tbreak\n\t\t}\n\t\tif overflow {\n\t\t\tcontinue\n\t\t}\n\t\tif x > (1<<63-1)/10 {\n\t\t\t// It's possible for overflow to give a positive number, so take care.\n\t\t\toverflow = true\n\t\t\tcontinue\n\t\t}\n\t\ty := x*10 + int64(c) - '0'\n\t\tif y < 0 {\n\t\t\toverflow = true\n\t\t\tcontinue\n\t\t}\n\t\tx = y\n\t\tscale *= 10\n\t}\n\treturn x, scale, s[i:]\n}\n\nvar unitMap = map[string]int64{\n\t\"ns\": int64(Nanosecond),\n\t\"us\": int64(Microsecond),\n\t\"\u00b5s\": int64(Microsecond), // U+00B5 = micro symbol\n\t\"\u03bcs\": int64(Microsecond), // U+03BC = Greek letter mu\n\t\"ms\": int64(Millisecond),\n\t\"s\":  int64(Second),\n\t\"m\":  int64(Minute),\n\t\"h\":  int64(Hour),\n}\n\n// ParseDuration parses a duration string.\n// A duration string is a possibly signed sequence of\n// decimal numbers, each with optional fraction and a unit suffix,\n// such as \"300ms\", \"-1.5h\" or \"2h45m\".\n// Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\", \"h\".\nfunc ParseDuration(s string) (Duration, error) {\n\t// [-+]?([0-9]*(\\.[0-9]*)?[a-z]+)+\n\torig := s\n\tvar d int64\n\tneg := false\n\n\t// Consume [-+]?\n\tif s != \"\" {\n\t\tc := s[0]\n\t\tif c == '-' || c == '+' {\n\t\t\tneg = c == '-'\n\t\t\ts = s[1:]\n\t\t}\n\t}\n\t// Special case: if all that is left is \"0\", this is zero.\n\tif s == \"0\" {\n\t\treturn 0, nil\n\t}\n\tif s == \"\" {\n\t\treturn 0, errors.New(\"time: invalid duration \" + quote(orig))\n\t}\n\tfor s != \"\" {\n\t\tvar (\n\t\t\tv, f  int64       // integers before, after decimal point\n\t\t\tscale float64 = 1 // value = v + f/scale\n\t\t)\n\n\t\tvar err error\n\n\t\t// The next character must be [0-9.]\n\t\tif !(s[0] == '.' || '0' <= s[0] && s[0] <= '9') {\n\t\t\treturn 0, errors.New(\"time: invalid duration \" + quote(orig))\n\t\t}\n\t\t// Consume [0-9]*\n\t\tpl := len(s)\n\t\tv, s, err = leadingInt(s)\n\t\tif err != nil {\n\t\t\treturn 0, errors.New(\"time: invalid duration \" + quote(orig))\n\t\t}\n\t\tpre := pl != len(s) // whether we consumed anything before a period\n\n\t\t// Consume (\\.[0-9]*)?\n\t\tpost := false\n\t\tif s != \"\" && s[0] == '.' {\n\t\t\ts = s[1:]\n\t\t\tpl := len(s)\n\t\t\tf, scale, s = leadingFraction(s)\n\t\t\tpost = pl != len(s)\n\t\t}\n\t\tif !pre && !post {\n\t\t\t// no digits (e.g. \".s\" or \"-.s\")\n\t\t\treturn 0, errors.New(\"time: invalid duration \" + quote(orig))\n\t\t}\n\n\t\t// Consume unit.\n\t\ti := 0\n\t\tfor ; i < len(s); i++ {\n\t\t\tc := s[i]\n\t\t\tif c == '.' || '0' <= c && c <= '9' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif i == 0 {\n\t\t\treturn 0, errors.New(\"time: missing unit in duration \" + quote(orig))\n\t\t}\n\t\tu := s[:i]\n\t\ts = s[i:]\n\t\tunit, ok := unitMap[u]\n\t\tif !ok {\n\t\t\treturn 0, errors.New(\"time: unknown unit \" + quote(u) + \" in duration \" + quote(orig))\n\t\t}\n\t\tif v > (1<<63-1)/unit {\n\t\t\t// overflow\n\t\t\treturn 0, errors.New(\"time: invalid duration \" + quote(orig))\n\t\t}\n\t\tv *= unit\n\t\tif f > 0 {\n\t\t\t// float64 is needed to be nanosecond accurate for fractions of hours.\n\t\t\t// v >= 0 && (f*unit/scale) <= 3.6e+12 (ns/h, h is the largest unit)\n\t\t\tv += int64(float64(f) * (float64(unit) / scale))\n\t\t\tif v < 0 {\n\t\t\t\t// overflow\n\t\t\t\treturn 0, errors.New(\"time: invalid duration \" + quote(orig))\n\t\t\t}\n\t\t}\n\t\td += v\n\t\tif d < 0 {\n\t\t\t// overflow\n\t\t\treturn 0, errors.New(\"time: invalid duration \" + quote(orig))\n\t\t}\n\t}\n\n\tif neg {\n\t\td = -d\n\t}\n\treturn Duration(d), nil\n}\n","// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build js,wasm\n\n// Package js gives access to the WebAssembly host environment when using the js/wasm architecture.\n// Its API is based on JavaScript semantics.\n//\n// This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a\n// comprehensive API for users. It is exempt from the Go compatibility promise.\npackage js\n\nimport (\n\t\"runtime\"\n\t\"unsafe\"\n)\n\n// ref is used to identify a JavaScript value, since the value itself can not be passed to WebAssembly.\n//\n// The JavaScript value \"undefined\" is represented by the value 0.\n// A JavaScript number (64-bit float, except 0 and NaN) is represented by its IEEE 754 binary representation.\n// All other values are represented as an IEEE 754 binary representation of NaN with bits 0-31 used as\n// an ID and bits 32-34 used to differentiate between string, symbol, function and object.\ntype ref uint64\n\n// nanHead are the upper 32 bits of a ref which are set if the value is not encoded as an IEEE 754 number (see above).\nconst nanHead = 0x7FF80000\n\n// Wrapper is implemented by types that are backed by a JavaScript value.\ntype Wrapper interface {\n\t// JSValue returns a JavaScript value associated with an object.\n\tJSValue() Value\n}\n\n// Value represents a JavaScript value. The zero value is the JavaScript value \"undefined\".\n// Values can be checked for equality with the Equal method.\ntype Value struct {\n\t_     [0]func() // uncomparable; to make == not compile\n\tref   ref       // identifies a JavaScript value, see ref type\n\tgcPtr *ref      // used to trigger the finalizer when the Value is not referenced any more\n}\n\nconst (\n\t// the type flags need to be in sync with wasm_exec.js\n\ttypeFlagNone = iota\n\ttypeFlagObject\n\ttypeFlagString\n\ttypeFlagSymbol\n\ttypeFlagFunction\n)\n\n// JSValue implements Wrapper interface.\nfunc (v Value) JSValue() Value {\n\treturn v\n}\n\nfunc makeValue(r ref) Value {\n\tvar gcPtr *ref\n\ttypeFlag := (r >> 32) & 7\n\tif (r>>32)&nanHead == nanHead && typeFlag != typeFlagNone {\n\t\tgcPtr = new(ref)\n\t\t*gcPtr = r\n\t\truntime.SetFinalizer(gcPtr, func(p *ref) {\n\t\t\tfinalizeRef(*p)\n\t\t})\n\t}\n\n\treturn Value{ref: r, gcPtr: gcPtr}\n}\n\nfunc finalizeRef(r ref)\n\nfunc predefValue(id uint32, typeFlag byte) Value {\n\treturn Value{ref: (nanHead|ref(typeFlag))<<32 | ref(id)}\n}\n\nfunc floatValue(f float64) Value {\n\tif f == 0 {\n\t\treturn valueZero\n\t}\n\tif f != f {\n\t\treturn valueNaN\n\t}\n\treturn Value{ref: *(*ref)(unsafe.Pointer(&f))}\n}\n\n// Error wraps a JavaScript error.\ntype Error struct {\n\t// Value is the underlying JavaScript error value.\n\tValue\n}\n\n// Error implements the error interface.\nfunc (e Error) Error() string {\n\treturn \"JavaScript error: \" + e.Get(\"message\").String()\n}\n\nvar (\n\tvalueUndefined = Value{ref: 0}\n\tvalueNaN       = predefValue(0, typeFlagNone)\n\tvalueZero      = predefValue(1, typeFlagNone)\n\tvalueNull      = predefValue(2, typeFlagNone)\n\tvalueTrue      = predefValue(3, typeFlagNone)\n\tvalueFalse     = predefValue(4, typeFlagNone)\n\tvalueGlobal    = predefValue(5, typeFlagObject)\n\tjsGo           = predefValue(6, typeFlagObject) // instance of the Go class in JavaScript\n\n\tobjectConstructor = valueGlobal.Get(\"Object\")\n\tarrayConstructor  = valueGlobal.Get(\"Array\")\n)\n\n// Equal reports whether v and w are equal according to JavaScript's === operator.\nfunc (v Value) Equal(w Value) bool {\n\treturn v.ref == w.ref && v.ref != valueNaN.ref\n}\n\n// Undefined returns the JavaScript value \"undefined\".\nfunc Undefined() Value {\n\treturn valueUndefined\n}\n\n// IsUndefined reports whether v is the JavaScript value \"undefined\".\nfunc (v Value) IsUndefined() bool {\n\treturn v.ref == valueUndefined.ref\n}\n\n// Null returns the JavaScript value \"null\".\nfunc Null() Value {\n\treturn valueNull\n}\n\n// IsNull reports whether v is the JavaScript value \"null\".\nfunc (v Value) IsNull() bool {\n\treturn v.ref == valueNull.ref\n}\n\n// IsNaN reports whether v is the JavaScript value \"NaN\".\nfunc (v Value) IsNaN() bool {\n\treturn v.ref == valueNaN.ref\n}\n\n// Global returns the JavaScript global object, usually \"window\" or \"global\".\nfunc Global() Value {\n\treturn valueGlobal\n}\n\n// ValueOf returns x as a JavaScript value:\n//\n//  | Go                     | JavaScript             |\n//  | ---------------------- | ---------------------- |\n//  | js.Value               | [its value]            |\n//  | js.Func                | function               |\n//  | nil                    | null                   |\n//  | bool                   | boolean                |\n//  | integers and floats    | number                 |\n//  | string                 | string                 |\n//  | []interface{}          | new array              |\n//  | map[string]interface{} | new object             |\n//\n// Panics if x is not one of the expected types.\nfunc ValueOf(x interface{}) Value {\n\tswitch x := x.(type) {\n\tcase Value: // should precede Wrapper to avoid a loop\n\t\treturn x\n\tcase Wrapper:\n\t\treturn x.JSValue()\n\tcase nil:\n\t\treturn valueNull\n\tcase bool:\n\t\tif x {\n\t\t\treturn valueTrue\n\t\t} else {\n\t\t\treturn valueFalse\n\t\t}\n\tcase int:\n\t\treturn floatValue(float64(x))\n\tcase int8:\n\t\treturn floatValue(float64(x))\n\tcase int16:\n\t\treturn floatValue(float64(x))\n\tcase int32:\n\t\treturn floatValue(float64(x))\n\tcase int64:\n\t\treturn floatValue(float64(x))\n\tcase uint:\n\t\treturn floatValue(float64(x))\n\tcase uint8:\n\t\treturn floatValue(float64(x))\n\tcase uint16:\n\t\treturn floatValue(float64(x))\n\tcase uint32:\n\t\treturn floatValue(float64(x))\n\tcase uint64:\n\t\treturn floatValue(float64(x))\n\tcase uintptr:\n\t\treturn floatValue(float64(x))\n\tcase unsafe.Pointer:\n\t\treturn floatValue(float64(uintptr(x)))\n\tcase float32:\n\t\treturn floatValue(float64(x))\n\tcase float64:\n\t\treturn floatValue(x)\n\tcase string:\n\t\treturn makeValue(stringVal(x))\n\tcase []interface{}:\n\t\ta := arrayConstructor.New(len(x))\n\t\tfor i, s := range x {\n\t\t\ta.SetIndex(i, s)\n\t\t}\n\t\treturn a\n\tcase map[string]interface{}:\n\t\to := objectConstructor.New()\n\t\tfor k, v := range x {\n\t\t\to.Set(k, v)\n\t\t}\n\t\treturn o\n\tdefault:\n\t\tpanic(\"ValueOf: invalid value\")\n\t}\n}\n\nfunc stringVal(x string) ref\n\n// Type represents the JavaScript type of a Value.\ntype Type int\n\nconst (\n\tTypeUndefined Type = iota\n\tTypeNull\n\tTypeBoolean\n\tTypeNumber\n\tTypeString\n\tTypeSymbol\n\tTypeObject\n\tTypeFunction\n)\n\nfunc (t Type) String() string {\n\tswitch t {\n\tcase TypeUndefined:\n\t\treturn \"undefined\"\n\tcase TypeNull:\n\t\treturn \"null\"\n\tcase TypeBoolean:\n\t\treturn \"boolean\"\n\tcase TypeNumber:\n\t\treturn \"number\"\n\tcase TypeString:\n\t\treturn \"string\"\n\tcase TypeSymbol:\n\t\treturn \"symbol\"\n\tcase TypeObject:\n\t\treturn \"object\"\n\tcase TypeFunction:\n\t\treturn \"function\"\n\tdefault:\n\t\tpanic(\"bad type\")\n\t}\n}\n\nfunc (t Type) isObject() bool {\n\treturn t == TypeObject || t == TypeFunction\n}\n\n// Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator,\n// except that it returns TypeNull instead of TypeObject for null.\nfunc (v Value) Type() Type {\n\tswitch v.ref {\n\tcase valueUndefined.ref:\n\t\treturn TypeUndefined\n\tcase valueNull.ref:\n\t\treturn TypeNull\n\tcase valueTrue.ref, valueFalse.ref:\n\t\treturn TypeBoolean\n\t}\n\tif v.isNumber() {\n\t\treturn TypeNumber\n\t}\n\ttypeFlag := (v.ref >> 32) & 7\n\tswitch typeFlag {\n\tcase typeFlagObject:\n\t\treturn TypeObject\n\tcase typeFlagString:\n\t\treturn TypeString\n\tcase typeFlagSymbol:\n\t\treturn TypeSymbol\n\tcase typeFlagFunction:\n\t\treturn TypeFunction\n\tdefault:\n\t\tpanic(\"bad type flag\")\n\t}\n}\n\n// Get returns the JavaScript property p of value v.\n// It panics if v is not a JavaScript object.\nfunc (v Value) Get(p string) Value {\n\tif vType := v.Type(); !vType.isObject() {\n\t\tpanic(&ValueError{\"Value.Get\", vType})\n\t}\n\tr := makeValue(valueGet(v.ref, p))\n\truntime.KeepAlive(v)\n\treturn r\n}\n\nfunc valueGet(v ref, p string) ref\n\n// Set sets the JavaScript property p of value v to ValueOf(x).\n// It panics if v is not a JavaScript object.\nfunc (v Value) Set(p string, x interface{}) {\n\tif vType := v.Type(); !vType.isObject() {\n\t\tpanic(&ValueError{\"Value.Set\", vType})\n\t}\n\txv := ValueOf(x)\n\tvalueSet(v.ref, p, xv.ref)\n\truntime.KeepAlive(v)\n\truntime.KeepAlive(xv)\n}\n\nfunc valueSet(v ref, p string, x ref)\n\n// Delete deletes the JavaScript property p of value v.\n// It panics if v is not a JavaScript object.\nfunc (v Value) Delete(p string) {\n\tif vType := v.Type(); !vType.isObject() {\n\t\tpanic(&ValueError{\"Value.Delete\", vType})\n\t}\n\tvalueDelete(v.ref, p)\n\truntime.KeepAlive(v)\n}\n\nfunc valueDelete(v ref, p string)\n\n// Index returns JavaScript index i of value v.\n// It panics if v is not a JavaScript object.\nfunc (v Value) Index(i int) Value {\n\tif vType := v.Type(); !vType.isObject() {\n\t\tpanic(&ValueError{\"Value.Index\", vType})\n\t}\n\tr := makeValue(valueIndex(v.ref, i))\n\truntime.KeepAlive(v)\n\treturn r\n}\n\nfunc valueIndex(v ref, i int) ref\n\n// SetIndex sets the JavaScript index i of value v to ValueOf(x).\n// It panics if v is not a JavaScript object.\nfunc (v Value) SetIndex(i int, x interface{}) {\n\tif vType := v.Type(); !vType.isObject() {\n\t\tpanic(&ValueError{\"Value.SetIndex\", vType})\n\t}\n\txv := ValueOf(x)\n\tvalueSetIndex(v.ref, i, xv.ref)\n\truntime.KeepAlive(v)\n\truntime.KeepAlive(xv)\n}\n\nfunc valueSetIndex(v ref, i int, x ref)\n\nfunc makeArgs(args []interface{}) ([]Value, []ref) {\n\targVals := make([]Value, len(args))\n\targRefs := make([]ref, len(args))\n\tfor i, arg := range args {\n\t\tv := ValueOf(arg)\n\t\targVals[i] = v\n\t\targRefs[i] = v.ref\n\t}\n\treturn argVals, argRefs\n}\n\n// Length returns the JavaScript property \"length\" of v.\n// It panics if v is not a JavaScript object.\nfunc (v Value) Length() int {\n\tif vType := v.Type(); !vType.isObject() {\n\t\tpanic(&ValueError{\"Value.SetIndex\", vType})\n\t}\n\tr := valueLength(v.ref)\n\truntime.KeepAlive(v)\n\treturn r\n}\n\nfunc valueLength(v ref) int\n\n// Call does a JavaScript call to the method m of value v with the given arguments.\n// It panics if v has no method m.\n// The arguments get mapped to JavaScript values according to the ValueOf function.\nfunc (v Value) Call(m string, args ...interface{}) Value {\n\targVals, argRefs := makeArgs(args)\n\tres, ok := valueCall(v.ref, m, argRefs)\n\truntime.KeepAlive(v)\n\truntime.KeepAlive(argVals)\n\tif !ok {\n\t\tif vType := v.Type(); !vType.isObject() { // check here to avoid overhead in success case\n\t\t\tpanic(&ValueError{\"Value.Call\", vType})\n\t\t}\n\t\tif propType := v.Get(m).Type(); propType != TypeFunction {\n\t\t\tpanic(\"syscall/js: Value.Call: property \" + m + \" is not a function, got \" + propType.String())\n\t\t}\n\t\tpanic(Error{makeValue(res)})\n\t}\n\treturn makeValue(res)\n}\n\nfunc valueCall(v ref, m string, args []ref) (ref, bool)\n\n// Invoke does a JavaScript call of the value v with the given arguments.\n// It panics if v is not a JavaScript function.\n// The arguments get mapped to JavaScript values according to the ValueOf function.\nfunc (v Value) Invoke(args ...interface{}) Value {\n\targVals, argRefs := makeArgs(args)\n\tres, ok := valueInvoke(v.ref, argRefs)\n\truntime.KeepAlive(v)\n\truntime.KeepAlive(argVals)\n\tif !ok {\n\t\tif vType := v.Type(); vType != TypeFunction { // check here to avoid overhead in success case\n\t\t\tpanic(&ValueError{\"Value.Invoke\", vType})\n\t\t}\n\t\tpanic(Error{makeValue(res)})\n\t}\n\treturn makeValue(res)\n}\n\nfunc valueInvoke(v ref, args []ref) (ref, bool)\n\n// New uses JavaScript's \"new\" operator with value v as constructor and the given arguments.\n// It panics if v is not a JavaScript function.\n// The arguments get mapped to JavaScript values according to the ValueOf function.\nfunc (v Value) New(args ...interface{}) Value {\n\targVals, argRefs := makeArgs(args)\n\tres, ok := valueNew(v.ref, argRefs)\n\truntime.KeepAlive(v)\n\truntime.KeepAlive(argVals)\n\tif !ok {\n\t\tif vType := v.Type(); vType != TypeFunction { // check here to avoid overhead in success case\n\t\t\tpanic(&ValueError{\"Value.Invoke\", vType})\n\t\t}\n\t\tpanic(Error{makeValue(res)})\n\t}\n\treturn makeValue(res)\n}\n\nfunc valueNew(v ref, args []ref) (ref, bool)\n\nfunc (v Value) isNumber() bool {\n\treturn v.ref == valueZero.ref ||\n\t\tv.ref == valueNaN.ref ||\n\t\t(v.ref != valueUndefined.ref && (v.ref>>32)&nanHead != nanHead)\n}\n\nfunc (v Value) float(method string) float64 {\n\tif !v.isNumber() {\n\t\tpanic(&ValueError{method, v.Type()})\n\t}\n\tif v.ref == valueZero.ref {\n\t\treturn 0\n\t}\n\treturn *(*float64)(unsafe.Pointer(&v.ref))\n}\n\n// Float returns the value v as a float64.\n// It panics if v is not a JavaScript number.\nfunc (v Value) Float() float64 {\n\treturn v.float(\"Value.Float\")\n}\n\n// Int returns the value v truncated to an int.\n// It panics if v is not a JavaScript number.\nfunc (v Value) Int() int {\n\treturn int(v.float(\"Value.Int\"))\n}\n\n// Bool returns the value v as a bool.\n// It panics if v is not a JavaScript boolean.\nfunc (v Value) Bool() bool {\n\tswitch v.ref {\n\tcase valueTrue.ref:\n\t\treturn true\n\tcase valueFalse.ref:\n\t\treturn false\n\tdefault:\n\t\tpanic(&ValueError{\"Value.Bool\", v.Type()})\n\t}\n}\n\n// Truthy returns the JavaScript \"truthiness\" of the value v. In JavaScript,\n// false, 0, \"\", null, undefined, and NaN are \"falsy\", and everything else is\n// \"truthy\". See https://developer.mozilla.org/en-US/docs/Glossary/Truthy.\nfunc (v Value) Truthy() bool {\n\tswitch v.Type() {\n\tcase TypeUndefined, TypeNull:\n\t\treturn false\n\tcase TypeBoolean:\n\t\treturn v.Bool()\n\tcase TypeNumber:\n\t\treturn v.ref != valueNaN.ref && v.ref != valueZero.ref\n\tcase TypeString:\n\t\treturn v.String() != \"\"\n\tcase TypeSymbol, TypeFunction, TypeObject:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"bad type\")\n\t}\n}\n\n// String returns the value v as a string.\n// String is a special case because of Go's String method convention. Unlike the other getters,\n// it does not panic if v's Type is not TypeString. Instead, it returns a string of the form \"<T>\"\n// or \"<T: V>\" where T is v's type and V is a string representation of v's value.\nfunc (v Value) String() string {\n\tswitch v.Type() {\n\tcase TypeString:\n\t\treturn jsString(v)\n\tcase TypeUndefined:\n\t\treturn \"<undefined>\"\n\tcase TypeNull:\n\t\treturn \"<null>\"\n\tcase TypeBoolean:\n\t\treturn \"<boolean: \" + jsString(v) + \">\"\n\tcase TypeNumber:\n\t\treturn \"<number: \" + jsString(v) + \">\"\n\tcase TypeSymbol:\n\t\treturn \"<symbol>\"\n\tcase TypeObject:\n\t\treturn \"<object>\"\n\tcase TypeFunction:\n\t\treturn \"<function>\"\n\tdefault:\n\t\tpanic(\"bad type\")\n\t}\n}\n\nfunc jsString(v Value) string {\n\tstr, length := valuePrepareString(v.ref)\n\truntime.KeepAlive(v)\n\tb := make([]byte, length)\n\tvalueLoadString(str, b)\n\tfinalizeRef(str)\n\treturn string(b)\n}\n\nfunc valuePrepareString(v ref) (ref, int)\n\nfunc valueLoadString(v ref, b []byte)\n\n// InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator.\nfunc (v Value) InstanceOf(t Value) bool {\n\tr := valueInstanceOf(v.ref, t.ref)\n\truntime.KeepAlive(v)\n\truntime.KeepAlive(t)\n\treturn r\n}\n\nfunc valueInstanceOf(v ref, t ref) bool\n\n// A ValueError occurs when a Value method is invoked on\n// a Value that does not support it. Such cases are documented\n// in the description of each method.\ntype ValueError struct {\n\tMethod string\n\tType   Type\n}\n\nfunc (e *ValueError) Error() string {\n\treturn \"syscall/js: call of \" + e.Method + \" on \" + e.Type.String()\n}\n\n// CopyBytesToGo copies bytes from src to dst.\n// It panics if src is not an Uint8Array or Uint8ClampedArray.\n// It returns the number of bytes copied, which will be the minimum of the lengths of src and dst.\nfunc CopyBytesToGo(dst []byte, src Value) int {\n\tn, ok := copyBytesToGo(dst, src.ref)\n\truntime.KeepAlive(src)\n\tif !ok {\n\t\tpanic(\"syscall/js: CopyBytesToGo: expected src to be an Uint8Array or Uint8ClampedArray\")\n\t}\n\treturn n\n}\n\nfunc copyBytesToGo(dst []byte, src ref) (int, bool)\n\n// CopyBytesToJS copies bytes from src to dst.\n// It panics if dst is not an Uint8Array or Uint8ClampedArray.\n// It returns the number of bytes copied, which will be the minimum of the lengths of src and dst.\nfunc CopyBytesToJS(dst Value, src []byte) int {\n\tn, ok := copyBytesToJS(dst.ref, src)\n\truntime.KeepAlive(dst)\n\tif !ok {\n\t\tpanic(\"syscall/js: CopyBytesToJS: expected dst to be an Uint8Array or Uint8ClampedArray\")\n\t}\n\treturn n\n}\n\nfunc copyBytesToJS(dst ref, src []byte) (int, bool)\n","// Portions copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package os implements a subset of the Go \"os\" package. See\n// https://godoc.org/os for details.\n//\n// Note that the current implementation is blocking. This limitation should be\n// removed in a future version.\npackage os\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"syscall\"\n)\n\n// Seek whence values.\n//\n// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.\nconst (\n\tSEEK_SET int = io.SeekStart\n\tSEEK_CUR int = io.SeekCurrent\n\tSEEK_END int = io.SeekEnd\n)\n\n// Mkdir creates a directory. If the operation fails, it will return an error of\n// type *PathError.\nfunc Mkdir(path string, perm FileMode) error {\n\tfs, suffix := findMount(path)\n\tif fs == nil {\n\t\treturn &PathError{\"mkdir\", path, ErrNotExist}\n\t}\n\terr := fs.Mkdir(suffix, perm)\n\tif err != nil {\n\t\treturn &PathError{\"mkdir\", path, err}\n\t}\n\treturn nil\n}\n\n// Many functions in package syscall return a count of -1 instead of 0.\n// Using fixCount(call()) instead of call() corrects the count.\nfunc fixCount(n int, err error) (int, error) {\n\tif n < 0 {\n\t\tn = 0\n\t}\n\treturn n, err\n}\n\n// Remove removes a file or (empty) directory. If the operation fails, it will\n// return an error of type *PathError.\nfunc Remove(path string) error {\n\tfs, suffix := findMount(path)\n\tif fs == nil {\n\t\treturn &PathError{\"remove\", path, ErrNotExist}\n\t}\n\terr := fs.Remove(suffix)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// RemoveAll is a stub, it is not implemented.\nfunc RemoveAll(path string) error {\n\treturn ErrNotImplemented\n}\n\n// File represents an open file descriptor.\ntype File struct {\n\thandle FileHandle\n\tname   string\n}\n\n// Name returns the name of the file with which it was opened.\nfunc (f *File) Name() string {\n\treturn f.name\n}\n\n// OpenFile opens the named file. If the operation fails, the returned error\n// will be of type *PathError.\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error) {\n\tfs, suffix := findMount(name)\n\tif fs == nil {\n\t\treturn nil, &PathError{\"open\", name, ErrNotExist}\n\t}\n\thandle, err := fs.OpenFile(suffix, flag, perm)\n\tif err != nil {\n\t\treturn nil, &PathError{\"open\", name, err}\n\t}\n\treturn &File{name: name, handle: handle}, nil\n}\n\n// Open opens the file named for reading.\nfunc Open(name string) (*File, error) {\n\treturn OpenFile(name, O_RDONLY, 0)\n}\n\n// Create creates the named file, overwriting it if it already exists.\nfunc Create(name string) (*File, error) {\n\treturn OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)\n}\n\n// Read reads up to len(b) bytes from the File. It returns the number of bytes\n// read and any error encountered. At end of file, Read returns 0, io.EOF.\nfunc (f *File) Read(b []byte) (n int, err error) {\n\tn, err = f.handle.Read(b)\n\t// TODO: want to always wrap, like upstream, but ReadFile() compares against exactly io.EOF?\n\tif err != nil && err != io.EOF {\n\t\terr = &PathError{\"read\", f.name, err}\n\t}\n\treturn\n}\n\nvar errNegativeOffset = errors.New(\"negative offset\")\n\n// ReadAt reads up to len(b) bytes from the File at the given absolute offset.\n// It returns the number of bytes read and any error encountered, possible io.EOF.\n// At end of file, Read returns 0, io.EOF.\nfunc (f *File) ReadAt(b []byte, offset int64) (n int, err error) {\n\tif offset < 0 {\n\t\treturn 0, &PathError{Op: \"readat\", Path: f.name, Err: errNegativeOffset}\n\t}\n\n\tfor len(b) > 0 {\n\t\tm, e := f.handle.ReadAt(b, offset)\n\t\tif e != nil {\n\t\t\t// TODO: want to always wrap, like upstream, but TestReadAtEOF compares against exactly io.EOF?\n\t\t\tif e != io.EOF {\n\t\t\t\terr = &PathError{\"readat\", f.name, e}\n\t\t\t} else {\n\t\t\t\terr = e\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tn += m\n\t\tb = b[m:]\n\t\toffset += int64(m)\n\t}\n\n\treturn\n}\n\n// Write writes len(b) bytes to the File. It returns the number of bytes written\n// and an error, if any. Write returns a non-nil error when n != len(b).\nfunc (f *File) Write(b []byte) (n int, err error) {\n\tn, err = f.handle.Write(b)\n\tif err != nil {\n\t\terr = &PathError{\"write\", f.name, err}\n\t}\n\treturn\n}\n\n// WriteString is like Write, but writes the contents of string s rather than a\n// slice of bytes.\nfunc (f *File) WriteString(s string) (n int, err error) {\n\treturn f.Write([]byte(s))\n}\n\nfunc (f *File) WriteAt(b []byte, off int64) (n int, err error) {\n\treturn 0, ErrNotImplemented\n}\n\n// Close closes the File, rendering it unusable for I/O.\nfunc (f *File) Close() (err error) {\n\terr = f.handle.Close()\n\tif err != nil {\n\t\terr = &PathError{\"close\", f.name, err}\n\t}\n\treturn\n}\n\n// Readdir is a stub, not yet implemented\nfunc (f *File) Readdir(n int) ([]FileInfo, error) {\n\treturn nil, &PathError{\"readdir\", f.name, ErrNotImplemented}\n}\n\n// Readdirnames is a stub, not yet implemented\nfunc (f *File) Readdirnames(n int) (names []string, err error) {\n\treturn nil, &PathError{\"readdirnames\", f.name, ErrNotImplemented}\n}\n\n// Seek sets the offset for the next Read or Write on file to offset, interpreted\n// according to whence: 0 means relative to the origin of the file, 1 means\n// relative to the current offset, and 2 means relative to the end.\n// It returns the new offset and an error, if any.\n// The behavior of Seek on a file opened with O_APPEND is not specified.\n//\n// If f is a directory, the behavior of Seek varies by operating\n// system; you can seek to the beginning of the directory on Unix-like\n// operating systems, but not on Windows.\nfunc (f *File) Seek(offset int64, whence int) (ret int64, err error) {\n\treturn f.handle.Seek(offset, whence)\n}\n\nfunc (f *File) SyscallConn() (syscall.RawConn, error) {\n\treturn nil, ErrNotImplemented\n}\n\n// Fd returns the file handle referencing the open file.\nfunc (f *File) Fd() uintptr {\n\tpanic(\"unimplemented: os.file.Fd()\")\n}\n\n// Truncate is a stub, not yet implemented\nfunc (f *File) Truncate(size int64) error {\n\treturn &PathError{\"truncate\", f.name, ErrNotImplemented}\n}\n\n// PathError records an error and the operation and file path that caused it.\n// TODO: PathError moved to io/fs in go 1.16 and left an alias in os/errors.go.\n// Do the same once we drop support for go 1.15.\ntype PathError struct {\n\tOp   string\n\tPath string\n\tErr  error\n}\n\nfunc (e *PathError) Error() string {\n\treturn e.Op + \" \" + e.Path + \": \" + e.Err.Error()\n}\n\nfunc (e *PathError) Unwrap() error {\n\treturn e.Err\n}\n\n// LinkError records an error during a link or symlink or rename system call and\n// the paths that caused it.\ntype LinkError struct {\n\tOp  string\n\tOld string\n\tNew string\n\tErr error\n}\n\nfunc (e *LinkError) Error() string {\n\treturn e.Op + \" \" + e.Old + \" \" + e.New + \": \" + e.Err.Error()\n}\n\nfunc (e *LinkError) Unwrap() error {\n\treturn e.Err\n}\n\nconst (\n\tO_RDONLY int = syscall.O_RDONLY\n\tO_WRONLY int = syscall.O_WRONLY\n\tO_RDWR   int = syscall.O_RDWR\n\tO_APPEND int = syscall.O_APPEND\n\tO_CREATE int = syscall.O_CREAT\n\tO_EXCL   int = syscall.O_EXCL\n\tO_SYNC   int = syscall.O_SYNC\n\tO_TRUNC  int = syscall.O_TRUNC\n)\n\nfunc Getwd() (string, error) {\n\treturn syscall.Getwd()\n}\n\n// TempDir returns the default directory to use for temporary files.\n//\n// On Unix systems, it returns $TMPDIR if non-empty, else /tmp.\n// On Windows, it uses GetTempPath, returning the first non-empty\n// value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\n//\n// The directory is neither guaranteed to exist nor have accessible\n// permissions.\nfunc TempDir() string {\n\treturn tempDir()\n}\n","// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage fmt\n\nimport \"errors\"\n\n// Errorf formats according to a format specifier and returns the string as a\n// value that satisfies error.\n//\n// If the format specifier includes a %w verb with an error operand,\n// the returned error will implement an Unwrap method returning the operand. It is\n// invalid to include more than one %w verb or to supply it with an operand\n// that does not implement the error interface. The %w verb is otherwise\n// a synonym for %v.\nfunc Errorf(format string, a ...interface{}) error {\n\tp := newPrinter()\n\tp.wrapErrs = true\n\tp.doPrintf(format, a)\n\ts := string(p.buf)\n\tvar err error\n\tif p.wrappedErr == nil {\n\t\terr = errors.New(s)\n\t} else {\n\t\terr = &wrapError{s, p.wrappedErr}\n\t}\n\tp.free()\n\treturn err\n}\n\ntype wrapError struct {\n\tmsg string\n\terr error\n}\n\nfunc (e *wrapError) Error() string {\n\treturn e.msg\n}\n\nfunc (e *wrapError) Unwrap() error {\n\treturn e.err\n}\n","package websocket\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// StatusCode represents a WebSocket status code.\n// https://tools.ietf.org/html/rfc6455#section-7.4\ntype StatusCode int\n\n// https://www.iana.org/assignments/websocket/websocket.xhtml#close-code-number\n//\n// These are only the status codes defined by the protocol.\n//\n// You can define custom codes in the 3000-4999 range.\n// The 3000-3999 range is reserved for use by libraries, frameworks and applications.\n// The 4000-4999 range is reserved for private use.\nconst (\n\tStatusNormalClosure   StatusCode = 1000\n\tStatusGoingAway       StatusCode = 1001\n\tStatusProtocolError   StatusCode = 1002\n\tStatusUnsupportedData StatusCode = 1003\n\n\t// 1004 is reserved and so unexported.\n\tstatusReserved StatusCode = 1004\n\n\t// StatusNoStatusRcvd cannot be sent in a close message.\n\t// It is reserved for when a close message is received without\n\t// a status code.\n\tStatusNoStatusRcvd StatusCode = 1005\n\n\t// StatusAbnormalClosure is exported for use only with Wasm.\n\t// In non Wasm Go, the returned error will indicate whether the\n\t// connection was closed abnormally.\n\tStatusAbnormalClosure StatusCode = 1006\n\n\tStatusInvalidFramePayloadData StatusCode = 1007\n\tStatusPolicyViolation         StatusCode = 1008\n\tStatusMessageTooBig           StatusCode = 1009\n\tStatusMandatoryExtension      StatusCode = 1010\n\tStatusInternalError           StatusCode = 1011\n\tStatusServiceRestart          StatusCode = 1012\n\tStatusTryAgainLater           StatusCode = 1013\n\tStatusBadGateway              StatusCode = 1014\n\n\t// StatusTLSHandshake is only exported for use with Wasm.\n\t// In non Wasm Go, the returned error will indicate whether there was\n\t// a TLS handshake failure.\n\tStatusTLSHandshake StatusCode = 1015\n)\n\n// CloseError is returned when the connection is closed with a status and reason.\n//\n// Use Go 1.13's errors.As to check for this error.\n// Also see the CloseStatus helper.\ntype CloseError struct {\n\tCode   StatusCode\n\tReason string\n}\n\nfunc (ce CloseError) Error() string {\n\treturn fmt.Sprintf(\"status = %v and reason = %q\", ce.Code, ce.Reason)\n}\n\n// CloseStatus is a convenience wrapper around Go 1.13's errors.As to grab\n// the status code from a CloseError.\n//\n// -1 will be returned if the passed error is nil or not a CloseError.\nfunc CloseStatus(err error) StatusCode {\n\tvar ce CloseError\n\tif errors.As(err, &ce) {\n\t\treturn ce.Code\n\t}\n\treturn -1\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package url parses URLs and implements query escaping.\npackage url\n\n// See RFC 3986. This package generally follows RFC 3986, except where\n// it deviates for compatibility reasons. When sending changes, first\n// search old issues for history on decisions. Unit tests should also\n// contain references to issue numbers with details.\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Error reports an error and the operation and URL that caused it.\ntype Error struct {\n\tOp  string\n\tURL string\n\tErr error\n}\n\nfunc (e *Error) Unwrap() error { return e.Err }\nfunc (e *Error) Error() string { return fmt.Sprintf(\"%s %q: %s\", e.Op, e.URL, e.Err) }\n\nfunc (e *Error) Timeout() bool {\n\tt, ok := e.Err.(interface {\n\t\tTimeout() bool\n\t})\n\treturn ok && t.Timeout()\n}\n\nfunc (e *Error) Temporary() bool {\n\tt, ok := e.Err.(interface {\n\t\tTemporary() bool\n\t})\n\treturn ok && t.Temporary()\n}\n\nconst upperhex = \"0123456789ABCDEF\"\n\nfunc ishex(c byte) bool {\n\tswitch {\n\tcase '0' <= c && c <= '9':\n\t\treturn true\n\tcase 'a' <= c && c <= 'f':\n\t\treturn true\n\tcase 'A' <= c && c <= 'F':\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc unhex(c byte) byte {\n\tswitch {\n\tcase '0' <= c && c <= '9':\n\t\treturn c - '0'\n\tcase 'a' <= c && c <= 'f':\n\t\treturn c - 'a' + 10\n\tcase 'A' <= c && c <= 'F':\n\t\treturn c - 'A' + 10\n\t}\n\treturn 0\n}\n\ntype encoding int\n\nconst (\n\tencodePath encoding = 1 + iota\n\tencodePathSegment\n\tencodeHost\n\tencodeZone\n\tencodeUserPassword\n\tencodeQueryComponent\n\tencodeFragment\n)\n\ntype EscapeError string\n\nfunc (e EscapeError) Error() string {\n\treturn \"invalid URL escape \" + strconv.Quote(string(e))\n}\n\ntype InvalidHostError string\n\nfunc (e InvalidHostError) Error() string {\n\treturn \"invalid character \" + strconv.Quote(string(e)) + \" in host name\"\n}\n\n// Return true if the specified character should be escaped when\n// appearing in a URL string, according to RFC 3986.\n//\n// Please be informed that for now shouldEscape does not check all\n// reserved characters correctly. See golang.org/issue/5684.\nfunc shouldEscape(c byte, mode encoding) bool {\n\t// \u00a72.3 Unreserved characters (alphanum)\n\tif 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9' {\n\t\treturn false\n\t}\n\n\tif mode == encodeHost || mode == encodeZone {\n\t\t// \u00a73.2.2 Host allows\n\t\t//\tsub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t\t// as part of reg-name.\n\t\t// We add : because we include :port as part of host.\n\t\t// We add [ ] because we include [ipv6]:port as part of host.\n\t\t// We add < > because they're the only characters left that\n\t\t// we could possibly allow, and Parse will reject them if we\n\t\t// escape them (because hosts can't use %-encoding for\n\t\t// ASCII bytes).\n\t\tswitch c {\n\t\tcase '!', '$', '&', '\\'', '(', ')', '*', '+', ',', ';', '=', ':', '[', ']', '<', '>', '\"':\n\t\t\treturn false\n\t\t}\n\t}\n\n\tswitch c {\n\tcase '-', '_', '.', '~': // \u00a72.3 Unreserved characters (mark)\n\t\treturn false\n\n\tcase '$', '&', '+', ',', '/', ':', ';', '=', '?', '@': // \u00a72.2 Reserved characters (reserved)\n\t\t// Different sections of the URL allow a few of\n\t\t// the reserved characters to appear unescaped.\n\t\tswitch mode {\n\t\tcase encodePath: // \u00a73.3\n\t\t\t// The RFC allows : @ & = + $ but saves / ; , for assigning\n\t\t\t// meaning to individual path segments. This package\n\t\t\t// only manipulates the path as a whole, so we allow those\n\t\t\t// last three as well. That leaves only ? to escape.\n\t\t\treturn c == '?'\n\n\t\tcase encodePathSegment: // \u00a73.3\n\t\t\t// The RFC allows : @ & = + $ but saves / ; , for assigning\n\t\t\t// meaning to individual path segments.\n\t\t\treturn c == '/' || c == ';' || c == ',' || c == '?'\n\n\t\tcase encodeUserPassword: // \u00a73.2.1\n\t\t\t// The RFC allows ';', ':', '&', '=', '+', '$', and ',' in\n\t\t\t// userinfo, so we must escape only '@', '/', and '?'.\n\t\t\t// The parsing of userinfo treats ':' as special so we must escape\n\t\t\t// that too.\n\t\t\treturn c == '@' || c == '/' || c == '?' || c == ':'\n\n\t\tcase encodeQueryComponent: // \u00a73.4\n\t\t\t// The RFC reserves (so we must escape) everything.\n\t\t\treturn true\n\n\t\tcase encodeFragment: // \u00a74.1\n\t\t\t// The RFC text is silent but the grammar allows\n\t\t\t// everything, so escape nothing.\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif mode == encodeFragment {\n\t\t// RFC 3986 \u00a72.2 allows not escaping sub-delims. A subset of sub-delims are\n\t\t// included in reserved from RFC 2396 \u00a72.2. The remaining sub-delims do not\n\t\t// need to be escaped. To minimize potential breakage, we apply two restrictions:\n\t\t// (1) we always escape sub-delims outside of the fragment, and (2) we always\n\t\t// escape single quote to avoid breaking callers that had previously assumed that\n\t\t// single quotes would be escaped. See issue #19917.\n\t\tswitch c {\n\t\tcase '!', '(', ')', '*':\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Everything else must be escaped.\n\treturn true\n}\n\n// QueryUnescape does the inverse transformation of QueryEscape,\n// converting each 3-byte encoded substring of the form \"%AB\" into the\n// hex-decoded byte 0xAB.\n// It returns an error if any % is not followed by two hexadecimal\n// digits.\nfunc QueryUnescape(s string) (string, error) {\n\treturn unescape(s, encodeQueryComponent)\n}\n\n// PathUnescape does the inverse transformation of PathEscape,\n// converting each 3-byte encoded substring of the form \"%AB\" into the\n// hex-decoded byte 0xAB. It returns an error if any % is not followed\n// by two hexadecimal digits.\n//\n// PathUnescape is identical to QueryUnescape except that it does not\n// unescape '+' to ' ' (space).\nfunc PathUnescape(s string) (string, error) {\n\treturn unescape(s, encodePathSegment)\n}\n\n// unescape unescapes a string; the mode specifies\n// which section of the URL string is being unescaped.\nfunc unescape(s string, mode encoding) (string, error) {\n\t// Count %, check that they're well-formed.\n\tn := 0\n\thasPlus := false\n\tfor i := 0; i < len(s); {\n\t\tswitch s[i] {\n\t\tcase '%':\n\t\t\tn++\n\t\t\tif i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {\n\t\t\t\ts = s[i:]\n\t\t\t\tif len(s) > 3 {\n\t\t\t\t\ts = s[:3]\n\t\t\t\t}\n\t\t\t\treturn \"\", EscapeError(s)\n\t\t\t}\n\t\t\t// Per https://tools.ietf.org/html/rfc3986#page-21\n\t\t\t// in the host component %-encoding can only be used\n\t\t\t// for non-ASCII bytes.\n\t\t\t// But https://tools.ietf.org/html/rfc6874#section-2\n\t\t\t// introduces %25 being allowed to escape a percent sign\n\t\t\t// in IPv6 scoped-address literals. Yay.\n\t\t\tif mode == encodeHost && unhex(s[i+1]) < 8 && s[i:i+3] != \"%25\" {\n\t\t\t\treturn \"\", EscapeError(s[i : i+3])\n\t\t\t}\n\t\t\tif mode == encodeZone {\n\t\t\t\t// RFC 6874 says basically \"anything goes\" for zone identifiers\n\t\t\t\t// and that even non-ASCII can be redundantly escaped,\n\t\t\t\t// but it seems prudent to restrict %-escaped bytes here to those\n\t\t\t\t// that are valid host name bytes in their unescaped form.\n\t\t\t\t// That is, you can use escaping in the zone identifier but not\n\t\t\t\t// to introduce bytes you couldn't just write directly.\n\t\t\t\t// But Windows puts spaces here! Yay.\n\t\t\t\tv := unhex(s[i+1])<<4 | unhex(s[i+2])\n\t\t\t\tif s[i:i+3] != \"%25\" && v != ' ' && shouldEscape(v, encodeHost) {\n\t\t\t\t\treturn \"\", EscapeError(s[i : i+3])\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += 3\n\t\tcase '+':\n\t\t\thasPlus = mode == encodeQueryComponent\n\t\t\ti++\n\t\tdefault:\n\t\t\tif (mode == encodeHost || mode == encodeZone) && s[i] < 0x80 && shouldEscape(s[i], mode) {\n\t\t\t\treturn \"\", InvalidHostError(s[i : i+1])\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\n\tif n == 0 && !hasPlus {\n\t\treturn s, nil\n\t}\n\n\tvar t strings.Builder\n\tt.Grow(len(s) - 2*n)\n\tfor i := 0; i < len(s); i++ {\n\t\tswitch s[i] {\n\t\tcase '%':\n\t\t\tt.WriteByte(unhex(s[i+1])<<4 | unhex(s[i+2]))\n\t\t\ti += 2\n\t\tcase '+':\n\t\t\tif mode == encodeQueryComponent {\n\t\t\t\tt.WriteByte(' ')\n\t\t\t} else {\n\t\t\t\tt.WriteByte('+')\n\t\t\t}\n\t\tdefault:\n\t\t\tt.WriteByte(s[i])\n\t\t}\n\t}\n\treturn t.String(), nil\n}\n\n// QueryEscape escapes the string so it can be safely placed\n// inside a URL query.\nfunc QueryEscape(s string) string {\n\treturn escape(s, encodeQueryComponent)\n}\n\n// PathEscape escapes the string so it can be safely placed inside a URL path segment,\n// replacing special characters (including /) with %XX sequences as needed.\nfunc PathEscape(s string) string {\n\treturn escape(s, encodePathSegment)\n}\n\nfunc escape(s string, mode encoding) string {\n\tspaceCount, hexCount := 0, 0\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif shouldEscape(c, mode) {\n\t\t\tif c == ' ' && mode == encodeQueryComponent {\n\t\t\t\tspaceCount++\n\t\t\t} else {\n\t\t\t\thexCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tif spaceCount == 0 && hexCount == 0 {\n\t\treturn s\n\t}\n\n\tvar buf [64]byte\n\tvar t []byte\n\n\trequired := len(s) + 2*hexCount\n\tif required <= len(buf) {\n\t\tt = buf[:required]\n\t} else {\n\t\tt = make([]byte, required)\n\t}\n\n\tif hexCount == 0 {\n\t\tcopy(t, s)\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == ' ' {\n\t\t\t\tt[i] = '+'\n\t\t\t}\n\t\t}\n\t\treturn string(t)\n\t}\n\n\tj := 0\n\tfor i := 0; i < len(s); i++ {\n\t\tswitch c := s[i]; {\n\t\tcase c == ' ' && mode == encodeQueryComponent:\n\t\t\tt[j] = '+'\n\t\t\tj++\n\t\tcase shouldEscape(c, mode):\n\t\t\tt[j] = '%'\n\t\t\tt[j+1] = upperhex[c>>4]\n\t\t\tt[j+2] = upperhex[c&15]\n\t\t\tj += 3\n\t\tdefault:\n\t\t\tt[j] = s[i]\n\t\t\tj++\n\t\t}\n\t}\n\treturn string(t)\n}\n\n// A URL represents a parsed URL (technically, a URI reference).\n//\n// The general form represented is:\n//\n//\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n//\n// URLs that do not start with a slash after the scheme are interpreted as:\n//\n//\tscheme:opaque[?query][#fragment]\n//\n// Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\n// A consequence is that it is impossible to tell which slashes in the Path were\n// slashes in the raw URL and which were %2f. This distinction is rarely important,\n// but when it is, the code should use RawPath, an optional field which only gets\n// set if the default encoding is different from Path.\n//\n// URL's String method uses the EscapedPath method to obtain the path. See the\n// EscapedPath method for more details.\ntype URL struct {\n\tScheme      string\n\tOpaque      string    // encoded opaque data\n\tUser        *Userinfo // username and password information\n\tHost        string    // host or host:port\n\tPath        string    // path (relative paths may omit leading slash)\n\tRawPath     string    // encoded path hint (see EscapedPath method)\n\tForceQuery  bool      // append a query ('?') even if RawQuery is empty\n\tRawQuery    string    // encoded query values, without '?'\n\tFragment    string    // fragment for references, without '#'\n\tRawFragment string    // encoded fragment hint (see EscapedFragment method)\n}\n\n// User returns a Userinfo containing the provided username\n// and no password set.\nfunc User(username string) *Userinfo {\n\treturn &Userinfo{username, \"\", false}\n}\n\n// UserPassword returns a Userinfo containing the provided username\n// and password.\n//\n// This functionality should only be used with legacy web sites.\n// RFC 2396 warns that interpreting Userinfo this way\n// ``is NOT RECOMMENDED, because the passing of authentication\n// information in clear text (such as URI) has proven to be a\n// security risk in almost every case where it has been used.''\nfunc UserPassword(username, password string) *Userinfo {\n\treturn &Userinfo{username, password, true}\n}\n\n// The Userinfo type is an immutable encapsulation of username and\n// password details for a URL. An existing Userinfo value is guaranteed\n// to have a username set (potentially empty, as allowed by RFC 2396),\n// and optionally a password.\ntype Userinfo struct {\n\tusername    string\n\tpassword    string\n\tpasswordSet bool\n}\n\n// Username returns the username.\nfunc (u *Userinfo) Username() string {\n\tif u == nil {\n\t\treturn \"\"\n\t}\n\treturn u.username\n}\n\n// Password returns the password in case it is set, and whether it is set.\nfunc (u *Userinfo) Password() (string, bool) {\n\tif u == nil {\n\t\treturn \"\", false\n\t}\n\treturn u.password, u.passwordSet\n}\n\n// String returns the encoded userinfo information in the standard form\n// of \"username[:password]\".\nfunc (u *Userinfo) String() string {\n\tif u == nil {\n\t\treturn \"\"\n\t}\n\ts := escape(u.username, encodeUserPassword)\n\tif u.passwordSet {\n\t\ts += \":\" + escape(u.password, encodeUserPassword)\n\t}\n\treturn s\n}\n\n// Maybe rawURL is of the form scheme:path.\n// (Scheme must be [a-zA-Z][a-zA-Z0-9+-.]*)\n// If so, return scheme, path; else return \"\", rawURL.\nfunc getScheme(rawURL string) (scheme, path string, err error) {\n\tfor i := 0; i < len(rawURL); i++ {\n\t\tc := rawURL[i]\n\t\tswitch {\n\t\tcase 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z':\n\t\t// do nothing\n\t\tcase '0' <= c && c <= '9' || c == '+' || c == '-' || c == '.':\n\t\t\tif i == 0 {\n\t\t\t\treturn \"\", rawURL, nil\n\t\t\t}\n\t\tcase c == ':':\n\t\t\tif i == 0 {\n\t\t\t\treturn \"\", \"\", errors.New(\"missing protocol scheme\")\n\t\t\t}\n\t\t\treturn rawURL[:i], rawURL[i+1:], nil\n\t\tdefault:\n\t\t\t// we have encountered an invalid character,\n\t\t\t// so there is no valid scheme\n\t\t\treturn \"\", rawURL, nil\n\t\t}\n\t}\n\treturn \"\", rawURL, nil\n}\n\n// split slices s into two substrings separated by the first occurrence of\n// sep. If cutc is true then sep is excluded from the second substring.\n// If sep does not occur in s then s and the empty string is returned.\nfunc split(s string, sep byte, cutc bool) (string, string) {\n\ti := strings.IndexByte(s, sep)\n\tif i < 0 {\n\t\treturn s, \"\"\n\t}\n\tif cutc {\n\t\treturn s[:i], s[i+1:]\n\t}\n\treturn s[:i], s[i:]\n}\n\n// Parse parses a raw url into a URL structure.\n//\n// The url may be relative (a path, without a host) or absolute\n// (starting with a scheme). Trying to parse a hostname and path\n// without a scheme is invalid but may not necessarily return an\n// error, due to parsing ambiguities.\nfunc Parse(rawURL string) (*URL, error) {\n\t// Cut off #frag\n\tu, frag := split(rawURL, '#', true)\n\turl, err := parse(u, false)\n\tif err != nil {\n\t\treturn nil, &Error{\"parse\", u, err}\n\t}\n\tif frag == \"\" {\n\t\treturn url, nil\n\t}\n\tif err = url.setFragment(frag); err != nil {\n\t\treturn nil, &Error{\"parse\", rawURL, err}\n\t}\n\treturn url, nil\n}\n\n// ParseRequestURI parses a raw url into a URL structure. It assumes that\n// url was received in an HTTP request, so the url is interpreted\n// only as an absolute URI or an absolute path.\n// The string url is assumed not to have a #fragment suffix.\n// (Web browsers strip #fragment before sending the URL to a web server.)\nfunc ParseRequestURI(rawURL string) (*URL, error) {\n\turl, err := parse(rawURL, true)\n\tif err != nil {\n\t\treturn nil, &Error{\"parse\", rawURL, err}\n\t}\n\treturn url, nil\n}\n\n// parse parses a URL from a string in one of two contexts. If\n// viaRequest is true, the URL is assumed to have arrived via an HTTP request,\n// in which case only absolute URLs or path-absolute relative URLs are allowed.\n// If viaRequest is false, all forms of relative URLs are allowed.\nfunc parse(rawURL string, viaRequest bool) (*URL, error) {\n\tvar rest string\n\tvar err error\n\n\tif stringContainsCTLByte(rawURL) {\n\t\treturn nil, errors.New(\"net/url: invalid control character in URL\")\n\t}\n\n\tif rawURL == \"\" && viaRequest {\n\t\treturn nil, errors.New(\"empty url\")\n\t}\n\turl := new(URL)\n\n\tif rawURL == \"*\" {\n\t\turl.Path = \"*\"\n\t\treturn url, nil\n\t}\n\n\t// Split off possible leading \"http:\", \"mailto:\", etc.\n\t// Cannot contain escaped characters.\n\tif url.Scheme, rest, err = getScheme(rawURL); err != nil {\n\t\treturn nil, err\n\t}\n\turl.Scheme = strings.ToLower(url.Scheme)\n\n\tif strings.HasSuffix(rest, \"?\") && strings.Count(rest, \"?\") == 1 {\n\t\turl.ForceQuery = true\n\t\trest = rest[:len(rest)-1]\n\t} else {\n\t\trest, url.RawQuery = split(rest, '?', true)\n\t}\n\n\tif !strings.HasPrefix(rest, \"/\") {\n\t\tif url.Scheme != \"\" {\n\t\t\t// We consider rootless paths per RFC 3986 as opaque.\n\t\t\turl.Opaque = rest\n\t\t\treturn url, nil\n\t\t}\n\t\tif viaRequest {\n\t\t\treturn nil, errors.New(\"invalid URI for request\")\n\t\t}\n\n\t\t// Avoid confusion with malformed schemes, like cache_object:foo/bar.\n\t\t// See golang.org/issue/16822.\n\t\t//\n\t\t// RFC 3986, \u00a73.3:\n\t\t// In addition, a URI reference (Section 4.1) may be a relative-path reference,\n\t\t// in which case the first path segment cannot contain a colon (\":\") character.\n\t\tcolon := strings.Index(rest, \":\")\n\t\tslash := strings.Index(rest, \"/\")\n\t\tif colon >= 0 && (slash < 0 || colon < slash) {\n\t\t\t// First path segment has colon. Not allowed in relative URL.\n\t\t\treturn nil, errors.New(\"first path segment in URL cannot contain colon\")\n\t\t}\n\t}\n\n\tif (url.Scheme != \"\" || !viaRequest && !strings.HasPrefix(rest, \"///\")) && strings.HasPrefix(rest, \"//\") {\n\t\tvar authority string\n\t\tauthority, rest = split(rest[2:], '/', false)\n\t\turl.User, url.Host, err = parseAuthority(authority)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// Set Path and, optionally, RawPath.\n\t// RawPath is a hint of the encoding of Path. We don't want to set it if\n\t// the default escaping of Path is equivalent, to help make sure that people\n\t// don't rely on it in general.\n\tif err := url.setPath(rest); err != nil {\n\t\treturn nil, err\n\t}\n\treturn url, nil\n}\n\nfunc parseAuthority(authority string) (user *Userinfo, host string, err error) {\n\ti := strings.LastIndex(authority, \"@\")\n\tif i < 0 {\n\t\thost, err = parseHost(authority)\n\t} else {\n\t\thost, err = parseHost(authority[i+1:])\n\t}\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif i < 0 {\n\t\treturn nil, host, nil\n\t}\n\tuserinfo := authority[:i]\n\tif !validUserinfo(userinfo) {\n\t\treturn nil, \"\", errors.New(\"net/url: invalid userinfo\")\n\t}\n\tif !strings.Contains(userinfo, \":\") {\n\t\tif userinfo, err = unescape(userinfo, encodeUserPassword); err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tuser = User(userinfo)\n\t} else {\n\t\tusername, password := split(userinfo, ':', true)\n\t\tif username, err = unescape(username, encodeUserPassword); err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tif password, err = unescape(password, encodeUserPassword); err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tuser = UserPassword(username, password)\n\t}\n\treturn user, host, nil\n}\n\n// parseHost parses host as an authority without user\n// information. That is, as host[:port].\nfunc parseHost(host string) (string, error) {\n\tif strings.HasPrefix(host, \"[\") {\n\t\t// Parse an IP-Literal in RFC 3986 and RFC 6874.\n\t\t// E.g., \"[fe80::1]\", \"[fe80::1%25en0]\", \"[fe80::1]:80\".\n\t\ti := strings.LastIndex(host, \"]\")\n\t\tif i < 0 {\n\t\t\treturn \"\", errors.New(\"missing ']' in host\")\n\t\t}\n\t\tcolonPort := host[i+1:]\n\t\tif !validOptionalPort(colonPort) {\n\t\t\treturn \"\", fmt.Errorf(\"invalid port %q after host\", colonPort)\n\t\t}\n\n\t\t// RFC 6874 defines that %25 (%-encoded percent) introduces\n\t\t// the zone identifier, and the zone identifier can use basically\n\t\t// any %-encoding it likes. That's different from the host, which\n\t\t// can only %-encode non-ASCII bytes.\n\t\t// We do impose some restrictions on the zone, to avoid stupidity\n\t\t// like newlines.\n\t\tzone := strings.Index(host[:i], \"%25\")\n\t\tif zone >= 0 {\n\t\t\thost1, err := unescape(host[:zone], encodeHost)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\thost2, err := unescape(host[zone:i], encodeZone)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\thost3, err := unescape(host[i:], encodeHost)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\treturn host1 + host2 + host3, nil\n\t\t}\n\t} else if i := strings.LastIndex(host, \":\"); i != -1 {\n\t\tcolonPort := host[i:]\n\t\tif !validOptionalPort(colonPort) {\n\t\t\treturn \"\", fmt.Errorf(\"invalid port %q after host\", colonPort)\n\t\t}\n\t}\n\n\tvar err error\n\tif host, err = unescape(host, encodeHost); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn host, nil\n}\n\n// setPath sets the Path and RawPath fields of the URL based on the provided\n// escaped path p. It maintains the invariant that RawPath is only specified\n// when it differs from the default encoding of the path.\n// For example:\n// - setPath(\"/foo/bar\")   will set Path=\"/foo/bar\" and RawPath=\"\"\n// - setPath(\"/foo%2fbar\") will set Path=\"/foo/bar\" and RawPath=\"/foo%2fbar\"\n// setPath will return an error only if the provided path contains an invalid\n// escaping.\nfunc (u *URL) setPath(p string) error {\n\tpath, err := unescape(p, encodePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tu.Path = path\n\tif escp := escape(path, encodePath); p == escp {\n\t\t// Default encoding is fine.\n\t\tu.RawPath = \"\"\n\t} else {\n\t\tu.RawPath = p\n\t}\n\treturn nil\n}\n\n// EscapedPath returns the escaped form of u.Path.\n// In general there are multiple possible escaped forms of any path.\n// EscapedPath returns u.RawPath when it is a valid escaping of u.Path.\n// Otherwise EscapedPath ignores u.RawPath and computes an escaped\n// form on its own.\n// The String and RequestURI methods use EscapedPath to construct\n// their results.\n// In general, code should call EscapedPath instead of\n// reading u.RawPath directly.\nfunc (u *URL) EscapedPath() string {\n\tif u.RawPath != \"\" && validEncoded(u.RawPath, encodePath) {\n\t\tp, err := unescape(u.RawPath, encodePath)\n\t\tif err == nil && p == u.Path {\n\t\t\treturn u.RawPath\n\t\t}\n\t}\n\tif u.Path == \"*\" {\n\t\treturn \"*\" // don't escape (Issue 11202)\n\t}\n\treturn escape(u.Path, encodePath)\n}\n\n// validEncoded reports whether s is a valid encoded path or fragment,\n// according to mode.\n// It must not contain any bytes that require escaping during encoding.\nfunc validEncoded(s string, mode encoding) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\t// RFC 3986, Appendix A.\n\t\t// pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\".\n\t\t// shouldEscape is not quite compliant with the RFC,\n\t\t// so we check the sub-delims ourselves and let\n\t\t// shouldEscape handle the others.\n\t\tswitch s[i] {\n\t\tcase '!', '$', '&', '\\'', '(', ')', '*', '+', ',', ';', '=', ':', '@':\n\t\t\t// ok\n\t\tcase '[', ']':\n\t\t\t// ok - not specified in RFC 3986 but left alone by modern browsers\n\t\tcase '%':\n\t\t\t// ok - percent encoded, will decode\n\t\tdefault:\n\t\t\tif shouldEscape(s[i], mode) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// setFragment is like setPath but for Fragment/RawFragment.\nfunc (u *URL) setFragment(f string) error {\n\tfrag, err := unescape(f, encodeFragment)\n\tif err != nil {\n\t\treturn err\n\t}\n\tu.Fragment = frag\n\tif escf := escape(frag, encodeFragment); f == escf {\n\t\t// Default encoding is fine.\n\t\tu.RawFragment = \"\"\n\t} else {\n\t\tu.RawFragment = f\n\t}\n\treturn nil\n}\n\n// EscapedFragment returns the escaped form of u.Fragment.\n// In general there are multiple possible escaped forms of any fragment.\n// EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment.\n// Otherwise EscapedFragment ignores u.RawFragment and computes an escaped\n// form on its own.\n// The String method uses EscapedFragment to construct its result.\n// In general, code should call EscapedFragment instead of\n// reading u.RawFragment directly.\nfunc (u *URL) EscapedFragment() string {\n\tif u.RawFragment != \"\" && validEncoded(u.RawFragment, encodeFragment) {\n\t\tf, err := unescape(u.RawFragment, encodeFragment)\n\t\tif err == nil && f == u.Fragment {\n\t\t\treturn u.RawFragment\n\t\t}\n\t}\n\treturn escape(u.Fragment, encodeFragment)\n}\n\n// validOptionalPort reports whether port is either an empty string\n// or matches /^:\\d*$/\nfunc validOptionalPort(port string) bool {\n\tif port == \"\" {\n\t\treturn true\n\t}\n\tif port[0] != ':' {\n\t\treturn false\n\t}\n\tfor _, b := range port[1:] {\n\t\tif b < '0' || b > '9' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// String reassembles the URL into a valid URL string.\n// The general form of the result is one of:\n//\n//\tscheme:opaque?query#fragment\n//\tscheme://userinfo@host/path?query#fragment\n//\n// If u.Opaque is non-empty, String uses the first form;\n// otherwise it uses the second form.\n// Any non-ASCII characters in host are escaped.\n// To obtain the path, String uses u.EscapedPath().\n//\n// In the second form, the following rules apply:\n//\t- if u.Scheme is empty, scheme: is omitted.\n//\t- if u.User is nil, userinfo@ is omitted.\n//\t- if u.Host is empty, host/ is omitted.\n//\t- if u.Scheme and u.Host are empty and u.User is nil,\n//\t   the entire scheme://userinfo@host/ is omitted.\n//\t- if u.Host is non-empty and u.Path begins with a /,\n//\t   the form host/path does not add its own /.\n//\t- if u.RawQuery is empty, ?query is omitted.\n//\t- if u.Fragment is empty, #fragment is omitted.\nfunc (u *URL) String() string {\n\tvar buf strings.Builder\n\tif u.Scheme != \"\" {\n\t\tbuf.WriteString(u.Scheme)\n\t\tbuf.WriteByte(':')\n\t}\n\tif u.Opaque != \"\" {\n\t\tbuf.WriteString(u.Opaque)\n\t} else {\n\t\tif u.Scheme != \"\" || u.Host != \"\" || u.User != nil {\n\t\t\tif u.Host != \"\" || u.Path != \"\" || u.User != nil {\n\t\t\t\tbuf.WriteString(\"//\")\n\t\t\t}\n\t\t\tif ui := u.User; ui != nil {\n\t\t\t\tbuf.WriteString(ui.String())\n\t\t\t\tbuf.WriteByte('@')\n\t\t\t}\n\t\t\tif h := u.Host; h != \"\" {\n\t\t\t\tbuf.WriteString(escape(h, encodeHost))\n\t\t\t}\n\t\t}\n\t\tpath := u.EscapedPath()\n\t\tif path != \"\" && path[0] != '/' && u.Host != \"\" {\n\t\t\tbuf.WriteByte('/')\n\t\t}\n\t\tif buf.Len() == 0 {\n\t\t\t// RFC 3986 \u00a74.2\n\t\t\t// A path segment that contains a colon character (e.g., \"this:that\")\n\t\t\t// cannot be used as the first segment of a relative-path reference, as\n\t\t\t// it would be mistaken for a scheme name. Such a segment must be\n\t\t\t// preceded by a dot-segment (e.g., \"./this:that\") to make a relative-\n\t\t\t// path reference.\n\t\t\tif i := strings.IndexByte(path, ':'); i > -1 && strings.IndexByte(path[:i], '/') == -1 {\n\t\t\t\tbuf.WriteString(\"./\")\n\t\t\t}\n\t\t}\n\t\tbuf.WriteString(path)\n\t}\n\tif u.ForceQuery || u.RawQuery != \"\" {\n\t\tbuf.WriteByte('?')\n\t\tbuf.WriteString(u.RawQuery)\n\t}\n\tif u.Fragment != \"\" {\n\t\tbuf.WriteByte('#')\n\t\tbuf.WriteString(u.EscapedFragment())\n\t}\n\treturn buf.String()\n}\n\n// Redacted is like String but replaces any password with \"xxxxx\".\n// Only the password in u.URL is redacted.\nfunc (u *URL) Redacted() string {\n\tif u == nil {\n\t\treturn \"\"\n\t}\n\n\tru := *u\n\tif _, has := ru.User.Password(); has {\n\t\tru.User = UserPassword(ru.User.Username(), \"xxxxx\")\n\t}\n\treturn ru.String()\n}\n\n// Values maps a string key to a list of values.\n// It is typically used for query parameters and form values.\n// Unlike in the http.Header map, the keys in a Values map\n// are case-sensitive.\ntype Values map[string][]string\n\n// Get gets the first value associated with the given key.\n// If there are no values associated with the key, Get returns\n// the empty string. To access multiple values, use the map\n// directly.\nfunc (v Values) Get(key string) string {\n\tif v == nil {\n\t\treturn \"\"\n\t}\n\tvs := v[key]\n\tif len(vs) == 0 {\n\t\treturn \"\"\n\t}\n\treturn vs[0]\n}\n\n// Set sets the key to value. It replaces any existing\n// values.\nfunc (v Values) Set(key, value string) {\n\tv[key] = []string{value}\n}\n\n// Add adds the value to key. It appends to any existing\n// values associated with key.\nfunc (v Values) Add(key, value string) {\n\tv[key] = append(v[key], value)\n}\n\n// Del deletes the values associated with key.\nfunc (v Values) Del(key string) {\n\tdelete(v, key)\n}\n\n// Has checks whether a given key is set.\nfunc (v Values) Has(key string) bool {\n\t_, ok := v[key]\n\treturn ok\n}\n\n// ParseQuery parses the URL-encoded query string and returns\n// a map listing the values specified for each key.\n// ParseQuery always returns a non-nil map containing all the\n// valid query parameters found; err describes the first decoding error\n// encountered, if any.\n//\n// Query is expected to be a list of key=value settings separated by ampersands.\n// A setting without an equals sign is interpreted as a key set to an empty\n// value.\n// Settings containing a non-URL-encoded semicolon are considered invalid.\nfunc ParseQuery(query string) (Values, error) {\n\tm := make(Values)\n\terr := parseQuery(m, query)\n\treturn m, err\n}\n\nfunc parseQuery(m Values, query string) (err error) {\n\tfor query != \"\" {\n\t\tkey := query\n\t\tif i := strings.IndexAny(key, \"&\"); i >= 0 {\n\t\t\tkey, query = key[:i], key[i+1:]\n\t\t} else {\n\t\t\tquery = \"\"\n\t\t}\n\t\tif strings.Contains(key, \";\") {\n\t\t\terr = fmt.Errorf(\"invalid semicolon separator in query\")\n\t\t\tcontinue\n\t\t}\n\t\tif key == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvalue := \"\"\n\t\tif i := strings.Index(key, \"=\"); i >= 0 {\n\t\t\tkey, value = key[:i], key[i+1:]\n\t\t}\n\t\tkey, err1 := QueryUnescape(key)\n\t\tif err1 != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = err1\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tvalue, err1 = QueryUnescape(value)\n\t\tif err1 != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = err1\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tm[key] = append(m[key], value)\n\t}\n\treturn err\n}\n\n// Encode encodes the values into ``URL encoded'' form\n// (\"bar=baz&foo=quux\") sorted by key.\nfunc (v Values) Encode() string {\n\tif v == nil {\n\t\treturn \"\"\n\t}\n\tvar buf strings.Builder\n\tkeys := make([]string, 0, len(v))\n\tfor k := range v {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\tfor _, k := range keys {\n\t\tvs := v[k]\n\t\tkeyEscaped := QueryEscape(k)\n\t\tfor _, v := range vs {\n\t\t\tif buf.Len() > 0 {\n\t\t\t\tbuf.WriteByte('&')\n\t\t\t}\n\t\t\tbuf.WriteString(keyEscaped)\n\t\t\tbuf.WriteByte('=')\n\t\t\tbuf.WriteString(QueryEscape(v))\n\t\t}\n\t}\n\treturn buf.String()\n}\n\n// resolvePath applies special path segments from refs and applies\n// them to base, per RFC 3986.\nfunc resolvePath(base, ref string) string {\n\tvar full string\n\tif ref == \"\" {\n\t\tfull = base\n\t} else if ref[0] != '/' {\n\t\ti := strings.LastIndex(base, \"/\")\n\t\tfull = base[:i+1] + ref\n\t} else {\n\t\tfull = ref\n\t}\n\tif full == \"\" {\n\t\treturn \"\"\n\t}\n\n\tvar (\n\t\tlast string\n\t\telem string\n\t\ti    int\n\t\tdst  strings.Builder\n\t)\n\tfirst := true\n\tremaining := full\n\t// We want to return a leading '/', so write it now.\n\tdst.WriteByte('/')\n\tfor i >= 0 {\n\t\ti = strings.IndexByte(remaining, '/')\n\t\tif i < 0 {\n\t\t\tlast, elem, remaining = remaining, remaining, \"\"\n\t\t} else {\n\t\t\telem, remaining = remaining[:i], remaining[i+1:]\n\t\t}\n\t\tif elem == \".\" {\n\t\t\tfirst = false\n\t\t\t// drop\n\t\t\tcontinue\n\t\t}\n\n\t\tif elem == \"..\" {\n\t\t\t// Ignore the leading '/' we already wrote.\n\t\t\tstr := dst.String()[1:]\n\t\t\tindex := strings.LastIndexByte(str, '/')\n\n\t\t\tdst.Reset()\n\t\t\tdst.WriteByte('/')\n\t\t\tif index == -1 {\n\t\t\t\tfirst = true\n\t\t\t} else {\n\t\t\t\tdst.WriteString(str[:index])\n\t\t\t}\n\t\t} else {\n\t\t\tif !first {\n\t\t\t\tdst.WriteByte('/')\n\t\t\t}\n\t\t\tdst.WriteString(elem)\n\t\t\tfirst = false\n\t\t}\n\t}\n\n\tif last == \".\" || last == \"..\" {\n\t\tdst.WriteByte('/')\n\t}\n\n\t// We wrote an initial '/', but we don't want two.\n\tr := dst.String()\n\tif len(r) > 1 && r[1] == '/' {\n\t\tr = r[1:]\n\t}\n\treturn r\n}\n\n// IsAbs reports whether the URL is absolute.\n// Absolute means that it has a non-empty scheme.\nfunc (u *URL) IsAbs() bool {\n\treturn u.Scheme != \"\"\n}\n\n// Parse parses a URL in the context of the receiver. The provided URL\n// may be relative or absolute. Parse returns nil, err on parse\n// failure, otherwise its return value is the same as ResolveReference.\nfunc (u *URL) Parse(ref string) (*URL, error) {\n\trefURL, err := Parse(ref)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn u.ResolveReference(refURL), nil\n}\n\n// ResolveReference resolves a URI reference to an absolute URI from\n// an absolute base URI u, per RFC 3986 Section 5.2. The URI reference\n// may be relative or absolute. ResolveReference always returns a new\n// URL instance, even if the returned URL is identical to either the\n// base or reference. If ref is an absolute URL, then ResolveReference\n// ignores base and returns a copy of ref.\nfunc (u *URL) ResolveReference(ref *URL) *URL {\n\turl := *ref\n\tif ref.Scheme == \"\" {\n\t\turl.Scheme = u.Scheme\n\t}\n\tif ref.Scheme != \"\" || ref.Host != \"\" || ref.User != nil {\n\t\t// The \"absoluteURI\" or \"net_path\" cases.\n\t\t// We can ignore the error from setPath since we know we provided a\n\t\t// validly-escaped path.\n\t\turl.setPath(resolvePath(ref.EscapedPath(), \"\"))\n\t\treturn &url\n\t}\n\tif ref.Opaque != \"\" {\n\t\turl.User = nil\n\t\turl.Host = \"\"\n\t\turl.Path = \"\"\n\t\treturn &url\n\t}\n\tif ref.Path == \"\" && ref.RawQuery == \"\" {\n\t\turl.RawQuery = u.RawQuery\n\t\tif ref.Fragment == \"\" {\n\t\t\turl.Fragment = u.Fragment\n\t\t\turl.RawFragment = u.RawFragment\n\t\t}\n\t}\n\t// The \"abs_path\" or \"rel_path\" cases.\n\turl.Host = u.Host\n\turl.User = u.User\n\turl.setPath(resolvePath(u.EscapedPath(), ref.EscapedPath()))\n\treturn &url\n}\n\n// Query parses RawQuery and returns the corresponding values.\n// It silently discards malformed value pairs.\n// To check errors use ParseQuery.\nfunc (u *URL) Query() Values {\n\tv, _ := ParseQuery(u.RawQuery)\n\treturn v\n}\n\n// RequestURI returns the encoded path?query or opaque?query\n// string that would be used in an HTTP request for u.\nfunc (u *URL) RequestURI() string {\n\tresult := u.Opaque\n\tif result == \"\" {\n\t\tresult = u.EscapedPath()\n\t\tif result == \"\" {\n\t\t\tresult = \"/\"\n\t\t}\n\t} else {\n\t\tif strings.HasPrefix(result, \"//\") {\n\t\t\tresult = u.Scheme + \":\" + result\n\t\t}\n\t}\n\tif u.ForceQuery || u.RawQuery != \"\" {\n\t\tresult += \"?\" + u.RawQuery\n\t}\n\treturn result\n}\n\n// Hostname returns u.Host, stripping any valid port number if present.\n//\n// If the result is enclosed in square brackets, as literal IPv6 addresses are,\n// the square brackets are removed from the result.\nfunc (u *URL) Hostname() string {\n\thost, _ := splitHostPort(u.Host)\n\treturn host\n}\n\n// Port returns the port part of u.Host, without the leading colon.\n//\n// If u.Host doesn't contain a valid numeric port, Port returns an empty string.\nfunc (u *URL) Port() string {\n\t_, port := splitHostPort(u.Host)\n\treturn port\n}\n\n// splitHostPort separates host and port. If the port is not valid, it returns\n// the entire input as host, and it doesn't check the validity of the host.\n// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.\nfunc splitHostPort(hostPort string) (host, port string) {\n\thost = hostPort\n\n\tcolon := strings.LastIndexByte(host, ':')\n\tif colon != -1 && validOptionalPort(host[colon:]) {\n\t\thost, port = host[:colon], host[colon+1:]\n\t}\n\n\tif strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {\n\t\thost = host[1 : len(host)-1]\n\t}\n\n\treturn\n}\n\n// Marshaling interface implementations.\n// Would like to implement MarshalText/UnmarshalText but that will change the JSON representation of URLs.\n\nfunc (u *URL) MarshalBinary() (text []byte, err error) {\n\treturn []byte(u.String()), nil\n}\n\nfunc (u *URL) UnmarshalBinary(text []byte) error {\n\tu1, err := Parse(string(text))\n\tif err != nil {\n\t\treturn err\n\t}\n\t*u = *u1\n\treturn nil\n}\n\n// validUserinfo reports whether s is a valid userinfo string per RFC 3986\n// Section 3.2.1:\n//     userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n//     unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n//     sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n//                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n//\n// It doesn't validate pct-encoded. The caller does that via func unescape.\nfunc validUserinfo(s string) bool {\n\tfor _, r := range s {\n\t\tif 'A' <= r && r <= 'Z' {\n\t\t\tcontinue\n\t\t}\n\t\tif 'a' <= r && r <= 'z' {\n\t\t\tcontinue\n\t\t}\n\t\tif '0' <= r && r <= '9' {\n\t\t\tcontinue\n\t\t}\n\t\tswitch r {\n\t\tcase '-', '.', '_', ':', '~', '!', '$', '&', '\\'',\n\t\t\t'(', ')', '*', '+', ',', ';', '=', '%', '@':\n\t\t\tcontinue\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// stringContainsCTLByte reports whether s contains any ASCII control character.\nfunc stringContainsCTLByte(s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tb := s[i]\n\t\tif b < ' ' || b == 0x7f {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n","// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage time\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\t\"syscall\"\n)\n\n//go:generate env ZONEINFO=$GOROOT/lib/time/zoneinfo.zip go run genzabbrs.go -output zoneinfo_abbrs_windows.go\n\n// A Location maps time instants to the zone in use at that time.\n// Typically, the Location represents the collection of time offsets\n// in use in a geographical area. For many Locations the time offset varies\n// depending on whether daylight savings time is in use at the time instant.\ntype Location struct {\n\tname string\n\tzone []zone\n\ttx   []zoneTrans\n\n\t// The tzdata information can be followed by a string that describes\n\t// how to handle DST transitions not recorded in zoneTrans.\n\t// The format is the TZ environment variable without a colon; see\n\t// https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html.\n\t// Example string, for America/Los_Angeles: PST8PDT,M3.2.0,M11.1.0\n\textend string\n\n\t// Most lookups will be for the current time.\n\t// To avoid the binary search through tx, keep a\n\t// static one-element cache that gives the correct\n\t// zone for the time when the Location was created.\n\t// if cacheStart <= t < cacheEnd,\n\t// lookup can return cacheZone.\n\t// The units for cacheStart and cacheEnd are seconds\n\t// since January 1, 1970 UTC, to match the argument\n\t// to lookup.\n\tcacheStart int64\n\tcacheEnd   int64\n\tcacheZone  *zone\n}\n\n// A zone represents a single time zone such as CET.\ntype zone struct {\n\tname   string // abbreviated name, \"CET\"\n\toffset int    // seconds east of UTC\n\tisDST  bool   // is this zone Daylight Savings Time?\n}\n\n// A zoneTrans represents a single time zone transition.\ntype zoneTrans struct {\n\twhen         int64 // transition time, in seconds since 1970 GMT\n\tindex        uint8 // the index of the zone that goes into effect at that time\n\tisstd, isutc bool  // ignored - no idea what these mean\n}\n\n// alpha and omega are the beginning and end of time for zone\n// transitions.\nconst (\n\talpha = -1 << 63  // math.MinInt64\n\tomega = 1<<63 - 1 // math.MaxInt64\n)\n\n// UTC represents Universal Coordinated Time (UTC).\nvar UTC *Location = &utcLoc\n\n// utcLoc is separate so that get can refer to &utcLoc\n// and ensure that it never returns a nil *Location,\n// even if a badly behaved client has changed UTC.\nvar utcLoc = Location{name: \"UTC\"}\n\n// Local represents the system's local time zone.\n// On Unix systems, Local consults the TZ environment\n// variable to find the time zone to use. No TZ means\n// use the system default /etc/localtime.\n// TZ=\"\" means use UTC.\n// TZ=\"foo\" means use file foo in the system timezone directory.\nvar Local *Location = &localLoc\n\n// localLoc is separate so that initLocal can initialize\n// it even if a client has changed Local.\nvar localLoc Location\nvar localOnce sync.Once\n\nfunc (l *Location) get() *Location {\n\tif l == nil {\n\t\treturn &utcLoc\n\t}\n\tif l == &localLoc {\n\t\tlocalOnce.Do(initLocal)\n\t}\n\treturn l\n}\n\n// String returns a descriptive name for the time zone information,\n// corresponding to the name argument to LoadLocation or FixedZone.\nfunc (l *Location) String() string {\n\treturn l.get().name\n}\n\n// FixedZone returns a Location that always uses\n// the given zone name and offset (seconds east of UTC).\nfunc FixedZone(name string, offset int) *Location {\n\tl := &Location{\n\t\tname:       name,\n\t\tzone:       []zone{{name, offset, false}},\n\t\ttx:         []zoneTrans{{alpha, 0, false, false}},\n\t\tcacheStart: alpha,\n\t\tcacheEnd:   omega,\n\t}\n\tl.cacheZone = &l.zone[0]\n\treturn l\n}\n\n// lookup returns information about the time zone in use at an\n// instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.\n//\n// The returned information gives the name of the zone (such as \"CET\"),\n// the start and end times bracketing sec when that zone is in effect,\n// the offset in seconds east of UTC (such as -5*60*60), and whether\n// the daylight savings is being observed at that time.\nfunc (l *Location) lookup(sec int64) (name string, offset int, start, end int64, isDST bool) {\n\tl = l.get()\n\n\tif len(l.zone) == 0 {\n\t\tname = \"UTC\"\n\t\toffset = 0\n\t\tstart = alpha\n\t\tend = omega\n\t\tisDST = false\n\t\treturn\n\t}\n\n\tif zone := l.cacheZone; zone != nil && l.cacheStart <= sec && sec < l.cacheEnd {\n\t\tname = zone.name\n\t\toffset = zone.offset\n\t\tstart = l.cacheStart\n\t\tend = l.cacheEnd\n\t\tisDST = zone.isDST\n\t\treturn\n\t}\n\n\tif len(l.tx) == 0 || sec < l.tx[0].when {\n\t\tzone := &l.zone[l.lookupFirstZone()]\n\t\tname = zone.name\n\t\toffset = zone.offset\n\t\tstart = alpha\n\t\tif len(l.tx) > 0 {\n\t\t\tend = l.tx[0].when\n\t\t} else {\n\t\t\tend = omega\n\t\t}\n\t\tisDST = zone.isDST\n\t\treturn\n\t}\n\n\t// Binary search for entry with largest time <= sec.\n\t// Not using sort.Search to avoid dependencies.\n\ttx := l.tx\n\tend = omega\n\tlo := 0\n\thi := len(tx)\n\tfor hi-lo > 1 {\n\t\tm := lo + (hi-lo)/2\n\t\tlim := tx[m].when\n\t\tif sec < lim {\n\t\t\tend = lim\n\t\t\thi = m\n\t\t} else {\n\t\t\tlo = m\n\t\t}\n\t}\n\tzone := &l.zone[tx[lo].index]\n\tname = zone.name\n\toffset = zone.offset\n\tstart = tx[lo].when\n\t// end = maintained during the search\n\tisDST = zone.isDST\n\n\t// If we're at the end of the known zone transitions,\n\t// try the extend string.\n\tif lo == len(tx)-1 && l.extend != \"\" {\n\t\tif ename, eoffset, estart, eend, eisDST, ok := tzset(l.extend, end, sec); ok {\n\t\t\treturn ename, eoffset, estart, eend, eisDST\n\t\t}\n\t}\n\n\treturn\n}\n\n// lookupFirstZone returns the index of the time zone to use for times\n// before the first transition time, or when there are no transition\n// times.\n//\n// The reference implementation in localtime.c from\n// https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz\n// implements the following algorithm for these cases:\n// 1) If the first zone is unused by the transitions, use it.\n// 2) Otherwise, if there are transition times, and the first\n//    transition is to a zone in daylight time, find the first\n//    non-daylight-time zone before and closest to the first transition\n//    zone.\n// 3) Otherwise, use the first zone that is not daylight time, if\n//    there is one.\n// 4) Otherwise, use the first zone.\nfunc (l *Location) lookupFirstZone() int {\n\t// Case 1.\n\tif !l.firstZoneUsed() {\n\t\treturn 0\n\t}\n\n\t// Case 2.\n\tif len(l.tx) > 0 && l.zone[l.tx[0].index].isDST {\n\t\tfor zi := int(l.tx[0].index) - 1; zi >= 0; zi-- {\n\t\t\tif !l.zone[zi].isDST {\n\t\t\t\treturn zi\n\t\t\t}\n\t\t}\n\t}\n\n\t// Case 3.\n\tfor zi := range l.zone {\n\t\tif !l.zone[zi].isDST {\n\t\t\treturn zi\n\t\t}\n\t}\n\n\t// Case 4.\n\treturn 0\n}\n\n// firstZoneUsed reports whether the first zone is used by some\n// transition.\nfunc (l *Location) firstZoneUsed() bool {\n\tfor _, tx := range l.tx {\n\t\tif tx.index == 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// tzset takes a timezone string like the one found in the TZ environment\n// variable, the end of the last time zone transition expressed as seconds\n// since January 1, 1970 00:00:00 UTC, and a time expressed the same way.\n// We call this a tzset string since in C the function tzset reads TZ.\n// The return values are as for lookup, plus ok which reports whether the\n// parse succeeded.\nfunc tzset(s string, initEnd, sec int64) (name string, offset int, start, end int64, isDST, ok bool) {\n\tvar (\n\t\tstdName, dstName     string\n\t\tstdOffset, dstOffset int\n\t)\n\n\tstdName, s, ok = tzsetName(s)\n\tif ok {\n\t\tstdOffset, s, ok = tzsetOffset(s)\n\t}\n\tif !ok {\n\t\treturn \"\", 0, 0, 0, false, false\n\t}\n\n\t// The numbers in the tzset string are added to local time to get UTC,\n\t// but our offsets are added to UTC to get local time,\n\t// so we negate the number we see here.\n\tstdOffset = -stdOffset\n\n\tif len(s) == 0 || s[0] == ',' {\n\t\t// No daylight savings time.\n\t\treturn stdName, stdOffset, initEnd, omega, false, true\n\t}\n\n\tdstName, s, ok = tzsetName(s)\n\tif ok {\n\t\tif len(s) == 0 || s[0] == ',' {\n\t\t\tdstOffset = stdOffset + secondsPerHour\n\t\t} else {\n\t\t\tdstOffset, s, ok = tzsetOffset(s)\n\t\t\tdstOffset = -dstOffset // as with stdOffset, above\n\t\t}\n\t}\n\tif !ok {\n\t\treturn \"\", 0, 0, 0, false, false\n\t}\n\n\tif len(s) == 0 {\n\t\t// Default DST rules per tzcode.\n\t\ts = \",M3.2.0,M11.1.0\"\n\t}\n\t// The TZ definition does not mention ';' here but tzcode accepts it.\n\tif s[0] != ',' && s[0] != ';' {\n\t\treturn \"\", 0, 0, 0, false, false\n\t}\n\ts = s[1:]\n\n\tvar startRule, endRule rule\n\tstartRule, s, ok = tzsetRule(s)\n\tif !ok || len(s) == 0 || s[0] != ',' {\n\t\treturn \"\", 0, 0, 0, false, false\n\t}\n\ts = s[1:]\n\tendRule, s, ok = tzsetRule(s)\n\tif !ok || len(s) > 0 {\n\t\treturn \"\", 0, 0, 0, false, false\n\t}\n\n\tyear, _, _, yday := absDate(uint64(sec+unixToInternal+internalToAbsolute), false)\n\n\tysec := int64(yday*secondsPerDay) + sec%secondsPerDay\n\n\t// Compute start of year in seconds since Unix epoch.\n\td := daysSinceEpoch(year)\n\tabs := int64(d * secondsPerDay)\n\tabs += absoluteToInternal + internalToUnix\n\n\tstartSec := int64(tzruleTime(year, startRule, stdOffset))\n\tendSec := int64(tzruleTime(year, endRule, dstOffset))\n\tdstIsDST, stdIsDST := true, false\n\t// Note: this is a flipping of \"DST\" and \"STD\" while retaining the labels\n\t// This happens in southern hemispheres. The labelling here thus is a little\n\t// inconsistent with the goal.\n\tif endSec < startSec {\n\t\tstartSec, endSec = endSec, startSec\n\t\tstdName, dstName = dstName, stdName\n\t\tstdOffset, dstOffset = dstOffset, stdOffset\n\t\tstdIsDST, dstIsDST = dstIsDST, stdIsDST\n\t}\n\n\t// The start and end values that we return are accurate\n\t// close to a daylight savings transition, but are otherwise\n\t// just the start and end of the year. That suffices for\n\t// the only caller that cares, which is Date.\n\tif ysec < startSec {\n\t\treturn stdName, stdOffset, abs, startSec + abs, stdIsDST, true\n\t} else if ysec >= endSec {\n\t\treturn stdName, stdOffset, endSec + abs, abs + 365*secondsPerDay, stdIsDST, true\n\t} else {\n\t\treturn dstName, dstOffset, startSec + abs, endSec + abs, dstIsDST, true\n\t}\n}\n\n// tzsetName returns the timezone name at the start of the tzset string s,\n// and the remainder of s, and reports whether the parsing is OK.\nfunc tzsetName(s string) (string, string, bool) {\n\tif len(s) == 0 {\n\t\treturn \"\", \"\", false\n\t}\n\tif s[0] != '<' {\n\t\tfor i, r := range s {\n\t\t\tswitch r {\n\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '-', '+':\n\t\t\t\tif i < 3 {\n\t\t\t\t\treturn \"\", \"\", false\n\t\t\t\t}\n\t\t\t\treturn s[:i], s[i:], true\n\t\t\t}\n\t\t}\n\t\tif len(s) < 3 {\n\t\t\treturn \"\", \"\", false\n\t\t}\n\t\treturn s, \"\", true\n\t} else {\n\t\tfor i, r := range s {\n\t\t\tif r == '>' {\n\t\t\t\treturn s[1:i], s[i+1:], true\n\t\t\t}\n\t\t}\n\t\treturn \"\", \"\", false\n\t}\n}\n\n// tzsetOffset returns the timezone offset at the start of the tzset string s,\n// and the remainder of s, and reports whether the parsing is OK.\n// The timezone offset is returned as a number of seconds.\nfunc tzsetOffset(s string) (offset int, rest string, ok bool) {\n\tif len(s) == 0 {\n\t\treturn 0, \"\", false\n\t}\n\tneg := false\n\tif s[0] == '+' {\n\t\ts = s[1:]\n\t} else if s[0] == '-' {\n\t\ts = s[1:]\n\t\tneg = true\n\t}\n\n\t// The tzdata code permits values up to 24 * 7 here,\n\t// although POSIX does not.\n\tvar hours int\n\thours, s, ok = tzsetNum(s, 0, 24*7)\n\tif !ok {\n\t\treturn 0, \"\", false\n\t}\n\toff := hours * secondsPerHour\n\tif len(s) == 0 || s[0] != ':' {\n\t\tif neg {\n\t\t\toff = -off\n\t\t}\n\t\treturn off, s, true\n\t}\n\n\tvar mins int\n\tmins, s, ok = tzsetNum(s[1:], 0, 59)\n\tif !ok {\n\t\treturn 0, \"\", false\n\t}\n\toff += mins * secondsPerMinute\n\tif len(s) == 0 || s[0] != ':' {\n\t\tif neg {\n\t\t\toff = -off\n\t\t}\n\t\treturn off, s, true\n\t}\n\n\tvar secs int\n\tsecs, s, ok = tzsetNum(s[1:], 0, 59)\n\tif !ok {\n\t\treturn 0, \"\", false\n\t}\n\toff += secs\n\n\tif neg {\n\t\toff = -off\n\t}\n\treturn off, s, true\n}\n\n// ruleKind is the kinds of rules that can be seen in a tzset string.\ntype ruleKind int\n\nconst (\n\truleJulian ruleKind = iota\n\truleDOY\n\truleMonthWeekDay\n)\n\n// rule is a rule read from a tzset string.\ntype rule struct {\n\tkind ruleKind\n\tday  int\n\tweek int\n\tmon  int\n\ttime int // transition time\n}\n\n// tzsetRule parses a rule from a tzset string.\n// It returns the rule, and the remainder of the string, and reports success.\nfunc tzsetRule(s string) (rule, string, bool) {\n\tvar r rule\n\tif len(s) == 0 {\n\t\treturn rule{}, \"\", false\n\t}\n\tok := false\n\tif s[0] == 'J' {\n\t\tvar jday int\n\t\tjday, s, ok = tzsetNum(s[1:], 1, 365)\n\t\tif !ok {\n\t\t\treturn rule{}, \"\", false\n\t\t}\n\t\tr.kind = ruleJulian\n\t\tr.day = jday\n\t} else if s[0] == 'M' {\n\t\tvar mon int\n\t\tmon, s, ok = tzsetNum(s[1:], 1, 12)\n\t\tif !ok || len(s) == 0 || s[0] != '.' {\n\t\t\treturn rule{}, \"\", false\n\n\t\t}\n\t\tvar week int\n\t\tweek, s, ok = tzsetNum(s[1:], 1, 5)\n\t\tif !ok || len(s) == 0 || s[0] != '.' {\n\t\t\treturn rule{}, \"\", false\n\t\t}\n\t\tvar day int\n\t\tday, s, ok = tzsetNum(s[1:], 0, 6)\n\t\tif !ok {\n\t\t\treturn rule{}, \"\", false\n\t\t}\n\t\tr.kind = ruleMonthWeekDay\n\t\tr.day = day\n\t\tr.week = week\n\t\tr.mon = mon\n\t} else {\n\t\tvar day int\n\t\tday, s, ok = tzsetNum(s, 0, 365)\n\t\tif !ok {\n\t\t\treturn rule{}, \"\", false\n\t\t}\n\t\tr.kind = ruleDOY\n\t\tr.day = day\n\t}\n\n\tif len(s) == 0 || s[0] != '/' {\n\t\tr.time = 2 * secondsPerHour // 2am is the default\n\t\treturn r, s, true\n\t}\n\n\toffset, s, ok := tzsetOffset(s[1:])\n\tif !ok {\n\t\treturn rule{}, \"\", false\n\t}\n\tr.time = offset\n\n\treturn r, s, true\n}\n\n// tzsetNum parses a number from a tzset string.\n// It returns the number, and the remainder of the string, and reports success.\n// The number must be between min and max.\nfunc tzsetNum(s string, min, max int) (num int, rest string, ok bool) {\n\tif len(s) == 0 {\n\t\treturn 0, \"\", false\n\t}\n\tnum = 0\n\tfor i, r := range s {\n\t\tif r < '0' || r > '9' {\n\t\t\tif i == 0 || num < min {\n\t\t\t\treturn 0, \"\", false\n\t\t\t}\n\t\t\treturn num, s[i:], true\n\t\t}\n\t\tnum *= 10\n\t\tnum += int(r) - '0'\n\t\tif num > max {\n\t\t\treturn 0, \"\", false\n\t\t}\n\t}\n\tif num < min {\n\t\treturn 0, \"\", false\n\t}\n\treturn num, \"\", true\n}\n\n// tzruleTime takes a year, a rule, and a timezone offset,\n// and returns the number of seconds since the start of the year\n// that the rule takes effect.\nfunc tzruleTime(year int, r rule, off int) int {\n\tvar s int\n\tswitch r.kind {\n\tcase ruleJulian:\n\t\ts = (r.day - 1) * secondsPerDay\n\t\tif isLeap(year) && r.day >= 60 {\n\t\t\ts += secondsPerDay\n\t\t}\n\tcase ruleDOY:\n\t\ts = r.day * secondsPerDay\n\tcase ruleMonthWeekDay:\n\t\t// Zeller's Congruence.\n\t\tm1 := (r.mon+9)%12 + 1\n\t\tyy0 := year\n\t\tif r.mon <= 2 {\n\t\t\tyy0--\n\t\t}\n\t\tyy1 := yy0 / 100\n\t\tyy2 := yy0 % 100\n\t\tdow := ((26*m1-2)/10 + 1 + yy2 + yy2/4 + yy1/4 - 2*yy1) % 7\n\t\tif dow < 0 {\n\t\t\tdow += 7\n\t\t}\n\t\t// Now dow is the day-of-week of the first day of r.mon.\n\t\t// Get the day-of-month of the first \"dow\" day.\n\t\td := r.day - dow\n\t\tif d < 0 {\n\t\t\td += 7\n\t\t}\n\t\tfor i := 1; i < r.week; i++ {\n\t\t\tif d+7 >= daysIn(Month(r.mon), year) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\td += 7\n\t\t}\n\t\td += int(daysBefore[r.mon-1])\n\t\tif isLeap(year) && r.mon > 2 {\n\t\t\td++\n\t\t}\n\t\ts = d * secondsPerDay\n\t}\n\n\treturn s + r.time - off\n}\n\n// lookupName returns information about the time zone with\n// the given name (such as \"EST\") at the given pseudo-Unix time\n// (what the given time of day would be in UTC).\nfunc (l *Location) lookupName(name string, unix int64) (offset int, ok bool) {\n\tl = l.get()\n\n\t// First try for a zone with the right name that was actually\n\t// in effect at the given time. (In Sydney, Australia, both standard\n\t// and daylight-savings time are abbreviated \"EST\". Using the\n\t// offset helps us pick the right one for the given time.\n\t// It's not perfect: during the backward transition we might pick\n\t// either one.)\n\tfor i := range l.zone {\n\t\tzone := &l.zone[i]\n\t\tif zone.name == name {\n\t\t\tnam, offset, _, _, _ := l.lookup(unix - int64(zone.offset))\n\t\t\tif nam == zone.name {\n\t\t\t\treturn offset, true\n\t\t\t}\n\t\t}\n\t}\n\n\t// Otherwise fall back to an ordinary name match.\n\tfor i := range l.zone {\n\t\tzone := &l.zone[i]\n\t\tif zone.name == name {\n\t\t\treturn zone.offset, true\n\t\t}\n\t}\n\n\t// Otherwise, give up.\n\treturn\n}\n\n// NOTE(rsc): Eventually we will need to accept the POSIX TZ environment\n// syntax too, but I don't feel like implementing it today.\n\nvar errLocation = errors.New(\"time: invalid location name\")\n\nvar zoneinfo *string\nvar zoneinfoOnce sync.Once\n\n// LoadLocation returns the Location with the given name.\n//\n// If the name is \"\" or \"UTC\", LoadLocation returns UTC.\n// If the name is \"Local\", LoadLocation returns Local.\n//\n// Otherwise, the name is taken to be a location name corresponding to a file\n// in the IANA Time Zone database, such as \"America/New_York\".\n//\n// The time zone database needed by LoadLocation may not be\n// present on all systems, especially non-Unix systems.\n// LoadLocation looks in the directory or uncompressed zip file\n// named by the ZONEINFO environment variable, if any, then looks in\n// known installation locations on Unix systems,\n// and finally looks in $GOROOT/lib/time/zoneinfo.zip.\nfunc LoadLocation(name string) (*Location, error) {\n\tif name == \"\" || name == \"UTC\" {\n\t\treturn UTC, nil\n\t}\n\tif name == \"Local\" {\n\t\treturn Local, nil\n\t}\n\tif containsDotDot(name) || name[0] == '/' || name[0] == '\\\\' {\n\t\t// No valid IANA Time Zone name contains a single dot,\n\t\t// much less dot dot. Likewise, none begin with a slash.\n\t\treturn nil, errLocation\n\t}\n\tzoneinfoOnce.Do(func() {\n\t\tenv, _ := syscall.Getenv(\"ZONEINFO\")\n\t\tzoneinfo = &env\n\t})\n\tvar firstErr error\n\tif *zoneinfo != \"\" {\n\t\tif zoneData, err := loadTzinfoFromDirOrZip(*zoneinfo, name); err == nil {\n\t\t\tif z, err := LoadLocationFromTZData(name, zoneData); err == nil {\n\t\t\t\treturn z, nil\n\t\t\t}\n\t\t\tfirstErr = err\n\t\t} else if err != syscall.ENOENT {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\tif z, err := loadLocation(name, zoneSources); err == nil {\n\t\treturn z, nil\n\t} else if firstErr == nil {\n\t\tfirstErr = err\n\t}\n\treturn nil, firstErr\n}\n\n// containsDotDot reports whether s contains \"..\".\nfunc containsDotDot(s string) bool {\n\tif len(s) < 2 {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(s)-1; i++ {\n\t\tif s[i] == '.' && s[i+1] == '.' {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n","// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package context defines the Context type, which carries deadlines,\n// cancellation signals, and other request-scoped values across API boundaries\n// and between processes.\n//\n// Incoming requests to a server should create a Context, and outgoing\n// calls to servers should accept a Context. The chain of function\n// calls between them must propagate the Context, optionally replacing\n// it with a derived Context created using WithCancel, WithDeadline,\n// WithTimeout, or WithValue. When a Context is canceled, all\n// Contexts derived from it are also canceled.\n//\n// The WithCancel, WithDeadline, and WithTimeout functions take a\n// Context (the parent) and return a derived Context (the child) and a\n// CancelFunc. Calling the CancelFunc cancels the child and its\n// children, removes the parent's reference to the child, and stops\n// any associated timers. Failing to call the CancelFunc leaks the\n// child and its children until the parent is canceled or the timer\n// fires. The go vet tool checks that CancelFuncs are used on all\n// control-flow paths.\n//\n// Programs that use Contexts should follow these rules to keep interfaces\n// consistent across packages and enable static analysis tools to check context\n// propagation:\n//\n// Do not store Contexts inside a struct type; instead, pass a Context\n// explicitly to each function that needs it. The Context should be the first\n// parameter, typically named ctx:\n//\n// \tfunc DoSomething(ctx context.Context, arg Arg) error {\n// \t\t// ... use ctx ...\n// \t}\n//\n// Do not pass a nil Context, even if a function permits it. Pass context.TODO\n// if you are unsure about which Context to use.\n//\n// Use context Values only for request-scoped data that transits processes and\n// APIs, not for passing optional parameters to functions.\n//\n// The same Context may be passed to functions running in different goroutines;\n// Contexts are safe for simultaneous use by multiple goroutines.\n//\n// See https://blog.golang.org/context for example code for a server that uses\n// Contexts.\npackage context\n\nimport (\n\t\"errors\"\n\t\"internal/reflectlite\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// A Context carries a deadline, a cancellation signal, and other values across\n// API boundaries.\n//\n// Context's methods may be called by multiple goroutines simultaneously.\ntype Context interface {\n\t// Deadline returns the time when work done on behalf of this context\n\t// should be canceled. Deadline returns ok==false when no deadline is\n\t// set. Successive calls to Deadline return the same results.\n\tDeadline() (deadline time.Time, ok bool)\n\n\t// Done returns a channel that's closed when work done on behalf of this\n\t// context should be canceled. Done may return nil if this context can\n\t// never be canceled. Successive calls to Done return the same value.\n\t// The close of the Done channel may happen asynchronously,\n\t// after the cancel function returns.\n\t//\n\t// WithCancel arranges for Done to be closed when cancel is called;\n\t// WithDeadline arranges for Done to be closed when the deadline\n\t// expires; WithTimeout arranges for Done to be closed when the timeout\n\t// elapses.\n\t//\n\t// Done is provided for use in select statements:\n\t//\n\t//  // Stream generates values with DoSomething and sends them to out\n\t//  // until DoSomething returns an error or ctx.Done is closed.\n\t//  func Stream(ctx context.Context, out chan<- Value) error {\n\t//  \tfor {\n\t//  \t\tv, err := DoSomething(ctx)\n\t//  \t\tif err != nil {\n\t//  \t\t\treturn err\n\t//  \t\t}\n\t//  \t\tselect {\n\t//  \t\tcase <-ctx.Done():\n\t//  \t\t\treturn ctx.Err()\n\t//  \t\tcase out <- v:\n\t//  \t\t}\n\t//  \t}\n\t//  }\n\t//\n\t// See https://blog.golang.org/pipelines for more examples of how to use\n\t// a Done channel for cancellation.\n\tDone() <-chan struct{}\n\n\t// If Done is not yet closed, Err returns nil.\n\t// If Done is closed, Err returns a non-nil error explaining why:\n\t// Canceled if the context was canceled\n\t// or DeadlineExceeded if the context's deadline passed.\n\t// After Err returns a non-nil error, successive calls to Err return the same error.\n\tErr() error\n\n\t// Value returns the value associated with this context for key, or nil\n\t// if no value is associated with key. Successive calls to Value with\n\t// the same key returns the same result.\n\t//\n\t// Use context values only for request-scoped data that transits\n\t// processes and API boundaries, not for passing optional parameters to\n\t// functions.\n\t//\n\t// A key identifies a specific value in a Context. Functions that wish\n\t// to store values in Context typically allocate a key in a global\n\t// variable then use that key as the argument to context.WithValue and\n\t// Context.Value. A key can be any type that supports equality;\n\t// packages should define keys as an unexported type to avoid\n\t// collisions.\n\t//\n\t// Packages that define a Context key should provide type-safe accessors\n\t// for the values stored using that key:\n\t//\n\t// \t// Package user defines a User type that's stored in Contexts.\n\t// \tpackage user\n\t//\n\t// \timport \"context\"\n\t//\n\t// \t// User is the type of value stored in the Contexts.\n\t// \ttype User struct {...}\n\t//\n\t// \t// key is an unexported type for keys defined in this package.\n\t// \t// This prevents collisions with keys defined in other packages.\n\t// \ttype key int\n\t//\n\t// \t// userKey is the key for user.User values in Contexts. It is\n\t// \t// unexported; clients use user.NewContext and user.FromContext\n\t// \t// instead of using this key directly.\n\t// \tvar userKey key\n\t//\n\t// \t// NewContext returns a new Context that carries value u.\n\t// \tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t// \t\treturn context.WithValue(ctx, userKey, u)\n\t// \t}\n\t//\n\t// \t// FromContext returns the User value stored in ctx, if any.\n\t// \tfunc FromContext(ctx context.Context) (*User, bool) {\n\t// \t\tu, ok := ctx.Value(userKey).(*User)\n\t// \t\treturn u, ok\n\t// \t}\n\tValue(key interface{}) interface{}\n}\n\n// Canceled is the error returned by Context.Err when the context is canceled.\nvar Canceled = errors.New(\"context canceled\")\n\n// DeadlineExceeded is the error returned by Context.Err when the context's\n// deadline passes.\nvar DeadlineExceeded error = deadlineExceededError{}\n\ntype deadlineExceededError struct{}\n\nfunc (deadlineExceededError) Error() string   { return \"context deadline exceeded\" }\nfunc (deadlineExceededError) Timeout() bool   { return true }\nfunc (deadlineExceededError) Temporary() bool { return true }\n\n// An emptyCtx is never canceled, has no values, and has no deadline. It is not\n// struct{}, since vars of this type must have distinct addresses.\ntype emptyCtx int\n\nfunc (*emptyCtx) Deadline() (deadline time.Time, ok bool) {\n\treturn\n}\n\nfunc (*emptyCtx) Done() <-chan struct{} {\n\treturn nil\n}\n\nfunc (*emptyCtx) Err() error {\n\treturn nil\n}\n\nfunc (*emptyCtx) Value(key interface{}) interface{} {\n\treturn nil\n}\n\nfunc (e *emptyCtx) String() string {\n\tswitch e {\n\tcase background:\n\t\treturn \"context.Background\"\n\tcase todo:\n\t\treturn \"context.TODO\"\n\t}\n\treturn \"unknown empty Context\"\n}\n\nvar (\n\tbackground = new(emptyCtx)\n\ttodo       = new(emptyCtx)\n)\n\n// Background returns a non-nil, empty Context. It is never canceled, has no\n// values, and has no deadline. It is typically used by the main function,\n// initialization, and tests, and as the top-level Context for incoming\n// requests.\nfunc Background() Context {\n\treturn background\n}\n\n// TODO returns a non-nil, empty Context. Code should use context.TODO when\n// it's unclear which Context to use or it is not yet available (because the\n// surrounding function has not yet been extended to accept a Context\n// parameter).\nfunc TODO() Context {\n\treturn todo\n}\n\n// A CancelFunc tells an operation to abandon its work.\n// A CancelFunc does not wait for the work to stop.\n// A CancelFunc may be called by multiple goroutines simultaneously.\n// After the first call, subsequent calls to a CancelFunc do nothing.\ntype CancelFunc func()\n\n// WithCancel returns a copy of parent with a new Done channel. The returned\n// context's Done channel is closed when the returned cancel function is called\n// or when the parent context's Done channel is closed, whichever happens first.\n//\n// Canceling this context releases resources associated with it, so code should\n// call cancel as soon as the operations running in this Context complete.\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) {\n\tif parent == nil {\n\t\tpanic(\"cannot create context from nil parent\")\n\t}\n\tc := newCancelCtx(parent)\n\tpropagateCancel(parent, &c)\n\treturn &c, func() { c.cancel(true, Canceled) }\n}\n\n// newCancelCtx returns an initialized cancelCtx.\nfunc newCancelCtx(parent Context) cancelCtx {\n\treturn cancelCtx{Context: parent}\n}\n\n// goroutines counts the number of goroutines ever created; for testing.\nvar goroutines int32\n\n// propagateCancel arranges for child to be canceled when parent is.\nfunc propagateCancel(parent Context, child canceler) {\n\tdone := parent.Done()\n\tif done == nil {\n\t\treturn // parent is never canceled\n\t}\n\n\tselect {\n\tcase <-done:\n\t\t// parent is already canceled\n\t\tchild.cancel(false, parent.Err())\n\t\treturn\n\tdefault:\n\t}\n\n\tif p, ok := parentCancelCtx(parent); ok {\n\t\tp.mu.Lock()\n\t\tif p.err != nil {\n\t\t\t// parent has already been canceled\n\t\t\tchild.cancel(false, p.err)\n\t\t} else {\n\t\t\tif p.children == nil {\n\t\t\t\tp.children = make(map[canceler]struct{})\n\t\t\t}\n\t\t\tp.children[child] = struct{}{}\n\t\t}\n\t\tp.mu.Unlock()\n\t} else {\n\t\tatomic.AddInt32(&goroutines, +1)\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-parent.Done():\n\t\t\t\tchild.cancel(false, parent.Err())\n\t\t\tcase <-child.Done():\n\t\t\t}\n\t\t}()\n\t}\n}\n\n// &cancelCtxKey is the key that a cancelCtx returns itself for.\nvar cancelCtxKey int\n\n// parentCancelCtx returns the underlying *cancelCtx for parent.\n// It does this by looking up parent.Value(&cancelCtxKey) to find\n// the innermost enclosing *cancelCtx and then checking whether\n// parent.Done() matches that *cancelCtx. (If not, the *cancelCtx\n// has been wrapped in a custom implementation providing a\n// different done channel, in which case we should not bypass it.)\nfunc parentCancelCtx(parent Context) (*cancelCtx, bool) {\n\tdone := parent.Done()\n\tif done == closedchan || done == nil {\n\t\treturn nil, false\n\t}\n\tp, ok := parent.Value(&cancelCtxKey).(*cancelCtx)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\tpdone, _ := p.done.Load().(chan struct{})\n\tif pdone != done {\n\t\treturn nil, false\n\t}\n\treturn p, true\n}\n\n// removeChild removes a context from its parent.\nfunc removeChild(parent Context, child canceler) {\n\tp, ok := parentCancelCtx(parent)\n\tif !ok {\n\t\treturn\n\t}\n\tp.mu.Lock()\n\tif p.children != nil {\n\t\tdelete(p.children, child)\n\t}\n\tp.mu.Unlock()\n}\n\n// A canceler is a context type that can be canceled directly. The\n// implementations are *cancelCtx and *timerCtx.\ntype canceler interface {\n\tcancel(removeFromParent bool, err error)\n\tDone() <-chan struct{}\n}\n\n// closedchan is a reusable closed channel.\nvar closedchan = make(chan struct{})\n\nfunc init() {\n\tclose(closedchan)\n}\n\n// A cancelCtx can be canceled. When canceled, it also cancels any children\n// that implement canceler.\ntype cancelCtx struct {\n\tContext\n\n\tmu       sync.Mutex            // protects following fields\n\tdone     atomic.Value          // of chan struct{}, created lazily, closed by first cancel call\n\tchildren map[canceler]struct{} // set to nil by the first cancel call\n\terr      error                 // set to non-nil by the first cancel call\n}\n\nfunc (c *cancelCtx) Value(key interface{}) interface{} {\n\tif key == &cancelCtxKey {\n\t\treturn c\n\t}\n\treturn c.Context.Value(key)\n}\n\nfunc (c *cancelCtx) Done() <-chan struct{} {\n\td := c.done.Load()\n\tif d != nil {\n\t\treturn d.(chan struct{})\n\t}\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\td = c.done.Load()\n\tif d == nil {\n\t\td = make(chan struct{})\n\t\tc.done.Store(d)\n\t}\n\treturn d.(chan struct{})\n}\n\nfunc (c *cancelCtx) Err() error {\n\tc.mu.Lock()\n\terr := c.err\n\tc.mu.Unlock()\n\treturn err\n}\n\ntype stringer interface {\n\tString() string\n}\n\nfunc contextName(c Context) string {\n\tif s, ok := c.(stringer); ok {\n\t\treturn s.String()\n\t}\n\treturn reflectlite.TypeOf(c).String()\n}\n\nfunc (c *cancelCtx) String() string {\n\treturn contextName(c.Context) + \".WithCancel\"\n}\n\n// cancel closes c.done, cancels each of c's children, and, if\n// removeFromParent is true, removes c from its parent's children.\nfunc (c *cancelCtx) cancel(removeFromParent bool, err error) {\n\tif err == nil {\n\t\tpanic(\"context: internal error: missing cancel error\")\n\t}\n\tc.mu.Lock()\n\tif c.err != nil {\n\t\tc.mu.Unlock()\n\t\treturn // already canceled\n\t}\n\tc.err = err\n\td, _ := c.done.Load().(chan struct{})\n\tif d == nil {\n\t\tc.done.Store(closedchan)\n\t} else {\n\t\tclose(d)\n\t}\n\tfor child := range c.children {\n\t\t// NOTE: acquiring the child's lock while holding parent's lock.\n\t\tchild.cancel(false, err)\n\t}\n\tc.children = nil\n\tc.mu.Unlock()\n\n\tif removeFromParent {\n\t\tremoveChild(c.Context, c)\n\t}\n}\n\n// WithDeadline returns a copy of the parent context with the deadline adjusted\n// to be no later than d. If the parent's deadline is already earlier than d,\n// WithDeadline(parent, d) is semantically equivalent to parent. The returned\n// context's Done channel is closed when the deadline expires, when the returned\n// cancel function is called, or when the parent context's Done channel is\n// closed, whichever happens first.\n//\n// Canceling this context releases resources associated with it, so code should\n// call cancel as soon as the operations running in this Context complete.\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {\n\tif parent == nil {\n\t\tpanic(\"cannot create context from nil parent\")\n\t}\n\tif cur, ok := parent.Deadline(); ok && cur.Before(d) {\n\t\t// The current deadline is already sooner than the new one.\n\t\treturn WithCancel(parent)\n\t}\n\tc := &timerCtx{\n\t\tcancelCtx: newCancelCtx(parent),\n\t\tdeadline:  d,\n\t}\n\tpropagateCancel(parent, c)\n\tdur := time.Until(d)\n\tif dur <= 0 {\n\t\tc.cancel(true, DeadlineExceeded) // deadline has already passed\n\t\treturn c, func() { c.cancel(false, Canceled) }\n\t}\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.err == nil {\n\t\tc.timer = time.AfterFunc(dur, func() {\n\t\t\tc.cancel(true, DeadlineExceeded)\n\t\t})\n\t}\n\treturn c, func() { c.cancel(true, Canceled) }\n}\n\n// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to\n// implement Done and Err. It implements cancel by stopping its timer then\n// delegating to cancelCtx.cancel.\ntype timerCtx struct {\n\tcancelCtx\n\ttimer *time.Timer // Under cancelCtx.mu.\n\n\tdeadline time.Time\n}\n\nfunc (c *timerCtx) Deadline() (deadline time.Time, ok bool) {\n\treturn c.deadline, true\n}\n\nfunc (c *timerCtx) String() string {\n\treturn contextName(c.cancelCtx.Context) + \".WithDeadline(\" +\n\t\tc.deadline.String() + \" [\" +\n\t\ttime.Until(c.deadline).String() + \"])\"\n}\n\nfunc (c *timerCtx) cancel(removeFromParent bool, err error) {\n\tc.cancelCtx.cancel(false, err)\n\tif removeFromParent {\n\t\t// Remove this timerCtx from its parent cancelCtx's children.\n\t\tremoveChild(c.cancelCtx.Context, c)\n\t}\n\tc.mu.Lock()\n\tif c.timer != nil {\n\t\tc.timer.Stop()\n\t\tc.timer = nil\n\t}\n\tc.mu.Unlock()\n}\n\n// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n//\n// Canceling this context releases resources associated with it, so code should\n// call cancel as soon as the operations running in this Context complete:\n//\n// \tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n// \t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n// \t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n// \t\treturn slowOperation(ctx)\n// \t}\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n\treturn WithDeadline(parent, time.Now().Add(timeout))\n}\n\n// WithValue returns a copy of parent in which the value associated with key is\n// val.\n//\n// Use context Values only for request-scoped data that transits processes and\n// APIs, not for passing optional parameters to functions.\n//\n// The provided key must be comparable and should not be of type\n// string or any other built-in type to avoid collisions between\n// packages using context. Users of WithValue should define their own\n// types for keys. To avoid allocating when assigning to an\n// interface{}, context keys often have concrete type\n// struct{}. Alternatively, exported context key variables' static\n// type should be a pointer or interface.\nfunc WithValue(parent Context, key, val interface{}) Context {\n\tif parent == nil {\n\t\tpanic(\"cannot create context from nil parent\")\n\t}\n\tif key == nil {\n\t\tpanic(\"nil key\")\n\t}\n\tif !reflectlite.TypeOf(key).Comparable() {\n\t\tpanic(\"key is not comparable\")\n\t}\n\treturn &valueCtx{parent, key, val}\n}\n\n// A valueCtx carries a key-value pair. It implements Value for that key and\n// delegates all other calls to the embedded Context.\ntype valueCtx struct {\n\tContext\n\tkey, val interface{}\n}\n\n// stringify tries a bit to stringify v, without using fmt, since we don't\n// want context depending on the unicode tables. This is only used by\n// *valueCtx.String().\nfunc stringify(v interface{}) string {\n\tswitch s := v.(type) {\n\tcase stringer:\n\t\treturn s.String()\n\tcase string:\n\t\treturn s\n\t}\n\treturn \"<not Stringer>\"\n}\n\nfunc (c *valueCtx) String() string {\n\treturn contextName(c.Context) + \".WithValue(type \" +\n\t\treflectlite.TypeOf(c.key).String() +\n\t\t\", val \" + stringify(c.val) + \")\"\n}\n\nfunc (c *valueCtx) Value(key interface{}) interface{} {\n\tif c.key == key {\n\t\treturn c.val\n\t}\n\treturn c.Context.Value(key)\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package time provides functionality for measuring and displaying time.\n//\n// The calendrical calculations always assume a Gregorian calendar, with\n// no leap seconds.\n//\n// Monotonic Clocks\n//\n// Operating systems provide both a \u201cwall clock,\u201d which is subject to\n// changes for clock synchronization, and a \u201cmonotonic clock,\u201d which is\n// not. The general rule is that the wall clock is for telling time and\n// the monotonic clock is for measuring time. Rather than split the API,\n// in this package the Time returned by time.Now contains both a wall\n// clock reading and a monotonic clock reading; later time-telling\n// operations use the wall clock reading, but later time-measuring\n// operations, specifically comparisons and subtractions, use the\n// monotonic clock reading.\n//\n// For example, this code always computes a positive elapsed time of\n// approximately 20 milliseconds, even if the wall clock is changed during\n// the operation being timed:\n//\n//\tstart := time.Now()\n//\t... operation that takes 20 milliseconds ...\n//\tt := time.Now()\n//\telapsed := t.Sub(start)\n//\n// Other idioms, such as time.Since(start), time.Until(deadline), and\n// time.Now().Before(deadline), are similarly robust against wall clock\n// resets.\n//\n// The rest of this section gives the precise details of how operations\n// use monotonic clocks, but understanding those details is not required\n// to use this package.\n//\n// The Time returned by time.Now contains a monotonic clock reading.\n// If Time t has a monotonic clock reading, t.Add adds the same duration to\n// both the wall clock and monotonic clock readings to compute the result.\n// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time\n// computations, they always strip any monotonic clock reading from their results.\n// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation\n// of the wall time, they also strip any monotonic clock reading from their results.\n// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).\n//\n// If Times t and u both contain monotonic clock readings, the operations\n// t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out\n// using the monotonic clock readings alone, ignoring the wall clock\n// readings. If either t or u contains no monotonic clock reading, these\n// operations fall back to using the wall clock readings.\n//\n// On some systems the monotonic clock will stop if the computer goes to sleep.\n// On such a system, t.Sub(u) may not accurately reflect the actual\n// time that passed between t and u.\n//\n// Because the monotonic clock reading has no meaning outside\n// the current process, the serialized forms generated by t.GobEncode,\n// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic\n// clock reading, and t.Format provides no format for it. Similarly, the\n// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,\n// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.\n// t.UnmarshalJSON, and t.UnmarshalText always create times with\n// no monotonic clock reading.\n//\n// Note that the Go == operator compares not just the time instant but\n// also the Location and the monotonic clock reading. See the\n// documentation for the Time type for a discussion of equality\n// testing for Time values.\n//\n// For debugging, the result of t.String does include the monotonic\n// clock reading if present. If t != u because of different monotonic clock readings,\n// that difference will be visible when printing t.String() and u.String().\n//\npackage time\n\nimport (\n\t\"errors\"\n\t_ \"unsafe\" // for go:linkname\n)\n\n// A Time represents an instant in time with nanosecond precision.\n//\n// Programs using times should typically store and pass them as values,\n// not pointers. That is, time variables and struct fields should be of\n// type time.Time, not *time.Time.\n//\n// A Time value can be used by multiple goroutines simultaneously except\n// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and\n// UnmarshalText are not concurrency-safe.\n//\n// Time instants can be compared using the Before, After, and Equal methods.\n// The Sub method subtracts two instants, producing a Duration.\n// The Add method adds a Time and a Duration, producing a Time.\n//\n// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.\n// As this time is unlikely to come up in practice, the IsZero method gives\n// a simple way of detecting a time that has not been initialized explicitly.\n//\n// Each Time has associated with it a Location, consulted when computing the\n// presentation form of the time, such as in the Format, Hour, and Year methods.\n// The methods Local, UTC, and In return a Time with a specific location.\n// Changing the location in this way changes only the presentation; it does not\n// change the instant in time being denoted and therefore does not affect the\n// computations described in earlier paragraphs.\n//\n// Representations of a Time value saved by the GobEncode, MarshalBinary,\n// MarshalJSON, and MarshalText methods store the Time.Location's offset, but not\n// the location name. They therefore lose information about Daylight Saving Time.\n//\n// In addition to the required \u201cwall clock\u201d reading, a Time may contain an optional\n// reading of the current process's monotonic clock, to provide additional precision\n// for comparison or subtraction.\n// See the \u201cMonotonic Clocks\u201d section in the package documentation for details.\n//\n// Note that the Go == operator compares not just the time instant but also the\n// Location and the monotonic clock reading. Therefore, Time values should not\n// be used as map or database keys without first guaranteeing that the\n// identical Location has been set for all values, which can be achieved\n// through use of the UTC or Local method, and that the monotonic clock reading\n// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)\n// to t == u, since t.Equal uses the most accurate comparison available and\n// correctly handles the case when only one of its arguments has a monotonic\n// clock reading.\n//\ntype Time struct {\n\t// wall and ext encode the wall time seconds, wall time nanoseconds,\n\t// and optional monotonic clock reading in nanoseconds.\n\t//\n\t// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),\n\t// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.\n\t// The nanoseconds field is in the range [0, 999999999].\n\t// If the hasMonotonic bit is 0, then the 33-bit field must be zero\n\t// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.\n\t// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit\n\t// unsigned wall seconds since Jan 1 year 1885, and ext holds a\n\t// signed 64-bit monotonic clock reading, nanoseconds since process start.\n\twall uint64\n\text  int64\n\n\t// loc specifies the Location that should be used to\n\t// determine the minute, hour, month, day, and year\n\t// that correspond to this Time.\n\t// The nil location means UTC.\n\t// All UTC times are represented with loc==nil, never loc==&utcLoc.\n\tloc *Location\n}\n\nconst (\n\thasMonotonic = 1 << 63\n\tmaxWall      = wallToInternal + (1<<33 - 1) // year 2157\n\tminWall      = wallToInternal               // year 1885\n\tnsecMask     = 1<<30 - 1\n\tnsecShift    = 30\n)\n\n// These helpers for manipulating the wall and monotonic clock readings\n// take pointer receivers, even when they don't modify the time,\n// to make them cheaper to call.\n\n// nsec returns the time's nanoseconds.\nfunc (t *Time) nsec() int32 {\n\treturn int32(t.wall & nsecMask)\n}\n\n// sec returns the time's seconds since Jan 1 year 1.\nfunc (t *Time) sec() int64 {\n\tif t.wall&hasMonotonic != 0 {\n\t\treturn wallToInternal + int64(t.wall<<1>>(nsecShift+1))\n\t}\n\treturn t.ext\n}\n\n// unixSec returns the time's seconds since Jan 1 1970 (Unix time).\nfunc (t *Time) unixSec() int64 { return t.sec() + internalToUnix }\n\n// addSec adds d seconds to the time.\nfunc (t *Time) addSec(d int64) {\n\tif t.wall&hasMonotonic != 0 {\n\t\tsec := int64(t.wall << 1 >> (nsecShift + 1))\n\t\tdsec := sec + d\n\t\tif 0 <= dsec && dsec <= 1<<33-1 {\n\t\t\tt.wall = t.wall&nsecMask | uint64(dsec)<<nsecShift | hasMonotonic\n\t\t\treturn\n\t\t}\n\t\t// Wall second now out of range for packed field.\n\t\t// Move to ext.\n\t\tt.stripMono()\n\t}\n\n\t// Check if the sum of t.ext and d overflows and handle it properly.\n\tsum := t.ext + d\n\tif (sum > t.ext) == (d > 0) {\n\t\tt.ext = sum\n\t} else if d > 0 {\n\t\tt.ext = 1<<63 - 1\n\t} else {\n\t\tt.ext = -(1<<63 - 1)\n\t}\n}\n\n// setLoc sets the location associated with the time.\nfunc (t *Time) setLoc(loc *Location) {\n\tif loc == &utcLoc {\n\t\tloc = nil\n\t}\n\tt.stripMono()\n\tt.loc = loc\n}\n\n// stripMono strips the monotonic clock reading in t.\nfunc (t *Time) stripMono() {\n\tif t.wall&hasMonotonic != 0 {\n\t\tt.ext = t.sec()\n\t\tt.wall &= nsecMask\n\t}\n}\n\n// setMono sets the monotonic clock reading in t.\n// If t cannot hold a monotonic clock reading,\n// because its wall time is too large,\n// setMono is a no-op.\nfunc (t *Time) setMono(m int64) {\n\tif t.wall&hasMonotonic == 0 {\n\t\tsec := t.ext\n\t\tif sec < minWall || maxWall < sec {\n\t\t\treturn\n\t\t}\n\t\tt.wall |= hasMonotonic | uint64(sec-minWall)<<nsecShift\n\t}\n\tt.ext = m\n}\n\n// mono returns t's monotonic clock reading.\n// It returns 0 for a missing reading.\n// This function is used only for testing,\n// so it's OK that technically 0 is a valid\n// monotonic clock reading as well.\nfunc (t *Time) mono() int64 {\n\tif t.wall&hasMonotonic == 0 {\n\t\treturn 0\n\t}\n\treturn t.ext\n}\n\n// After reports whether the time instant t is after u.\nfunc (t Time) After(u Time) bool {\n\tif t.wall&u.wall&hasMonotonic != 0 {\n\t\treturn t.ext > u.ext\n\t}\n\tts := t.sec()\n\tus := u.sec()\n\treturn ts > us || ts == us && t.nsec() > u.nsec()\n}\n\n// Before reports whether the time instant t is before u.\nfunc (t Time) Before(u Time) bool {\n\tif t.wall&u.wall&hasMonotonic != 0 {\n\t\treturn t.ext < u.ext\n\t}\n\tts := t.sec()\n\tus := u.sec()\n\treturn ts < us || ts == us && t.nsec() < u.nsec()\n}\n\n// Equal reports whether t and u represent the same time instant.\n// Two times can be equal even if they are in different locations.\n// For example, 6:00 +0200 and 4:00 UTC are Equal.\n// See the documentation on the Time type for the pitfalls of using == with\n// Time values; most code should use Equal instead.\nfunc (t Time) Equal(u Time) bool {\n\tif t.wall&u.wall&hasMonotonic != 0 {\n\t\treturn t.ext == u.ext\n\t}\n\treturn t.sec() == u.sec() && t.nsec() == u.nsec()\n}\n\n// A Month specifies a month of the year (January = 1, ...).\ntype Month int\n\nconst (\n\tJanuary Month = 1 + iota\n\tFebruary\n\tMarch\n\tApril\n\tMay\n\tJune\n\tJuly\n\tAugust\n\tSeptember\n\tOctober\n\tNovember\n\tDecember\n)\n\n// String returns the English name of the month (\"January\", \"February\", ...).\nfunc (m Month) String() string {\n\tif January <= m && m <= December {\n\t\treturn longMonthNames[m-1]\n\t}\n\tbuf := make([]byte, 20)\n\tn := fmtInt(buf, uint64(m))\n\treturn \"%!Month(\" + string(buf[n:]) + \")\"\n}\n\n// A Weekday specifies a day of the week (Sunday = 0, ...).\ntype Weekday int\n\nconst (\n\tSunday Weekday = iota\n\tMonday\n\tTuesday\n\tWednesday\n\tThursday\n\tFriday\n\tSaturday\n)\n\n// String returns the English name of the day (\"Sunday\", \"Monday\", ...).\nfunc (d Weekday) String() string {\n\tif Sunday <= d && d <= Saturday {\n\t\treturn longDayNames[d]\n\t}\n\tbuf := make([]byte, 20)\n\tn := fmtInt(buf, uint64(d))\n\treturn \"%!Weekday(\" + string(buf[n:]) + \")\"\n}\n\n// Computations on time.\n//\n// The zero value for a Time is defined to be\n//\tJanuary 1, year 1, 00:00:00.000000000 UTC\n// which (1) looks like a zero, or as close as you can get in a date\n// (1-1-1 00:00:00 UTC), (2) is unlikely enough to arise in practice to\n// be a suitable \"not set\" sentinel, unlike Jan 1 1970, and (3) has a\n// non-negative year even in time zones west of UTC, unlike 1-1-0\n// 00:00:00 UTC, which would be 12-31-(-1) 19:00:00 in New York.\n//\n// The zero Time value does not force a specific epoch for the time\n// representation. For example, to use the Unix epoch internally, we\n// could define that to distinguish a zero value from Jan 1 1970, that\n// time would be represented by sec=-1, nsec=1e9. However, it does\n// suggest a representation, namely using 1-1-1 00:00:00 UTC as the\n// epoch, and that's what we do.\n//\n// The Add and Sub computations are oblivious to the choice of epoch.\n//\n// The presentation computations - year, month, minute, and so on - all\n// rely heavily on division and modulus by positive constants. For\n// calendrical calculations we want these divisions to round down, even\n// for negative values, so that the remainder is always positive, but\n// Go's division (like most hardware division instructions) rounds to\n// zero. We can still do those computations and then adjust the result\n// for a negative numerator, but it's annoying to write the adjustment\n// over and over. Instead, we can change to a different epoch so long\n// ago that all the times we care about will be positive, and then round\n// to zero and round down coincide. These presentation routines already\n// have to add the zone offset, so adding the translation to the\n// alternate epoch is cheap. For example, having a non-negative time t\n// means that we can write\n//\n//\tsec = t % 60\n//\n// instead of\n//\n//\tsec = t % 60\n//\tif sec < 0 {\n//\t\tsec += 60\n//\t}\n//\n// everywhere.\n//\n// The calendar runs on an exact 400 year cycle: a 400-year calendar\n// printed for 1970-2369 will apply as well to 2370-2769. Even the days\n// of the week match up. It simplifies the computations to choose the\n// cycle boundaries so that the exceptional years are always delayed as\n// long as possible. That means choosing a year equal to 1 mod 400, so\n// that the first leap year is the 4th year, the first missed leap year\n// is the 100th year, and the missed missed leap year is the 400th year.\n// So we'd prefer instead to print a calendar for 2001-2400 and reuse it\n// for 2401-2800.\n//\n// Finally, it's convenient if the delta between the Unix epoch and\n// long-ago epoch is representable by an int64 constant.\n//\n// These three considerations\u2014choose an epoch as early as possible, that\n// uses a year equal to 1 mod 400, and that is no more than 2\u2076\u00b3 seconds\n// earlier than 1970\u2014bring us to the year -292277022399. We refer to\n// this year as the absolute zero year, and to times measured as a uint64\n// seconds since this year as absolute times.\n//\n// Times measured as an int64 seconds since the year 1\u2014the representation\n// used for Time's sec field\u2014are called internal times.\n//\n// Times measured as an int64 seconds since the year 1970 are called Unix\n// times.\n//\n// It is tempting to just use the year 1 as the absolute epoch, defining\n// that the routines are only valid for years >= 1. However, the\n// routines would then be invalid when displaying the epoch in time zones\n// west of UTC, since it is year 0. It doesn't seem tenable to say that\n// printing the zero time correctly isn't supported in half the time\n// zones. By comparison, it's reasonable to mishandle some times in\n// the year -292277022399.\n//\n// All this is opaque to clients of the API and can be changed if a\n// better implementation presents itself.\n\nconst (\n\t// The unsigned zero year for internal calculations.\n\t// Must be 1 mod 400, and times before it will not compute correctly,\n\t// but otherwise can be changed at will.\n\tabsoluteZeroYear = -292277022399\n\n\t// The year of the zero Time.\n\t// Assumed by the unixToInternal computation below.\n\tinternalYear = 1\n\n\t// Offsets to convert between internal and absolute or Unix times.\n\tabsoluteToInternal int64 = (absoluteZeroYear - internalYear) * 365.2425 * secondsPerDay\n\tinternalToAbsolute       = -absoluteToInternal\n\n\tunixToInternal int64 = (1969*365 + 1969/4 - 1969/100 + 1969/400) * secondsPerDay\n\tinternalToUnix int64 = -unixToInternal\n\n\twallToInternal int64 = (1884*365 + 1884/4 - 1884/100 + 1884/400) * secondsPerDay\n\tinternalToWall int64 = -wallToInternal\n)\n\n// IsZero reports whether t represents the zero time instant,\n// January 1, year 1, 00:00:00 UTC.\nfunc (t Time) IsZero() bool {\n\treturn t.sec() == 0 && t.nsec() == 0\n}\n\n// abs returns the time t as an absolute time, adjusted by the zone offset.\n// It is called when computing a presentation property like Month or Hour.\nfunc (t Time) abs() uint64 {\n\tl := t.loc\n\t// Avoid function calls when possible.\n\tif l == nil || l == &localLoc {\n\t\tl = l.get()\n\t}\n\tsec := t.unixSec()\n\tif l != &utcLoc {\n\t\tif l.cacheZone != nil && l.cacheStart <= sec && sec < l.cacheEnd {\n\t\t\tsec += int64(l.cacheZone.offset)\n\t\t} else {\n\t\t\t_, offset, _, _, _ := l.lookup(sec)\n\t\t\tsec += int64(offset)\n\t\t}\n\t}\n\treturn uint64(sec + (unixToInternal + internalToAbsolute))\n}\n\n// locabs is a combination of the Zone and abs methods,\n// extracting both return values from a single zone lookup.\nfunc (t Time) locabs() (name string, offset int, abs uint64) {\n\tl := t.loc\n\tif l == nil || l == &localLoc {\n\t\tl = l.get()\n\t}\n\t// Avoid function call if we hit the local time cache.\n\tsec := t.unixSec()\n\tif l != &utcLoc {\n\t\tif l.cacheZone != nil && l.cacheStart <= sec && sec < l.cacheEnd {\n\t\t\tname = l.cacheZone.name\n\t\t\toffset = l.cacheZone.offset\n\t\t} else {\n\t\t\tname, offset, _, _, _ = l.lookup(sec)\n\t\t}\n\t\tsec += int64(offset)\n\t} else {\n\t\tname = \"UTC\"\n\t}\n\tabs = uint64(sec + (unixToInternal + internalToAbsolute))\n\treturn\n}\n\n// Date returns the year, month, and day in which t occurs.\nfunc (t Time) Date() (year int, month Month, day int) {\n\tyear, month, day, _ = t.date(true)\n\treturn\n}\n\n// Year returns the year in which t occurs.\nfunc (t Time) Year() int {\n\tyear, _, _, _ := t.date(false)\n\treturn year\n}\n\n// Month returns the month of the year specified by t.\nfunc (t Time) Month() Month {\n\t_, month, _, _ := t.date(true)\n\treturn month\n}\n\n// Day returns the day of the month specified by t.\nfunc (t Time) Day() int {\n\t_, _, day, _ := t.date(true)\n\treturn day\n}\n\n// Weekday returns the day of the week specified by t.\nfunc (t Time) Weekday() Weekday {\n\treturn absWeekday(t.abs())\n}\n\n// absWeekday is like Weekday but operates on an absolute time.\nfunc absWeekday(abs uint64) Weekday {\n\t// January 1 of the absolute year, like January 1 of 2001, was a Monday.\n\tsec := (abs + uint64(Monday)*secondsPerDay) % secondsPerWeek\n\treturn Weekday(int(sec) / secondsPerDay)\n}\n\n// ISOWeek returns the ISO 8601 year and week number in which t occurs.\n// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to\n// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1\n// of year n+1.\nfunc (t Time) ISOWeek() (year, week int) {\n\t// According to the rule that the first calendar week of a calendar year is\n\t// the week including the first Thursday of that year, and that the last one is\n\t// the week immediately preceding the first calendar week of the next calendar year.\n\t// See https://www.iso.org/obp/ui#iso:std:iso:8601:-1:ed-1:v1:en:term:3.1.1.23 for details.\n\n\t// weeks start with Monday\n\t// Monday Tuesday Wednesday Thursday Friday Saturday Sunday\n\t// 1      2       3         4        5      6        7\n\t// +3     +2      +1        0        -1     -2       -3\n\t// the offset to Thursday\n\tabs := t.abs()\n\td := Thursday - absWeekday(abs)\n\t// handle Sunday\n\tif d == 4 {\n\t\td = -3\n\t}\n\t// find the Thursday of the calendar week\n\tabs += uint64(d) * secondsPerDay\n\tyear, _, _, yday := absDate(abs, false)\n\treturn year, yday/7 + 1\n}\n\n// Clock returns the hour, minute, and second within the day specified by t.\nfunc (t Time) Clock() (hour, min, sec int) {\n\treturn absClock(t.abs())\n}\n\n// absClock is like clock but operates on an absolute time.\nfunc absClock(abs uint64) (hour, min, sec int) {\n\tsec = int(abs % secondsPerDay)\n\thour = sec / secondsPerHour\n\tsec -= hour * secondsPerHour\n\tmin = sec / secondsPerMinute\n\tsec -= min * secondsPerMinute\n\treturn\n}\n\n// Hour returns the hour within the day specified by t, in the range [0, 23].\nfunc (t Time) Hour() int {\n\treturn int(t.abs()%secondsPerDay) / secondsPerHour\n}\n\n// Minute returns the minute offset within the hour specified by t, in the range [0, 59].\nfunc (t Time) Minute() int {\n\treturn int(t.abs()%secondsPerHour) / secondsPerMinute\n}\n\n// Second returns the second offset within the minute specified by t, in the range [0, 59].\nfunc (t Time) Second() int {\n\treturn int(t.abs() % secondsPerMinute)\n}\n\n// Nanosecond returns the nanosecond offset within the second specified by t,\n// in the range [0, 999999999].\nfunc (t Time) Nanosecond() int {\n\treturn int(t.nsec())\n}\n\n// YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,\n// and [1,366] in leap years.\nfunc (t Time) YearDay() int {\n\t_, _, _, yday := t.date(false)\n\treturn yday + 1\n}\n\n// A Duration represents the elapsed time between two instants\n// as an int64 nanosecond count. The representation limits the\n// largest representable duration to approximately 290 years.\ntype Duration int64\n\nconst (\n\tminDuration Duration = -1 << 63\n\tmaxDuration Duration = 1<<63 - 1\n)\n\n// Common durations. There is no definition for units of Day or larger\n// to avoid confusion across daylight savings time zone transitions.\n//\n// To count the number of units in a Duration, divide:\n//\tsecond := time.Second\n//\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n//\n// To convert an integer number of units to a Duration, multiply:\n//\tseconds := 10\n//\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n//\nconst (\n\tNanosecond  Duration = 1\n\tMicrosecond          = 1000 * Nanosecond\n\tMillisecond          = 1000 * Microsecond\n\tSecond               = 1000 * Millisecond\n\tMinute               = 60 * Second\n\tHour                 = 60 * Minute\n)\n\n// String returns a string representing the duration in the form \"72h3m0.5s\".\n// Leading zero units are omitted. As a special case, durations less than one\n// second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure\n// that the leading digit is non-zero. The zero duration formats as 0s.\nfunc (d Duration) String() string {\n\t// Largest time is 2540400h10m10.000000000s\n\tvar buf [32]byte\n\tw := len(buf)\n\n\tu := uint64(d)\n\tneg := d < 0\n\tif neg {\n\t\tu = -u\n\t}\n\n\tif u < uint64(Second) {\n\t\t// Special case: if duration is smaller than a second,\n\t\t// use smaller units, like 1.2ms\n\t\tvar prec int\n\t\tw--\n\t\tbuf[w] = 's'\n\t\tw--\n\t\tswitch {\n\t\tcase u == 0:\n\t\t\treturn \"0s\"\n\t\tcase u < uint64(Microsecond):\n\t\t\t// print nanoseconds\n\t\t\tprec = 0\n\t\t\tbuf[w] = 'n'\n\t\tcase u < uint64(Millisecond):\n\t\t\t// print microseconds\n\t\t\tprec = 3\n\t\t\t// U+00B5 '\u00b5' micro sign == 0xC2 0xB5\n\t\t\tw-- // Need room for two bytes.\n\t\t\tcopy(buf[w:], \"\u00b5\")\n\t\tdefault:\n\t\t\t// print milliseconds\n\t\t\tprec = 6\n\t\t\tbuf[w] = 'm'\n\t\t}\n\t\tw, u = fmtFrac(buf[:w], u, prec)\n\t\tw = fmtInt(buf[:w], u)\n\t} else {\n\t\tw--\n\t\tbuf[w] = 's'\n\n\t\tw, u = fmtFrac(buf[:w], u, 9)\n\n\t\t// u is now integer seconds\n\t\tw = fmtInt(buf[:w], u%60)\n\t\tu /= 60\n\n\t\t// u is now integer minutes\n\t\tif u > 0 {\n\t\t\tw--\n\t\t\tbuf[w] = 'm'\n\t\t\tw = fmtInt(buf[:w], u%60)\n\t\t\tu /= 60\n\n\t\t\t// u is now integer hours\n\t\t\t// Stop at hours because days can be different lengths.\n\t\t\tif u > 0 {\n\t\t\t\tw--\n\t\t\t\tbuf[w] = 'h'\n\t\t\t\tw = fmtInt(buf[:w], u)\n\t\t\t}\n\t\t}\n\t}\n\n\tif neg {\n\t\tw--\n\t\tbuf[w] = '-'\n\t}\n\n\treturn string(buf[w:])\n}\n\n// fmtFrac formats the fraction of v/10**prec (e.g., \".12345\") into the\n// tail of buf, omitting trailing zeros. It omits the decimal\n// point too when the fraction is 0. It returns the index where the\n// output bytes begin and the value v/10**prec.\nfunc fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64) {\n\t// Omit trailing zeros up to and including decimal point.\n\tw := len(buf)\n\tprint := false\n\tfor i := 0; i < prec; i++ {\n\t\tdigit := v % 10\n\t\tprint = print || digit != 0\n\t\tif print {\n\t\t\tw--\n\t\t\tbuf[w] = byte(digit) + '0'\n\t\t}\n\t\tv /= 10\n\t}\n\tif print {\n\t\tw--\n\t\tbuf[w] = '.'\n\t}\n\treturn w, v\n}\n\n// fmtInt formats v into the tail of buf.\n// It returns the index where the output begins.\nfunc fmtInt(buf []byte, v uint64) int {\n\tw := len(buf)\n\tif v == 0 {\n\t\tw--\n\t\tbuf[w] = '0'\n\t} else {\n\t\tfor v > 0 {\n\t\t\tw--\n\t\t\tbuf[w] = byte(v%10) + '0'\n\t\t\tv /= 10\n\t\t}\n\t}\n\treturn w\n}\n\n// Nanoseconds returns the duration as an integer nanosecond count.\nfunc (d Duration) Nanoseconds() int64 { return int64(d) }\n\n// Microseconds returns the duration as an integer microsecond count.\nfunc (d Duration) Microseconds() int64 { return int64(d) / 1e3 }\n\n// Milliseconds returns the duration as an integer millisecond count.\nfunc (d Duration) Milliseconds() int64 { return int64(d) / 1e6 }\n\n// These methods return float64 because the dominant\n// use case is for printing a floating point number like 1.5s, and\n// a truncation to integer would make them not useful in those cases.\n// Splitting the integer and fraction ourselves guarantees that\n// converting the returned float64 to an integer rounds the same\n// way that a pure integer conversion would have, even in cases\n// where, say, float64(d.Nanoseconds())/1e9 would have rounded\n// differently.\n\n// Seconds returns the duration as a floating point number of seconds.\nfunc (d Duration) Seconds() float64 {\n\tsec := d / Second\n\tnsec := d % Second\n\treturn float64(sec) + float64(nsec)/1e9\n}\n\n// Minutes returns the duration as a floating point number of minutes.\nfunc (d Duration) Minutes() float64 {\n\tmin := d / Minute\n\tnsec := d % Minute\n\treturn float64(min) + float64(nsec)/(60*1e9)\n}\n\n// Hours returns the duration as a floating point number of hours.\nfunc (d Duration) Hours() float64 {\n\thour := d / Hour\n\tnsec := d % Hour\n\treturn float64(hour) + float64(nsec)/(60*60*1e9)\n}\n\n// Truncate returns the result of rounding d toward zero to a multiple of m.\n// If m <= 0, Truncate returns d unchanged.\nfunc (d Duration) Truncate(m Duration) Duration {\n\tif m <= 0 {\n\t\treturn d\n\t}\n\treturn d - d%m\n}\n\n// lessThanHalf reports whether x+x < y but avoids overflow,\n// assuming x and y are both positive (Duration is signed).\nfunc lessThanHalf(x, y Duration) bool {\n\treturn uint64(x)+uint64(x) < uint64(y)\n}\n\n// Round returns the result of rounding d to the nearest multiple of m.\n// The rounding behavior for halfway values is to round away from zero.\n// If the result exceeds the maximum (or minimum)\n// value that can be stored in a Duration,\n// Round returns the maximum (or minimum) duration.\n// If m <= 0, Round returns d unchanged.\nfunc (d Duration) Round(m Duration) Duration {\n\tif m <= 0 {\n\t\treturn d\n\t}\n\tr := d % m\n\tif d < 0 {\n\t\tr = -r\n\t\tif lessThanHalf(r, m) {\n\t\t\treturn d + r\n\t\t}\n\t\tif d1 := d - m + r; d1 < d {\n\t\t\treturn d1\n\t\t}\n\t\treturn minDuration // overflow\n\t}\n\tif lessThanHalf(r, m) {\n\t\treturn d - r\n\t}\n\tif d1 := d + m - r; d1 > d {\n\t\treturn d1\n\t}\n\treturn maxDuration // overflow\n}\n\n// Add returns the time t+d.\nfunc (t Time) Add(d Duration) Time {\n\tdsec := int64(d / 1e9)\n\tnsec := t.nsec() + int32(d%1e9)\n\tif nsec >= 1e9 {\n\t\tdsec++\n\t\tnsec -= 1e9\n\t} else if nsec < 0 {\n\t\tdsec--\n\t\tnsec += 1e9\n\t}\n\tt.wall = t.wall&^nsecMask | uint64(nsec) // update nsec\n\tt.addSec(dsec)\n\tif t.wall&hasMonotonic != 0 {\n\t\tte := t.ext + int64(d)\n\t\tif d < 0 && te > t.ext || d > 0 && te < t.ext {\n\t\t\t// Monotonic clock reading now out of range; degrade to wall-only.\n\t\t\tt.stripMono()\n\t\t} else {\n\t\t\tt.ext = te\n\t\t}\n\t}\n\treturn t\n}\n\n// Sub returns the duration t-u. If the result exceeds the maximum (or minimum)\n// value that can be stored in a Duration, the maximum (or minimum) duration\n// will be returned.\n// To compute t-d for a duration d, use t.Add(-d).\nfunc (t Time) Sub(u Time) Duration {\n\tif t.wall&u.wall&hasMonotonic != 0 {\n\t\tte := t.ext\n\t\tue := u.ext\n\t\td := Duration(te - ue)\n\t\tif d < 0 && te > ue {\n\t\t\treturn maxDuration // t - u is positive out of range\n\t\t}\n\t\tif d > 0 && te < ue {\n\t\t\treturn minDuration // t - u is negative out of range\n\t\t}\n\t\treturn d\n\t}\n\td := Duration(t.sec()-u.sec())*Second + Duration(t.nsec()-u.nsec())\n\t// Check for overflow or underflow.\n\tswitch {\n\tcase u.Add(d).Equal(t):\n\t\treturn d // d is correct\n\tcase t.Before(u):\n\t\treturn minDuration // t - u is negative out of range\n\tdefault:\n\t\treturn maxDuration // t - u is positive out of range\n\t}\n}\n\n// Since returns the time elapsed since t.\n// It is shorthand for time.Now().Sub(t).\nfunc Since(t Time) Duration {\n\tvar now Time\n\tif t.wall&hasMonotonic != 0 {\n\t\t// Common case optimization: if t has monotonic time, then Sub will use only it.\n\t\tnow = Time{hasMonotonic, runtimeNano() - startNano, nil}\n\t} else {\n\t\tnow = Now()\n\t}\n\treturn now.Sub(t)\n}\n\n// Until returns the duration until t.\n// It is shorthand for t.Sub(time.Now()).\nfunc Until(t Time) Duration {\n\tvar now Time\n\tif t.wall&hasMonotonic != 0 {\n\t\t// Common case optimization: if t has monotonic time, then Sub will use only it.\n\t\tnow = Time{hasMonotonic, runtimeNano() - startNano, nil}\n\t} else {\n\t\tnow = Now()\n\t}\n\treturn t.Sub(now)\n}\n\n// AddDate returns the time corresponding to adding the\n// given number of years, months, and days to t.\n// For example, AddDate(-1, 2, 3) applied to January 1, 2011\n// returns March 4, 2010.\n//\n// AddDate normalizes its result in the same way that Date does,\n// so, for example, adding one month to October 31 yields\n// December 1, the normalized form for November 31.\nfunc (t Time) AddDate(years int, months int, days int) Time {\n\tyear, month, day := t.Date()\n\thour, min, sec := t.Clock()\n\treturn Date(year+years, month+Month(months), day+days, hour, min, sec, int(t.nsec()), t.Location())\n}\n\nconst (\n\tsecondsPerMinute = 60\n\tsecondsPerHour   = 60 * secondsPerMinute\n\tsecondsPerDay    = 24 * secondsPerHour\n\tsecondsPerWeek   = 7 * secondsPerDay\n\tdaysPer400Years  = 365*400 + 97\n\tdaysPer100Years  = 365*100 + 24\n\tdaysPer4Years    = 365*4 + 1\n)\n\n// date computes the year, day of year, and when full=true,\n// the month and day in which t occurs.\nfunc (t Time) date(full bool) (year int, month Month, day int, yday int) {\n\treturn absDate(t.abs(), full)\n}\n\n// absDate is like date but operates on an absolute time.\nfunc absDate(abs uint64, full bool) (year int, month Month, day int, yday int) {\n\t// Split into time and day.\n\td := abs / secondsPerDay\n\n\t// Account for 400 year cycles.\n\tn := d / daysPer400Years\n\ty := 400 * n\n\td -= daysPer400Years * n\n\n\t// Cut off 100-year cycles.\n\t// The last cycle has one extra leap year, so on the last day\n\t// of that year, day / daysPer100Years will be 4 instead of 3.\n\t// Cut it back down to 3 by subtracting n>>2.\n\tn = d / daysPer100Years\n\tn -= n >> 2\n\ty += 100 * n\n\td -= daysPer100Years * n\n\n\t// Cut off 4-year cycles.\n\t// The last cycle has a missing leap year, which does not\n\t// affect the computation.\n\tn = d / daysPer4Years\n\ty += 4 * n\n\td -= daysPer4Years * n\n\n\t// Cut off years within a 4-year cycle.\n\t// The last year is a leap year, so on the last day of that year,\n\t// day / 365 will be 4 instead of 3. Cut it back down to 3\n\t// by subtracting n>>2.\n\tn = d / 365\n\tn -= n >> 2\n\ty += n\n\td -= 365 * n\n\n\tyear = int(int64(y) + absoluteZeroYear)\n\tyday = int(d)\n\n\tif !full {\n\t\treturn\n\t}\n\n\tday = yday\n\tif isLeap(year) {\n\t\t// Leap year\n\t\tswitch {\n\t\tcase day > 31+29-1:\n\t\t\t// After leap day; pretend it wasn't there.\n\t\t\tday--\n\t\tcase day == 31+29-1:\n\t\t\t// Leap day.\n\t\t\tmonth = February\n\t\t\tday = 29\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Estimate month on assumption that every month has 31 days.\n\t// The estimate may be too low by at most one month, so adjust.\n\tmonth = Month(day / 31)\n\tend := int(daysBefore[month+1])\n\tvar begin int\n\tif day >= end {\n\t\tmonth++\n\t\tbegin = end\n\t} else {\n\t\tbegin = int(daysBefore[month])\n\t}\n\n\tmonth++ // because January is 1\n\tday = day - begin + 1\n\treturn\n}\n\n// daysBefore[m] counts the number of days in a non-leap year\n// before month m begins. There is an entry for m=12, counting\n// the number of days before January of next year (365).\nvar daysBefore = [...]int32{\n\t0,\n\t31,\n\t31 + 28,\n\t31 + 28 + 31,\n\t31 + 28 + 31 + 30,\n\t31 + 28 + 31 + 30 + 31,\n\t31 + 28 + 31 + 30 + 31 + 30,\n\t31 + 28 + 31 + 30 + 31 + 30 + 31,\n\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,\n\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,\n\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,\n\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,\n\t31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,\n}\n\nfunc daysIn(m Month, year int) int {\n\tif m == February && isLeap(year) {\n\t\treturn 29\n\t}\n\treturn int(daysBefore[m] - daysBefore[m-1])\n}\n\n// daysSinceEpoch takes a year and returns the number of days from\n// the absolute epoch to the start of that year.\n// This is basically (year - zeroYear) * 365, but accounting for leap days.\nfunc daysSinceEpoch(year int) uint64 {\n\ty := uint64(int64(year) - absoluteZeroYear)\n\n\t// Add in days from 400-year cycles.\n\tn := y / 400\n\ty -= 400 * n\n\td := daysPer400Years * n\n\n\t// Add in 100-year cycles.\n\tn = y / 100\n\ty -= 100 * n\n\td += daysPer100Years * n\n\n\t// Add in 4-year cycles.\n\tn = y / 4\n\ty -= 4 * n\n\td += daysPer4Years * n\n\n\t// Add in non-leap years.\n\tn = y\n\td += 365 * n\n\n\treturn d\n}\n\n// Provided by package runtime.\nfunc now() (sec int64, nsec int32, mono int64)\n\n// runtimeNano returns the current value of the runtime clock in nanoseconds.\n//go:linkname runtimeNano runtime.nanotime\nfunc runtimeNano() int64\n\n// Monotonic times are reported as offsets from startNano.\n// We initialize startNano to runtimeNano() - 1 so that on systems where\n// monotonic time resolution is fairly low (e.g. Windows 2008\n// which appears to have a default resolution of 15ms),\n// we avoid ever reporting a monotonic time of 0.\n// (Callers may want to use 0 as \"time not set\".)\nvar startNano int64 = runtimeNano() - 1\n\n// Now returns the current local time.\nfunc Now() Time {\n\tsec, nsec, mono := now()\n\tmono -= startNano\n\tsec += unixToInternal - minWall\n\tif uint64(sec)>>33 != 0 {\n\t\treturn Time{uint64(nsec), sec + minWall, Local}\n\t}\n\treturn Time{hasMonotonic | uint64(sec)<<nsecShift | uint64(nsec), mono, Local}\n}\n\nfunc unixTime(sec int64, nsec int32) Time {\n\treturn Time{uint64(nsec), sec + unixToInternal, Local}\n}\n\n// UTC returns t with the location set to UTC.\nfunc (t Time) UTC() Time {\n\tt.setLoc(&utcLoc)\n\treturn t\n}\n\n// Local returns t with the location set to local time.\nfunc (t Time) Local() Time {\n\tt.setLoc(Local)\n\treturn t\n}\n\n// In returns a copy of t representing the same time instant, but\n// with the copy's location information set to loc for display\n// purposes.\n//\n// In panics if loc is nil.\nfunc (t Time) In(loc *Location) Time {\n\tif loc == nil {\n\t\tpanic(\"time: missing Location in call to Time.In\")\n\t}\n\tt.setLoc(loc)\n\treturn t\n}\n\n// Location returns the time zone information associated with t.\nfunc (t Time) Location() *Location {\n\tl := t.loc\n\tif l == nil {\n\t\tl = UTC\n\t}\n\treturn l\n}\n\n// Zone computes the time zone in effect at time t, returning the abbreviated\n// name of the zone (such as \"CET\") and its offset in seconds east of UTC.\nfunc (t Time) Zone() (name string, offset int) {\n\tname, offset, _, _, _ = t.loc.lookup(t.unixSec())\n\treturn\n}\n\n// Unix returns t as a Unix time, the number of seconds elapsed\n// since January 1, 1970 UTC. The result does not depend on the\n// location associated with t.\n// Unix-like operating systems often record time as a 32-bit\n// count of seconds, but since the method here returns a 64-bit\n// value it is valid for billions of years into the past or future.\nfunc (t Time) Unix() int64 {\n\treturn t.unixSec()\n}\n\n// UnixMilli returns t as a Unix time, the number of milliseconds elapsed since\n// January 1, 1970 UTC. The result is undefined if the Unix time in\n// milliseconds cannot be represented by an int64 (a date more than 292 million\n// years before or after 1970). The result does not depend on the\n// location associated with t.\nfunc (t Time) UnixMilli() int64 {\n\treturn t.unixSec()*1e3 + int64(t.nsec())/1e6\n}\n\n// UnixMicro returns t as a Unix time, the number of microseconds elapsed since\n// January 1, 1970 UTC. The result is undefined if the Unix time in\n// microseconds cannot be represented by an int64 (a date before year -290307 or\n// after year 294246). The result does not depend on the location associated\n// with t.\nfunc (t Time) UnixMicro() int64 {\n\treturn t.unixSec()*1e6 + int64(t.nsec())/1e3\n}\n\n// UnixNano returns t as a Unix time, the number of nanoseconds elapsed\n// since January 1, 1970 UTC. The result is undefined if the Unix time\n// in nanoseconds cannot be represented by an int64 (a date before the year\n// 1678 or after 2262). Note that this means the result of calling UnixNano\n// on the zero Time is undefined. The result does not depend on the\n// location associated with t.\nfunc (t Time) UnixNano() int64 {\n\treturn (t.unixSec())*1e9 + int64(t.nsec())\n}\n\nconst timeBinaryVersion byte = 1\n\n// MarshalBinary implements the encoding.BinaryMarshaler interface.\nfunc (t Time) MarshalBinary() ([]byte, error) {\n\tvar offsetMin int16 // minutes east of UTC. -1 is UTC.\n\n\tif t.Location() == UTC {\n\t\toffsetMin = -1\n\t} else {\n\t\t_, offset := t.Zone()\n\t\tif offset%60 != 0 {\n\t\t\treturn nil, errors.New(\"Time.MarshalBinary: zone offset has fractional minute\")\n\t\t}\n\t\toffset /= 60\n\t\tif offset < -32768 || offset == -1 || offset > 32767 {\n\t\t\treturn nil, errors.New(\"Time.MarshalBinary: unexpected zone offset\")\n\t\t}\n\t\toffsetMin = int16(offset)\n\t}\n\n\tsec := t.sec()\n\tnsec := t.nsec()\n\tenc := []byte{\n\t\ttimeBinaryVersion, // byte 0 : version\n\t\tbyte(sec >> 56),   // bytes 1-8: seconds\n\t\tbyte(sec >> 48),\n\t\tbyte(sec >> 40),\n\t\tbyte(sec >> 32),\n\t\tbyte(sec >> 24),\n\t\tbyte(sec >> 16),\n\t\tbyte(sec >> 8),\n\t\tbyte(sec),\n\t\tbyte(nsec >> 24), // bytes 9-12: nanoseconds\n\t\tbyte(nsec >> 16),\n\t\tbyte(nsec >> 8),\n\t\tbyte(nsec),\n\t\tbyte(offsetMin >> 8), // bytes 13-14: zone offset in minutes\n\t\tbyte(offsetMin),\n\t}\n\n\treturn enc, nil\n}\n\n// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\nfunc (t *Time) UnmarshalBinary(data []byte) error {\n\tbuf := data\n\tif len(buf) == 0 {\n\t\treturn errors.New(\"Time.UnmarshalBinary: no data\")\n\t}\n\n\tif buf[0] != timeBinaryVersion {\n\t\treturn errors.New(\"Time.UnmarshalBinary: unsupported version\")\n\t}\n\n\tif len(buf) != /*version*/ 1+ /*sec*/ 8+ /*nsec*/ 4+ /*zone offset*/ 2 {\n\t\treturn errors.New(\"Time.UnmarshalBinary: invalid length\")\n\t}\n\n\tbuf = buf[1:]\n\tsec := int64(buf[7]) | int64(buf[6])<<8 | int64(buf[5])<<16 | int64(buf[4])<<24 |\n\t\tint64(buf[3])<<32 | int64(buf[2])<<40 | int64(buf[1])<<48 | int64(buf[0])<<56\n\n\tbuf = buf[8:]\n\tnsec := int32(buf[3]) | int32(buf[2])<<8 | int32(buf[1])<<16 | int32(buf[0])<<24\n\n\tbuf = buf[4:]\n\toffset := int(int16(buf[1])|int16(buf[0])<<8) * 60\n\n\t*t = Time{}\n\tt.wall = uint64(nsec)\n\tt.ext = sec\n\n\tif offset == -1*60 {\n\t\tt.setLoc(&utcLoc)\n\t} else if _, localoff, _, _, _ := Local.lookup(t.unixSec()); offset == localoff {\n\t\tt.setLoc(Local)\n\t} else {\n\t\tt.setLoc(FixedZone(\"\", offset))\n\t}\n\n\treturn nil\n}\n\n// TODO(rsc): Remove GobEncoder, GobDecoder, MarshalJSON, UnmarshalJSON in Go 2.\n// The same semantics will be provided by the generic MarshalBinary, MarshalText,\n// UnmarshalBinary, UnmarshalText.\n\n// GobEncode implements the gob.GobEncoder interface.\nfunc (t Time) GobEncode() ([]byte, error) {\n\treturn t.MarshalBinary()\n}\n\n// GobDecode implements the gob.GobDecoder interface.\nfunc (t *Time) GobDecode(data []byte) error {\n\treturn t.UnmarshalBinary(data)\n}\n\n// MarshalJSON implements the json.Marshaler interface.\n// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.\nfunc (t Time) MarshalJSON() ([]byte, error) {\n\tif y := t.Year(); y < 0 || y >= 10000 {\n\t\t// RFC 3339 is clear that years are 4 digits exactly.\n\t\t// See golang.org/issue/4556#c15 for more discussion.\n\t\treturn nil, errors.New(\"Time.MarshalJSON: year outside of range [0,9999]\")\n\t}\n\n\tb := make([]byte, 0, len(RFC3339Nano)+2)\n\tb = append(b, '\"')\n\tb = t.AppendFormat(b, RFC3339Nano)\n\tb = append(b, '\"')\n\treturn b, nil\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\n// The time is expected to be a quoted string in RFC 3339 format.\nfunc (t *Time) UnmarshalJSON(data []byte) error {\n\t// Ignore null, like in the main JSON package.\n\tif string(data) == \"null\" {\n\t\treturn nil\n\t}\n\t// Fractional seconds are handled implicitly by Parse.\n\tvar err error\n\t*t, err = Parse(`\"`+RFC3339+`\"`, string(data))\n\treturn err\n}\n\n// MarshalText implements the encoding.TextMarshaler interface.\n// The time is formatted in RFC 3339 format, with sub-second precision added if present.\nfunc (t Time) MarshalText() ([]byte, error) {\n\tif y := t.Year(); y < 0 || y >= 10000 {\n\t\treturn nil, errors.New(\"Time.MarshalText: year outside of range [0,9999]\")\n\t}\n\n\tb := make([]byte, 0, len(RFC3339Nano))\n\treturn t.AppendFormat(b, RFC3339Nano), nil\n}\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface.\n// The time is expected to be in RFC 3339 format.\nfunc (t *Time) UnmarshalText(data []byte) error {\n\t// Fractional seconds are handled implicitly by Parse.\n\tvar err error\n\t*t, err = Parse(RFC3339, string(data))\n\treturn err\n}\n\n// Unix returns the local Time corresponding to the given Unix time,\n// sec seconds and nsec nanoseconds since January 1, 1970 UTC.\n// It is valid to pass nsec outside the range [0, 999999999].\n// Not all sec values have a corresponding time value. One such\n// value is 1<<63-1 (the largest int64 value).\nfunc Unix(sec int64, nsec int64) Time {\n\tif nsec < 0 || nsec >= 1e9 {\n\t\tn := nsec / 1e9\n\t\tsec += n\n\t\tnsec -= n * 1e9\n\t\tif nsec < 0 {\n\t\t\tnsec += 1e9\n\t\t\tsec--\n\t\t}\n\t}\n\treturn unixTime(sec, int32(nsec))\n}\n\n// UnixMilli returns the local Time corresponding to the given Unix time,\n// msec milliseconds since January 1, 1970 UTC.\nfunc UnixMilli(msec int64) Time {\n\treturn Unix(msec/1e3, (msec%1e3)*1e6)\n}\n\n// UnixMicro returns the local Time corresponding to the given Unix time,\n// usec microseconds since January 1, 1970 UTC.\nfunc UnixMicro(usec int64) Time {\n\treturn Unix(usec/1e6, (usec%1e6)*1e3)\n}\n\n// IsDST reports whether the time in the configured location is in Daylight Savings Time.\nfunc (t Time) IsDST() bool {\n\t_, _, _, _, isDST := t.loc.lookup(t.Unix())\n\treturn isDST\n}\n\nfunc isLeap(year int) bool {\n\treturn year%4 == 0 && (year%100 != 0 || year%400 == 0)\n}\n\n// norm returns nhi, nlo such that\n//\thi * base + lo == nhi * base + nlo\n//\t0 <= nlo < base\nfunc norm(hi, lo, base int) (nhi, nlo int) {\n\tif lo < 0 {\n\t\tn := (-lo-1)/base + 1\n\t\thi -= n\n\t\tlo += n * base\n\t}\n\tif lo >= base {\n\t\tn := lo / base\n\t\thi += n\n\t\tlo -= n * base\n\t}\n\treturn hi, lo\n}\n\n// Date returns the Time corresponding to\n//\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\n// in the appropriate zone for that time in the given location.\n//\n// The month, day, hour, min, sec, and nsec values may be outside\n// their usual ranges and will be normalized during the conversion.\n// For example, October 32 converts to November 1.\n//\n// A daylight savings time transition skips or repeats times.\n// For example, in the United States, March 13, 2011 2:15am never occurred,\n// while November 6, 2011 1:15am occurred twice. In such cases, the\n// choice of time zone, and therefore the time, is not well-defined.\n// Date returns a time that is correct in one of the two zones involved\n// in the transition, but it does not guarantee which.\n//\n// Date panics if loc is nil.\nfunc Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {\n\tif loc == nil {\n\t\tpanic(\"time: missing Location in call to Date\")\n\t}\n\n\t// Normalize month, overflowing into year.\n\tm := int(month) - 1\n\tyear, m = norm(year, m, 12)\n\tmonth = Month(m) + 1\n\n\t// Normalize nsec, sec, min, hour, overflowing into day.\n\tsec, nsec = norm(sec, nsec, 1e9)\n\tmin, sec = norm(min, sec, 60)\n\thour, min = norm(hour, min, 60)\n\tday, hour = norm(day, hour, 24)\n\n\t// Compute days since the absolute epoch.\n\td := daysSinceEpoch(year)\n\n\t// Add in days before this month.\n\td += uint64(daysBefore[month-1])\n\tif isLeap(year) && month >= March {\n\t\td++ // February 29\n\t}\n\n\t// Add in days before today.\n\td += uint64(day - 1)\n\n\t// Add in time elapsed today.\n\tabs := d * secondsPerDay\n\tabs += uint64(hour*secondsPerHour + min*secondsPerMinute + sec)\n\n\tunix := int64(abs) + (absoluteToInternal + internalToUnix)\n\n\t// Look for zone offset for t, so we can adjust to UTC.\n\t// The lookup function expects UTC, so we pass t in the\n\t// hope that it will not be too close to a zone transition,\n\t// and then adjust if it is.\n\t_, offset, start, end, _ := loc.lookup(unix)\n\tif offset != 0 {\n\t\tswitch utc := unix - int64(offset); {\n\t\tcase utc < start:\n\t\t\t_, offset, _, _, _ = loc.lookup(start - 1)\n\t\tcase utc >= end:\n\t\t\t_, offset, _, _, _ = loc.lookup(end)\n\t\t}\n\t\tunix -= int64(offset)\n\t}\n\n\tt := unixTime(unix, int32(nsec))\n\tt.setLoc(loc)\n\treturn t\n}\n\n// Truncate returns the result of rounding t down to a multiple of d (since the zero time).\n// If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.\n//\n// Truncate operates on the time as an absolute duration since the\n// zero time; it does not operate on the presentation form of the\n// time. Thus, Truncate(Hour) may return a time with a non-zero\n// minute, depending on the time's Location.\nfunc (t Time) Truncate(d Duration) Time {\n\tt.stripMono()\n\tif d <= 0 {\n\t\treturn t\n\t}\n\t_, r := div(t, d)\n\treturn t.Add(-r)\n}\n\n// Round returns the result of rounding t to the nearest multiple of d (since the zero time).\n// The rounding behavior for halfway values is to round up.\n// If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.\n//\n// Round operates on the time as an absolute duration since the\n// zero time; it does not operate on the presentation form of the\n// time. Thus, Round(Hour) may return a time with a non-zero\n// minute, depending on the time's Location.\nfunc (t Time) Round(d Duration) Time {\n\tt.stripMono()\n\tif d <= 0 {\n\t\treturn t\n\t}\n\t_, r := div(t, d)\n\tif lessThanHalf(r, d) {\n\t\treturn t.Add(-r)\n\t}\n\treturn t.Add(d - r)\n}\n\n// div divides t by d and returns the quotient parity and remainder.\n// We don't use the quotient parity anymore (round half up instead of round to even)\n// but it's still here in case we change our minds.\nfunc div(t Time, d Duration) (qmod2 int, r Duration) {\n\tneg := false\n\tnsec := t.nsec()\n\tsec := t.sec()\n\tif sec < 0 {\n\t\t// Operate on absolute value.\n\t\tneg = true\n\t\tsec = -sec\n\t\tnsec = -nsec\n\t\tif nsec < 0 {\n\t\t\tnsec += 1e9\n\t\t\tsec-- // sec >= 1 before the -- so safe\n\t\t}\n\t}\n\n\tswitch {\n\t// Special case: 2d divides 1 second.\n\tcase d < Second && Second%(d+d) == 0:\n\t\tqmod2 = int(nsec/int32(d)) & 1\n\t\tr = Duration(nsec % int32(d))\n\n\t// Special case: d is a multiple of 1 second.\n\tcase d%Second == 0:\n\t\td1 := int64(d / Second)\n\t\tqmod2 = int(sec/d1) & 1\n\t\tr = Duration(sec%d1)*Second + Duration(nsec)\n\n\t// General case.\n\t// This could be faster if more cleverness were applied,\n\t// but it's really only here to avoid special case restrictions in the API.\n\t// No one will care about these cases.\n\tdefault:\n\t\t// Compute nanoseconds as 128-bit number.\n\t\tsec := uint64(sec)\n\t\ttmp := (sec >> 32) * 1e9\n\t\tu1 := tmp >> 32\n\t\tu0 := tmp << 32\n\t\ttmp = (sec & 0xFFFFFFFF) * 1e9\n\t\tu0x, u0 := u0, u0+tmp\n\t\tif u0 < u0x {\n\t\t\tu1++\n\t\t}\n\t\tu0x, u0 = u0, u0+uint64(nsec)\n\t\tif u0 < u0x {\n\t\t\tu1++\n\t\t}\n\n\t\t// Compute remainder by subtracting r<<k for decreasing k.\n\t\t// Quotient parity is whether we subtract on last round.\n\t\td1 := uint64(d)\n\t\tfor d1>>63 != 1 {\n\t\t\td1 <<= 1\n\t\t}\n\t\td0 := uint64(0)\n\t\tfor {\n\t\t\tqmod2 = 0\n\t\t\tif u1 > d1 || u1 == d1 && u0 >= d0 {\n\t\t\t\t// subtract\n\t\t\t\tqmod2 = 1\n\t\t\t\tu0x, u0 = u0, u0-d0\n\t\t\t\tif u0 > u0x {\n\t\t\t\t\tu1--\n\t\t\t\t}\n\t\t\t\tu1 -= d1\n\t\t\t}\n\t\t\tif d1 == 0 && d0 == uint64(d) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\td0 >>= 1\n\t\t\td0 |= (d1 & 1) << 63\n\t\t\td1 >>= 1\n\t\t}\n\t\tr = Duration(u0)\n\t}\n\n\tif neg && r != 0 {\n\t\t// If input was negative and not an exact multiple of d, we computed q, r such that\n\t\t//\tq*d + r = -t\n\t\t// But the right answers are given by -(q-1), d-r:\n\t\t//\tq*d + r = -t\n\t\t//\t-q*d - r = t\n\t\t//\t-(q-1)*d + (d - r) = t\n\t\tqmod2 ^= 1\n\t\tr = d - r\n\t}\n\treturn\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage bytes\n\n// Simple byte buffer for marshaling data.\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"unicode/utf8\"\n)\n\n// smallBufferSize is an initial allocation minimal capacity.\nconst smallBufferSize = 64\n\n// A Buffer is a variable-sized buffer of bytes with Read and Write methods.\n// The zero value for Buffer is an empty buffer ready to use.\ntype Buffer struct {\n\tbuf      []byte // contents are the bytes buf[off : len(buf)]\n\toff      int    // read at &buf[off], write at &buf[len(buf)]\n\tlastRead readOp // last read operation, so that Unread* can work correctly.\n}\n\n// The readOp constants describe the last action performed on\n// the buffer, so that UnreadRune and UnreadByte can check for\n// invalid usage. opReadRuneX constants are chosen such that\n// converted to int they correspond to the rune size that was read.\ntype readOp int8\n\n// Don't use iota for these, as the values need to correspond with the\n// names and comments, which is easier to see when being explicit.\nconst (\n\topRead      readOp = -1 // Any other read operation.\n\topInvalid   readOp = 0  // Non-read operation.\n\topReadRune1 readOp = 1  // Read rune of size 1.\n\topReadRune2 readOp = 2  // Read rune of size 2.\n\topReadRune3 readOp = 3  // Read rune of size 3.\n\topReadRune4 readOp = 4  // Read rune of size 4.\n)\n\n// ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.\nvar ErrTooLarge = errors.New(\"bytes.Buffer: too large\")\nvar errNegativeRead = errors.New(\"bytes.Buffer: reader returned negative count from Read\")\n\nconst maxInt = int(^uint(0) >> 1)\n\n// Bytes returns a slice of length b.Len() holding the unread portion of the buffer.\n// The slice is valid for use only until the next buffer modification (that is,\n// only until the next call to a method like Read, Write, Reset, or Truncate).\n// The slice aliases the buffer content at least until the next buffer modification,\n// so immediate changes to the slice will affect the result of future reads.\nfunc (b *Buffer) Bytes() []byte { return b.buf[b.off:] }\n\n// String returns the contents of the unread portion of the buffer\n// as a string. If the Buffer is a nil pointer, it returns \"<nil>\".\n//\n// To build strings more efficiently, see the strings.Builder type.\nfunc (b *Buffer) String() string {\n\tif b == nil {\n\t\t// Special case, useful in debugging.\n\t\treturn \"<nil>\"\n\t}\n\treturn string(b.buf[b.off:])\n}\n\n// empty reports whether the unread portion of the buffer is empty.\nfunc (b *Buffer) empty() bool { return len(b.buf) <= b.off }\n\n// Len returns the number of bytes of the unread portion of the buffer;\n// b.Len() == len(b.Bytes()).\nfunc (b *Buffer) Len() int { return len(b.buf) - b.off }\n\n// Cap returns the capacity of the buffer's underlying byte slice, that is, the\n// total space allocated for the buffer's data.\nfunc (b *Buffer) Cap() int { return cap(b.buf) }\n\n// Truncate discards all but the first n unread bytes from the buffer\n// but continues to use the same allocated storage.\n// It panics if n is negative or greater than the length of the buffer.\nfunc (b *Buffer) Truncate(n int) {\n\tif n == 0 {\n\t\tb.Reset()\n\t\treturn\n\t}\n\tb.lastRead = opInvalid\n\tif n < 0 || n > b.Len() {\n\t\tpanic(\"bytes.Buffer: truncation out of range\")\n\t}\n\tb.buf = b.buf[:b.off+n]\n}\n\n// Reset resets the buffer to be empty,\n// but it retains the underlying storage for use by future writes.\n// Reset is the same as Truncate(0).\nfunc (b *Buffer) Reset() {\n\tb.buf = b.buf[:0]\n\tb.off = 0\n\tb.lastRead = opInvalid\n}\n\n// tryGrowByReslice is a inlineable version of grow for the fast-case where the\n// internal buffer only needs to be resliced.\n// It returns the index where bytes should be written and whether it succeeded.\nfunc (b *Buffer) tryGrowByReslice(n int) (int, bool) {\n\tif l := len(b.buf); n <= cap(b.buf)-l {\n\t\tb.buf = b.buf[:l+n]\n\t\treturn l, true\n\t}\n\treturn 0, false\n}\n\n// grow grows the buffer to guarantee space for n more bytes.\n// It returns the index where bytes should be written.\n// If the buffer can't grow it will panic with ErrTooLarge.\nfunc (b *Buffer) grow(n int) int {\n\tm := b.Len()\n\t// If buffer is empty, reset to recover space.\n\tif m == 0 && b.off != 0 {\n\t\tb.Reset()\n\t}\n\t// Try to grow by means of a reslice.\n\tif i, ok := b.tryGrowByReslice(n); ok {\n\t\treturn i\n\t}\n\tif b.buf == nil && n <= smallBufferSize {\n\t\tb.buf = make([]byte, n, smallBufferSize)\n\t\treturn 0\n\t}\n\tc := cap(b.buf)\n\tif n <= c/2-m {\n\t\t// We can slide things down instead of allocating a new\n\t\t// slice. We only need m+n <= c to slide, but\n\t\t// we instead let capacity get twice as large so we\n\t\t// don't spend all our time copying.\n\t\tcopy(b.buf, b.buf[b.off:])\n\t} else if c > maxInt-c-n {\n\t\tpanic(ErrTooLarge)\n\t} else {\n\t\t// Not enough space anywhere, we need to allocate.\n\t\tbuf := makeSlice(2*c + n)\n\t\tcopy(buf, b.buf[b.off:])\n\t\tb.buf = buf\n\t}\n\t// Restore b.off and len(b.buf).\n\tb.off = 0\n\tb.buf = b.buf[:m+n]\n\treturn m\n}\n\n// Grow grows the buffer's capacity, if necessary, to guarantee space for\n// another n bytes. After Grow(n), at least n bytes can be written to the\n// buffer without another allocation.\n// If n is negative, Grow will panic.\n// If the buffer can't grow it will panic with ErrTooLarge.\nfunc (b *Buffer) Grow(n int) {\n\tif n < 0 {\n\t\tpanic(\"bytes.Buffer.Grow: negative count\")\n\t}\n\tm := b.grow(n)\n\tb.buf = b.buf[:m]\n}\n\n// Write appends the contents of p to the buffer, growing the buffer as\n// needed. The return value n is the length of p; err is always nil. If the\n// buffer becomes too large, Write will panic with ErrTooLarge.\nfunc (b *Buffer) Write(p []byte) (n int, err error) {\n\tb.lastRead = opInvalid\n\tm, ok := b.tryGrowByReslice(len(p))\n\tif !ok {\n\t\tm = b.grow(len(p))\n\t}\n\treturn copy(b.buf[m:], p), nil\n}\n\n// WriteString appends the contents of s to the buffer, growing the buffer as\n// needed. The return value n is the length of s; err is always nil. If the\n// buffer becomes too large, WriteString will panic with ErrTooLarge.\nfunc (b *Buffer) WriteString(s string) (n int, err error) {\n\tb.lastRead = opInvalid\n\tm, ok := b.tryGrowByReslice(len(s))\n\tif !ok {\n\t\tm = b.grow(len(s))\n\t}\n\treturn copy(b.buf[m:], s), nil\n}\n\n// MinRead is the minimum slice size passed to a Read call by\n// Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond\n// what is required to hold the contents of r, ReadFrom will not grow the\n// underlying buffer.\nconst MinRead = 512\n\n// ReadFrom reads data from r until EOF and appends it to the buffer, growing\n// the buffer as needed. The return value n is the number of bytes read. Any\n// error except io.EOF encountered during the read is also returned. If the\n// buffer becomes too large, ReadFrom will panic with ErrTooLarge.\nfunc (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) {\n\tb.lastRead = opInvalid\n\tfor {\n\t\ti := b.grow(MinRead)\n\t\tb.buf = b.buf[:i]\n\t\tm, e := r.Read(b.buf[i:cap(b.buf)])\n\t\tif m < 0 {\n\t\t\tpanic(errNegativeRead)\n\t\t}\n\n\t\tb.buf = b.buf[:i+m]\n\t\tn += int64(m)\n\t\tif e == io.EOF {\n\t\t\treturn n, nil // e is EOF, so return nil explicitly\n\t\t}\n\t\tif e != nil {\n\t\t\treturn n, e\n\t\t}\n\t}\n}\n\n// makeSlice allocates a slice of size n. If the allocation fails, it panics\n// with ErrTooLarge.\nfunc makeSlice(n int) []byte {\n\t// If the make fails, give a known error.\n\tdefer func() {\n\t\tif recover() != nil {\n\t\t\tpanic(ErrTooLarge)\n\t\t}\n\t}()\n\treturn make([]byte, n)\n}\n\n// WriteTo writes data to w until the buffer is drained or an error occurs.\n// The return value n is the number of bytes written; it always fits into an\n// int, but it is int64 to match the io.WriterTo interface. Any error\n// encountered during the write is also returned.\nfunc (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n\tb.lastRead = opInvalid\n\tif nBytes := b.Len(); nBytes > 0 {\n\t\tm, e := w.Write(b.buf[b.off:])\n\t\tif m > nBytes {\n\t\t\tpanic(\"bytes.Buffer.WriteTo: invalid Write count\")\n\t\t}\n\t\tb.off += m\n\t\tn = int64(m)\n\t\tif e != nil {\n\t\t\treturn n, e\n\t\t}\n\t\t// all bytes should have been written, by definition of\n\t\t// Write method in io.Writer\n\t\tif m != nBytes {\n\t\t\treturn n, io.ErrShortWrite\n\t\t}\n\t}\n\t// Buffer is now empty; reset.\n\tb.Reset()\n\treturn n, nil\n}\n\n// WriteByte appends the byte c to the buffer, growing the buffer as needed.\n// The returned error is always nil, but is included to match bufio.Writer's\n// WriteByte. If the buffer becomes too large, WriteByte will panic with\n// ErrTooLarge.\nfunc (b *Buffer) WriteByte(c byte) error {\n\tb.lastRead = opInvalid\n\tm, ok := b.tryGrowByReslice(1)\n\tif !ok {\n\t\tm = b.grow(1)\n\t}\n\tb.buf[m] = c\n\treturn nil\n}\n\n// WriteRune appends the UTF-8 encoding of Unicode code point r to the\n// buffer, returning its length and an error, which is always nil but is\n// included to match bufio.Writer's WriteRune. The buffer is grown as needed;\n// if it becomes too large, WriteRune will panic with ErrTooLarge.\nfunc (b *Buffer) WriteRune(r rune) (n int, err error) {\n\t// Compare as uint32 to correctly handle negative runes.\n\tif uint32(r) < utf8.RuneSelf {\n\t\tb.WriteByte(byte(r))\n\t\treturn 1, nil\n\t}\n\tb.lastRead = opInvalid\n\tm, ok := b.tryGrowByReslice(utf8.UTFMax)\n\tif !ok {\n\t\tm = b.grow(utf8.UTFMax)\n\t}\n\tn = utf8.EncodeRune(b.buf[m:m+utf8.UTFMax], r)\n\tb.buf = b.buf[:m+n]\n\treturn n, nil\n}\n\n// Read reads the next len(p) bytes from the buffer or until the buffer\n// is drained. The return value n is the number of bytes read. If the\n// buffer has no data to return, err is io.EOF (unless len(p) is zero);\n// otherwise it is nil.\nfunc (b *Buffer) Read(p []byte) (n int, err error) {\n\tb.lastRead = opInvalid\n\tif b.empty() {\n\t\t// Buffer is empty, reset to recover space.\n\t\tb.Reset()\n\t\tif len(p) == 0 {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, io.EOF\n\t}\n\tn = copy(p, b.buf[b.off:])\n\tb.off += n\n\tif n > 0 {\n\t\tb.lastRead = opRead\n\t}\n\treturn n, nil\n}\n\n// Next returns a slice containing the next n bytes from the buffer,\n// advancing the buffer as if the bytes had been returned by Read.\n// If there are fewer than n bytes in the buffer, Next returns the entire buffer.\n// The slice is only valid until the next call to a read or write method.\nfunc (b *Buffer) Next(n int) []byte {\n\tb.lastRead = opInvalid\n\tm := b.Len()\n\tif n > m {\n\t\tn = m\n\t}\n\tdata := b.buf[b.off : b.off+n]\n\tb.off += n\n\tif n > 0 {\n\t\tb.lastRead = opRead\n\t}\n\treturn data\n}\n\n// ReadByte reads and returns the next byte from the buffer.\n// If no byte is available, it returns error io.EOF.\nfunc (b *Buffer) ReadByte() (byte, error) {\n\tif b.empty() {\n\t\t// Buffer is empty, reset to recover space.\n\t\tb.Reset()\n\t\treturn 0, io.EOF\n\t}\n\tc := b.buf[b.off]\n\tb.off++\n\tb.lastRead = opRead\n\treturn c, nil\n}\n\n// ReadRune reads and returns the next UTF-8-encoded\n// Unicode code point from the buffer.\n// If no bytes are available, the error returned is io.EOF.\n// If the bytes are an erroneous UTF-8 encoding, it\n// consumes one byte and returns U+FFFD, 1.\nfunc (b *Buffer) ReadRune() (r rune, size int, err error) {\n\tif b.empty() {\n\t\t// Buffer is empty, reset to recover space.\n\t\tb.Reset()\n\t\treturn 0, 0, io.EOF\n\t}\n\tc := b.buf[b.off]\n\tif c < utf8.RuneSelf {\n\t\tb.off++\n\t\tb.lastRead = opReadRune1\n\t\treturn rune(c), 1, nil\n\t}\n\tr, n := utf8.DecodeRune(b.buf[b.off:])\n\tb.off += n\n\tb.lastRead = readOp(n)\n\treturn r, n, nil\n}\n\n// UnreadRune unreads the last rune returned by ReadRune.\n// If the most recent read or write operation on the buffer was\n// not a successful ReadRune, UnreadRune returns an error.  (In this regard\n// it is stricter than UnreadByte, which will unread the last byte\n// from any read operation.)\nfunc (b *Buffer) UnreadRune() error {\n\tif b.lastRead <= opInvalid {\n\t\treturn errors.New(\"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune\")\n\t}\n\tif b.off >= int(b.lastRead) {\n\t\tb.off -= int(b.lastRead)\n\t}\n\tb.lastRead = opInvalid\n\treturn nil\n}\n\nvar errUnreadByte = errors.New(\"bytes.Buffer: UnreadByte: previous operation was not a successful read\")\n\n// UnreadByte unreads the last byte returned by the most recent successful\n// read operation that read at least one byte. If a write has happened since\n// the last read, if the last read returned an error, or if the read read zero\n// bytes, UnreadByte returns an error.\nfunc (b *Buffer) UnreadByte() error {\n\tif b.lastRead == opInvalid {\n\t\treturn errUnreadByte\n\t}\n\tb.lastRead = opInvalid\n\tif b.off > 0 {\n\t\tb.off--\n\t}\n\treturn nil\n}\n\n// ReadBytes reads until the first occurrence of delim in the input,\n// returning a slice containing the data up to and including the delimiter.\n// If ReadBytes encounters an error before finding a delimiter,\n// it returns the data read before the error and the error itself (often io.EOF).\n// ReadBytes returns err != nil if and only if the returned data does not end in\n// delim.\nfunc (b *Buffer) ReadBytes(delim byte) (line []byte, err error) {\n\tslice, err := b.readSlice(delim)\n\t// return a copy of slice. The buffer's backing array may\n\t// be overwritten by later calls.\n\tline = append(line, slice...)\n\treturn line, err\n}\n\n// readSlice is like ReadBytes but returns a reference to internal buffer data.\nfunc (b *Buffer) readSlice(delim byte) (line []byte, err error) {\n\ti := IndexByte(b.buf[b.off:], delim)\n\tend := b.off + i + 1\n\tif i < 0 {\n\t\tend = len(b.buf)\n\t\terr = io.EOF\n\t}\n\tline = b.buf[b.off:end]\n\tb.off = end\n\tb.lastRead = opRead\n\treturn line, err\n}\n\n// ReadString reads until the first occurrence of delim in the input,\n// returning a string containing the data up to and including the delimiter.\n// If ReadString encounters an error before finding a delimiter,\n// it returns the data read before the error and the error itself (often io.EOF).\n// ReadString returns err != nil if and only if the returned data does not end\n// in delim.\nfunc (b *Buffer) ReadString(delim byte) (line string, err error) {\n\tslice, err := b.readSlice(delim)\n\treturn string(slice), err\n}\n\n// NewBuffer creates and initializes a new Buffer using buf as its\n// initial contents. The new Buffer takes ownership of buf, and the\n// caller should not use buf after this call. NewBuffer is intended to\n// prepare a Buffer to read existing data. It can also be used to set\n// the initial size of the internal buffer for writing. To do that,\n// buf should have the desired capacity but a length of zero.\n//\n// In most cases, new(Buffer) (or just declaring a Buffer variable) is\n// sufficient to initialize a Buffer.\nfunc NewBuffer(buf []byte) *Buffer { return &Buffer{buf: buf} }\n\n// NewBufferString creates and initializes a new Buffer using string s as its\n// initial contents. It is intended to prepare a buffer to read an existing\n// string.\n//\n// In most cases, new(Buffer) (or just declaring a Buffer variable) is\n// sufficient to initialize a Buffer.\nfunc NewBufferString(s string) *Buffer {\n\treturn &Buffer{buf: []byte(s)}\n}\n","// Code generated by \"stringer -type=opcode,MessageType,StatusCode -output=stringer.go\"; DO NOT EDIT.\n\npackage websocket\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[opContinuation-0]\n\t_ = x[opText-1]\n\t_ = x[opBinary-2]\n\t_ = x[opClose-8]\n\t_ = x[opPing-9]\n\t_ = x[opPong-10]\n}\n\nconst (\n\t_opcode_name_0 = \"opContinuationopTextopBinary\"\n\t_opcode_name_1 = \"opCloseopPingopPong\"\n)\n\nvar (\n\t_opcode_index_0 = [...]uint8{0, 14, 20, 28}\n\t_opcode_index_1 = [...]uint8{0, 7, 13, 19}\n)\n\nfunc (i opcode) String() string {\n\tswitch {\n\tcase 0 <= i && i <= 2:\n\t\treturn _opcode_name_0[_opcode_index_0[i]:_opcode_index_0[i+1]]\n\tcase 8 <= i && i <= 10:\n\t\ti -= 8\n\t\treturn _opcode_name_1[_opcode_index_1[i]:_opcode_index_1[i+1]]\n\tdefault:\n\t\treturn \"opcode(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[MessageText-1]\n\t_ = x[MessageBinary-2]\n}\n\nconst _MessageType_name = \"MessageTextMessageBinary\"\n\nvar _MessageType_index = [...]uint8{0, 11, 24}\n\nfunc (i MessageType) String() string {\n\ti -= 1\n\tif i < 0 || i >= MessageType(len(_MessageType_index)-1) {\n\t\treturn \"MessageType(\" + strconv.FormatInt(int64(i+1), 10) + \")\"\n\t}\n\treturn _MessageType_name[_MessageType_index[i]:_MessageType_index[i+1]]\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[StatusNormalClosure-1000]\n\t_ = x[StatusGoingAway-1001]\n\t_ = x[StatusProtocolError-1002]\n\t_ = x[StatusUnsupportedData-1003]\n\t_ = x[statusReserved-1004]\n\t_ = x[StatusNoStatusRcvd-1005]\n\t_ = x[StatusAbnormalClosure-1006]\n\t_ = x[StatusInvalidFramePayloadData-1007]\n\t_ = x[StatusPolicyViolation-1008]\n\t_ = x[StatusMessageTooBig-1009]\n\t_ = x[StatusMandatoryExtension-1010]\n\t_ = x[StatusInternalError-1011]\n\t_ = x[StatusServiceRestart-1012]\n\t_ = x[StatusTryAgainLater-1013]\n\t_ = x[StatusBadGateway-1014]\n\t_ = x[StatusTLSHandshake-1015]\n}\n\nconst _StatusCode_name = \"StatusNormalClosureStatusGoingAwayStatusProtocolErrorStatusUnsupportedDatastatusReservedStatusNoStatusRcvdStatusAbnormalClosureStatusInvalidFramePayloadDataStatusPolicyViolationStatusMessageTooBigStatusMandatoryExtensionStatusInternalErrorStatusServiceRestartStatusTryAgainLaterStatusBadGatewayStatusTLSHandshake\"\n\nvar _StatusCode_index = [...]uint16{0, 19, 34, 53, 74, 88, 106, 127, 156, 177, 196, 220, 239, 259, 278, 294, 312}\n\nfunc (i StatusCode) String() string {\n\ti -= 1000\n\tif i < 0 || i >= StatusCode(len(_StatusCode_index)-1) {\n\t\treturn \"StatusCode(\" + strconv.FormatInt(int64(i+1000), 10) + \")\"\n\t}\n\treturn _StatusCode_name[_StatusCode_index[i]:_StatusCode_index[i+1]]\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage fmt\n\nimport (\n\t\"internal/fmtsort\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n\t\"sync\"\n\t\"unicode/utf8\"\n)\n\n// Strings for use with buffer.WriteString.\n// This is less overhead than using buffer.Write with byte arrays.\nconst (\n\tcommaSpaceString  = \", \"\n\tnilAngleString    = \"<nil>\"\n\tnilParenString    = \"(nil)\"\n\tnilString         = \"nil\"\n\tmapString         = \"map[\"\n\tpercentBangString = \"%!\"\n\tmissingString     = \"(MISSING)\"\n\tbadIndexString    = \"(BADINDEX)\"\n\tpanicString       = \"(PANIC=\"\n\textraString       = \"%!(EXTRA \"\n\tbadWidthString    = \"%!(BADWIDTH)\"\n\tbadPrecString     = \"%!(BADPREC)\"\n\tnoVerbString      = \"%!(NOVERB)\"\n\tinvReflectString  = \"<invalid reflect.Value>\"\n)\n\n// State represents the printer state passed to custom formatters.\n// It provides access to the io.Writer interface plus information about\n// the flags and options for the operand's format specifier.\ntype State interface {\n\t// Write is the function to call to emit formatted output to be printed.\n\tWrite(b []byte) (n int, err error)\n\t// Width returns the value of the width option and whether it has been set.\n\tWidth() (wid int, ok bool)\n\t// Precision returns the value of the precision option and whether it has been set.\n\tPrecision() (prec int, ok bool)\n\n\t// Flag reports whether the flag c, a character, has been set.\n\tFlag(c int) bool\n}\n\n// Formatter is implemented by any value that has a Format method.\n// The implementation controls how State and rune are interpreted,\n// and may call Sprint(f) or Fprint(f) etc. to generate its output.\ntype Formatter interface {\n\tFormat(f State, verb rune)\n}\n\n// Stringer is implemented by any value that has a String method,\n// which defines the ``native'' format for that value.\n// The String method is used to print values passed as an operand\n// to any format that accepts a string or to an unformatted printer\n// such as Print.\ntype Stringer interface {\n\tString() string\n}\n\n// GoStringer is implemented by any value that has a GoString method,\n// which defines the Go syntax for that value.\n// The GoString method is used to print values passed as an operand\n// to a %#v format.\ntype GoStringer interface {\n\tGoString() string\n}\n\n// Use simple []byte instead of bytes.Buffer to avoid large dependency.\ntype buffer []byte\n\nfunc (b *buffer) write(p []byte) {\n\t*b = append(*b, p...)\n}\n\nfunc (b *buffer) writeString(s string) {\n\t*b = append(*b, s...)\n}\n\nfunc (b *buffer) writeByte(c byte) {\n\t*b = append(*b, c)\n}\n\nfunc (bp *buffer) writeRune(r rune) {\n\tif r < utf8.RuneSelf {\n\t\t*bp = append(*bp, byte(r))\n\t\treturn\n\t}\n\n\tb := *bp\n\tn := len(b)\n\tfor n+utf8.UTFMax > cap(b) {\n\t\tb = append(b, 0)\n\t}\n\tw := utf8.EncodeRune(b[n:n+utf8.UTFMax], r)\n\t*bp = b[:n+w]\n}\n\n// pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.\ntype pp struct {\n\tbuf buffer\n\n\t// arg holds the current item, as an interface{}.\n\targ interface{}\n\n\t// value is used instead of arg for reflect values.\n\tvalue reflect.Value\n\n\t// fmt is used to format basic items such as integers or strings.\n\tfmt fmt\n\n\t// reordered records whether the format string used argument reordering.\n\treordered bool\n\t// goodArgNum records whether the most recent reordering directive was valid.\n\tgoodArgNum bool\n\t// panicking is set by catchPanic to avoid infinite panic, recover, panic, ... recursion.\n\tpanicking bool\n\t// erroring is set when printing an error string to guard against calling handleMethods.\n\terroring bool\n\t// wrapErrs is set when the format string may contain a %w verb.\n\twrapErrs bool\n\t// wrappedErr records the target of the %w verb.\n\twrappedErr error\n}\n\nvar ppFree = sync.Pool{\n\tNew: func() interface{} { return new(pp) },\n}\n\n// newPrinter allocates a new pp struct or grabs a cached one.\nfunc newPrinter() *pp {\n\tp := ppFree.Get().(*pp)\n\tp.panicking = false\n\tp.erroring = false\n\tp.wrapErrs = false\n\tp.fmt.init(&p.buf)\n\treturn p\n}\n\n// free saves used pp structs in ppFree; avoids an allocation per invocation.\nfunc (p *pp) free() {\n\t// Proper usage of a sync.Pool requires each entry to have approximately\n\t// the same memory cost. To obtain this property when the stored type\n\t// contains a variably-sized buffer, we add a hard limit on the maximum buffer\n\t// to place back in the pool.\n\t//\n\t// See https://golang.org/issue/23199\n\tif cap(p.buf) > 64<<10 {\n\t\treturn\n\t}\n\n\tp.buf = p.buf[:0]\n\tp.arg = nil\n\tp.value = reflect.Value{}\n\tp.wrappedErr = nil\n\tppFree.Put(p)\n}\n\nfunc (p *pp) Width() (wid int, ok bool) { return p.fmt.wid, p.fmt.widPresent }\n\nfunc (p *pp) Precision() (prec int, ok bool) { return p.fmt.prec, p.fmt.precPresent }\n\nfunc (p *pp) Flag(b int) bool {\n\tswitch b {\n\tcase '-':\n\t\treturn p.fmt.minus\n\tcase '+':\n\t\treturn p.fmt.plus || p.fmt.plusV\n\tcase '#':\n\t\treturn p.fmt.sharp || p.fmt.sharpV\n\tcase ' ':\n\t\treturn p.fmt.space\n\tcase '0':\n\t\treturn p.fmt.zero\n\t}\n\treturn false\n}\n\n// Implement Write so we can call Fprintf on a pp (through State), for\n// recursive use in custom verbs.\nfunc (p *pp) Write(b []byte) (ret int, err error) {\n\tp.buf.write(b)\n\treturn len(b), nil\n}\n\n// Implement WriteString so that we can call io.WriteString\n// on a pp (through state), for efficiency.\nfunc (p *pp) WriteString(s string) (ret int, err error) {\n\tp.buf.writeString(s)\n\treturn len(s), nil\n}\n\n// These routines end in 'f' and take a format string.\n\n// Fprintf formats according to a format specifier and writes to w.\n// It returns the number of bytes written and any write error encountered.\nfunc Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {\n\tp := newPrinter()\n\tp.doPrintf(format, a)\n\tn, err = w.Write(p.buf)\n\tp.free()\n\treturn\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc Printf(format string, a ...interface{}) (n int, err error) {\n\treturn Fprintf(os.Stdout, format, a...)\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc Sprintf(format string, a ...interface{}) string {\n\tp := newPrinter()\n\tp.doPrintf(format, a)\n\ts := string(p.buf)\n\tp.free()\n\treturn s\n}\n\n// These routines do not take a format string\n\n// Fprint formats using the default formats for its operands and writes to w.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc Fprint(w io.Writer, a ...interface{}) (n int, err error) {\n\tp := newPrinter()\n\tp.doPrint(a)\n\tn, err = w.Write(p.buf)\n\tp.free()\n\treturn\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc Print(a ...interface{}) (n int, err error) {\n\treturn Fprint(os.Stdout, a...)\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc Sprint(a ...interface{}) string {\n\tp := newPrinter()\n\tp.doPrint(a)\n\ts := string(p.buf)\n\tp.free()\n\treturn s\n}\n\n// These routines end in 'ln', do not take a format string,\n// always add spaces between operands, and add a newline\n// after the last operand.\n\n// Fprintln formats using the default formats for its operands and writes to w.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc Fprintln(w io.Writer, a ...interface{}) (n int, err error) {\n\tp := newPrinter()\n\tp.doPrintln(a)\n\tn, err = w.Write(p.buf)\n\tp.free()\n\treturn\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc Println(a ...interface{}) (n int, err error) {\n\treturn Fprintln(os.Stdout, a...)\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc Sprintln(a ...interface{}) string {\n\tp := newPrinter()\n\tp.doPrintln(a)\n\ts := string(p.buf)\n\tp.free()\n\treturn s\n}\n\n// getField gets the i'th field of the struct value.\n// If the field is itself is an interface, return a value for\n// the thing inside the interface, not the interface itself.\nfunc getField(v reflect.Value, i int) reflect.Value {\n\tval := v.Field(i)\n\tif val.Kind() == reflect.Interface && !val.IsNil() {\n\t\tval = val.Elem()\n\t}\n\treturn val\n}\n\n// tooLarge reports whether the magnitude of the integer is\n// too large to be used as a formatting width or precision.\nfunc tooLarge(x int) bool {\n\tconst max int = 1e6\n\treturn x > max || x < -max\n}\n\n// parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no number present.\nfunc parsenum(s string, start, end int) (num int, isnum bool, newi int) {\n\tif start >= end {\n\t\treturn 0, false, end\n\t}\n\tfor newi = start; newi < end && '0' <= s[newi] && s[newi] <= '9'; newi++ {\n\t\tif tooLarge(num) {\n\t\t\treturn 0, false, end // Overflow; crazy long number most likely.\n\t\t}\n\t\tnum = num*10 + int(s[newi]-'0')\n\t\tisnum = true\n\t}\n\treturn\n}\n\nfunc (p *pp) unknownType(v reflect.Value) {\n\tif !v.IsValid() {\n\t\tp.buf.writeString(nilAngleString)\n\t\treturn\n\t}\n\tp.buf.writeByte('?')\n\tp.buf.writeString(v.Type().String())\n\tp.buf.writeByte('?')\n}\n\nfunc (p *pp) badVerb(verb rune) {\n\tp.erroring = true\n\tp.buf.writeString(percentBangString)\n\tp.buf.writeRune(verb)\n\tp.buf.writeByte('(')\n\tswitch {\n\tcase p.arg != nil:\n\t\tp.buf.writeString(reflect.TypeOf(p.arg).String())\n\t\tp.buf.writeByte('=')\n\t\tp.printArg(p.arg, 'v')\n\tcase p.value.IsValid():\n\t\tp.buf.writeString(p.value.Type().String())\n\t\tp.buf.writeByte('=')\n\t\tp.printValue(p.value, 'v', 0)\n\tdefault:\n\t\tp.buf.writeString(nilAngleString)\n\t}\n\tp.buf.writeByte(')')\n\tp.erroring = false\n}\n\nfunc (p *pp) fmtBool(v bool, verb rune) {\n\tswitch verb {\n\tcase 't', 'v':\n\t\tp.fmt.fmtBoolean(v)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\n// fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or\n// not, as requested, by temporarily setting the sharp flag.\nfunc (p *pp) fmt0x64(v uint64, leading0x bool) {\n\tsharp := p.fmt.sharp\n\tp.fmt.sharp = leading0x\n\tp.fmt.fmtInteger(v, 16, unsigned, 'v', ldigits)\n\tp.fmt.sharp = sharp\n}\n\n// fmtInteger formats a signed or unsigned integer.\nfunc (p *pp) fmtInteger(v uint64, isSigned bool, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif p.fmt.sharpV && !isSigned {\n\t\t\tp.fmt0x64(v, true)\n\t\t} else {\n\t\t\tp.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)\n\t\t}\n\tcase 'd':\n\t\tp.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)\n\tcase 'b':\n\t\tp.fmt.fmtInteger(v, 2, isSigned, verb, ldigits)\n\tcase 'o', 'O':\n\t\tp.fmt.fmtInteger(v, 8, isSigned, verb, ldigits)\n\tcase 'x':\n\t\tp.fmt.fmtInteger(v, 16, isSigned, verb, ldigits)\n\tcase 'X':\n\t\tp.fmt.fmtInteger(v, 16, isSigned, verb, udigits)\n\tcase 'c':\n\t\tp.fmt.fmtC(v)\n\tcase 'q':\n\t\tp.fmt.fmtQc(v)\n\tcase 'U':\n\t\tp.fmt.fmtUnicode(v)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\n// fmtFloat formats a float. The default precision for each verb\n// is specified as last argument in the call to fmt_float.\nfunc (p *pp) fmtFloat(v float64, size int, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tp.fmt.fmtFloat(v, size, 'g', -1)\n\tcase 'b', 'g', 'G', 'x', 'X':\n\t\tp.fmt.fmtFloat(v, size, verb, -1)\n\tcase 'f', 'e', 'E':\n\t\tp.fmt.fmtFloat(v, size, verb, 6)\n\tcase 'F':\n\t\tp.fmt.fmtFloat(v, size, 'f', 6)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\n// fmtComplex formats a complex number v with\n// r = real(v) and j = imag(v) as (r+ji) using\n// fmtFloat for r and j formatting.\nfunc (p *pp) fmtComplex(v complex128, size int, verb rune) {\n\t// Make sure any unsupported verbs are found before the\n\t// calls to fmtFloat to not generate an incorrect error string.\n\tswitch verb {\n\tcase 'v', 'b', 'g', 'G', 'x', 'X', 'f', 'F', 'e', 'E':\n\t\toldPlus := p.fmt.plus\n\t\tp.buf.writeByte('(')\n\t\tp.fmtFloat(real(v), size/2, verb)\n\t\t// Imaginary part always has a sign.\n\t\tp.fmt.plus = true\n\t\tp.fmtFloat(imag(v), size/2, verb)\n\t\tp.buf.writeString(\"i)\")\n\t\tp.fmt.plus = oldPlus\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\nfunc (p *pp) fmtString(v string, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif p.fmt.sharpV {\n\t\t\tp.fmt.fmtQ(v)\n\t\t} else {\n\t\t\tp.fmt.fmtS(v)\n\t\t}\n\tcase 's':\n\t\tp.fmt.fmtS(v)\n\tcase 'x':\n\t\tp.fmt.fmtSx(v, ldigits)\n\tcase 'X':\n\t\tp.fmt.fmtSx(v, udigits)\n\tcase 'q':\n\t\tp.fmt.fmtQ(v)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\nfunc (p *pp) fmtBytes(v []byte, verb rune, typeString string) {\n\tswitch verb {\n\tcase 'v', 'd':\n\t\tif p.fmt.sharpV {\n\t\t\tp.buf.writeString(typeString)\n\t\t\tif v == nil {\n\t\t\t\tp.buf.writeString(nilParenString)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.buf.writeByte('{')\n\t\t\tfor i, c := range v {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tp.buf.writeString(commaSpaceString)\n\t\t\t\t}\n\t\t\t\tp.fmt0x64(uint64(c), true)\n\t\t\t}\n\t\t\tp.buf.writeByte('}')\n\t\t} else {\n\t\t\tp.buf.writeByte('[')\n\t\t\tfor i, c := range v {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tp.buf.writeByte(' ')\n\t\t\t\t}\n\t\t\t\tp.fmt.fmtInteger(uint64(c), 10, unsigned, verb, ldigits)\n\t\t\t}\n\t\t\tp.buf.writeByte(']')\n\t\t}\n\tcase 's':\n\t\tp.fmt.fmtBs(v)\n\tcase 'x':\n\t\tp.fmt.fmtBx(v, ldigits)\n\tcase 'X':\n\t\tp.fmt.fmtBx(v, udigits)\n\tcase 'q':\n\t\tp.fmt.fmtQ(string(v))\n\tdefault:\n\t\tp.printValue(reflect.ValueOf(v), verb, 0)\n\t}\n}\n\nfunc (p *pp) fmtPointer(value reflect.Value, verb rune) {\n\tvar u uintptr\n\tswitch value.Kind() {\n\tcase reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:\n\t\tu = value.Pointer()\n\tdefault:\n\t\tp.badVerb(verb)\n\t\treturn\n\t}\n\n\tswitch verb {\n\tcase 'v':\n\t\tif p.fmt.sharpV {\n\t\t\tp.buf.writeByte('(')\n\t\t\tp.buf.writeString(value.Type().String())\n\t\t\tp.buf.writeString(\")(\")\n\t\t\tif u == 0 {\n\t\t\t\tp.buf.writeString(nilString)\n\t\t\t} else {\n\t\t\t\tp.fmt0x64(uint64(u), true)\n\t\t\t}\n\t\t\tp.buf.writeByte(')')\n\t\t} else {\n\t\t\tif u == 0 {\n\t\t\t\tp.fmt.padString(nilAngleString)\n\t\t\t} else {\n\t\t\t\tp.fmt0x64(uint64(u), !p.fmt.sharp)\n\t\t\t}\n\t\t}\n\tcase 'p':\n\t\tp.fmt0x64(uint64(u), !p.fmt.sharp)\n\tcase 'b', 'o', 'd', 'x', 'X':\n\t\tp.fmtInteger(uint64(u), unsigned, verb)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\nfunc (p *pp) catchPanic(arg interface{}, verb rune, method string) {\n\tif err := recover(); err != nil {\n\t\t// If it's a nil pointer, just say \"<nil>\". The likeliest causes are a\n\t\t// Stringer that fails to guard against nil or a nil pointer for a\n\t\t// value receiver, and in either case, \"<nil>\" is a nice result.\n\t\tif v := reflect.ValueOf(arg); v.Kind() == reflect.Ptr && v.IsNil() {\n\t\t\tp.buf.writeString(nilAngleString)\n\t\t\treturn\n\t\t}\n\t\t// Otherwise print a concise panic message. Most of the time the panic\n\t\t// value will print itself nicely.\n\t\tif p.panicking {\n\t\t\t// Nested panics; the recursion in printArg cannot succeed.\n\t\t\tpanic(err)\n\t\t}\n\n\t\toldFlags := p.fmt.fmtFlags\n\t\t// For this output we want default behavior.\n\t\tp.fmt.clearflags()\n\n\t\tp.buf.writeString(percentBangString)\n\t\tp.buf.writeRune(verb)\n\t\tp.buf.writeString(panicString)\n\t\tp.buf.writeString(method)\n\t\tp.buf.writeString(\" method: \")\n\t\tp.panicking = true\n\t\tp.printArg(err, 'v')\n\t\tp.panicking = false\n\t\tp.buf.writeByte(')')\n\n\t\tp.fmt.fmtFlags = oldFlags\n\t}\n}\n\nfunc (p *pp) handleMethods(verb rune) (handled bool) {\n\tif p.erroring {\n\t\treturn\n\t}\n\tif verb == 'w' {\n\t\t// It is invalid to use %w other than with Errorf, more than once,\n\t\t// or with a non-error arg.\n\t\terr, ok := p.arg.(error)\n\t\tif !ok || !p.wrapErrs || p.wrappedErr != nil {\n\t\t\tp.wrappedErr = nil\n\t\t\tp.wrapErrs = false\n\t\t\tp.badVerb(verb)\n\t\t\treturn true\n\t\t}\n\t\tp.wrappedErr = err\n\t\t// If the arg is a Formatter, pass 'v' as the verb to it.\n\t\tverb = 'v'\n\t}\n\n\t// Is it a Formatter?\n\tif formatter, ok := p.arg.(Formatter); ok {\n\t\thandled = true\n\t\tdefer p.catchPanic(p.arg, verb, \"Format\")\n\t\tformatter.Format(p, verb)\n\t\treturn\n\t}\n\n\t// If we're doing Go syntax and the argument knows how to supply it, take care of it now.\n\tif p.fmt.sharpV {\n\t\tif stringer, ok := p.arg.(GoStringer); ok {\n\t\t\thandled = true\n\t\t\tdefer p.catchPanic(p.arg, verb, \"GoString\")\n\t\t\t// Print the result of GoString unadorned.\n\t\t\tp.fmt.fmtS(stringer.GoString())\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// If a string is acceptable according to the format, see if\n\t\t// the value satisfies one of the string-valued interfaces.\n\t\t// Println etc. set verb to %v, which is \"stringable\".\n\t\tswitch verb {\n\t\tcase 'v', 's', 'x', 'X', 'q':\n\t\t\t// Is it an error or Stringer?\n\t\t\t// The duplication in the bodies is necessary:\n\t\t\t// setting handled and deferring catchPanic\n\t\t\t// must happen before calling the method.\n\t\t\tswitch v := p.arg.(type) {\n\t\t\tcase error:\n\t\t\t\thandled = true\n\t\t\t\tdefer p.catchPanic(p.arg, verb, \"Error\")\n\t\t\t\tp.fmtString(v.Error(), verb)\n\t\t\t\treturn\n\n\t\t\tcase Stringer:\n\t\t\t\thandled = true\n\t\t\t\tdefer p.catchPanic(p.arg, verb, \"String\")\n\t\t\t\tp.fmtString(v.String(), verb)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p *pp) printArg(arg interface{}, verb rune) {\n\tp.arg = arg\n\tp.value = reflect.Value{}\n\n\tif arg == nil {\n\t\tswitch verb {\n\t\tcase 'T', 'v':\n\t\t\tp.fmt.padString(nilAngleString)\n\t\tdefault:\n\t\t\tp.badVerb(verb)\n\t\t}\n\t\treturn\n\t}\n\n\t// Special processing considerations.\n\t// %T (the value's type) and %p (its address) are special; we always do them first.\n\tswitch verb {\n\tcase 'T':\n\t\tp.fmt.fmtS(reflect.TypeOf(arg).String())\n\t\treturn\n\tcase 'p':\n\t\tp.fmtPointer(reflect.ValueOf(arg), 'p')\n\t\treturn\n\t}\n\n\t// Some types can be done without reflection.\n\tswitch f := arg.(type) {\n\tcase bool:\n\t\tp.fmtBool(f, verb)\n\tcase float32:\n\t\tp.fmtFloat(float64(f), 32, verb)\n\tcase float64:\n\t\tp.fmtFloat(f, 64, verb)\n\tcase complex64:\n\t\tp.fmtComplex(complex128(f), 64, verb)\n\tcase complex128:\n\t\tp.fmtComplex(f, 128, verb)\n\tcase int:\n\t\tp.fmtInteger(uint64(f), signed, verb)\n\tcase int8:\n\t\tp.fmtInteger(uint64(f), signed, verb)\n\tcase int16:\n\t\tp.fmtInteger(uint64(f), signed, verb)\n\tcase int32:\n\t\tp.fmtInteger(uint64(f), signed, verb)\n\tcase int64:\n\t\tp.fmtInteger(uint64(f), signed, verb)\n\tcase uint:\n\t\tp.fmtInteger(uint64(f), unsigned, verb)\n\tcase uint8:\n\t\tp.fmtInteger(uint64(f), unsigned, verb)\n\tcase uint16:\n\t\tp.fmtInteger(uint64(f), unsigned, verb)\n\tcase uint32:\n\t\tp.fmtInteger(uint64(f), unsigned, verb)\n\tcase uint64:\n\t\tp.fmtInteger(f, unsigned, verb)\n\tcase uintptr:\n\t\tp.fmtInteger(uint64(f), unsigned, verb)\n\tcase string:\n\t\tp.fmtString(f, verb)\n\tcase []byte:\n\t\tp.fmtBytes(f, verb, \"[]byte\")\n\tcase reflect.Value:\n\t\t// Handle extractable values with special methods\n\t\t// since printValue does not handle them at depth 0.\n\t\tif f.IsValid() && f.CanInterface() {\n\t\t\tp.arg = f.Interface()\n\t\t\tif p.handleMethods(verb) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tp.printValue(f, verb, 0)\n\tdefault:\n\t\t// If the type is not simple, it might have methods.\n\t\tif !p.handleMethods(verb) {\n\t\t\t// Need to use reflection, since the type had no\n\t\t\t// interface methods that could be used for formatting.\n\t\t\tp.printValue(reflect.ValueOf(f), verb, 0)\n\t\t}\n\t}\n}\n\n// printValue is similar to printArg but starts with a reflect value, not an interface{} value.\n// It does not handle 'p' and 'T' verbs because these should have been already handled by printArg.\nfunc (p *pp) printValue(value reflect.Value, verb rune, depth int) {\n\t// Handle values with special methods if not already handled by printArg (depth == 0).\n\tif depth > 0 && value.IsValid() && value.CanInterface() {\n\t\tp.arg = value.Interface()\n\t\tif p.handleMethods(verb) {\n\t\t\treturn\n\t\t}\n\t}\n\tp.arg = nil\n\tp.value = value\n\n\tswitch f := value; value.Kind() {\n\tcase reflect.Invalid:\n\t\tif depth == 0 {\n\t\t\tp.buf.writeString(invReflectString)\n\t\t} else {\n\t\t\tswitch verb {\n\t\t\tcase 'v':\n\t\t\t\tp.buf.writeString(nilAngleString)\n\t\t\tdefault:\n\t\t\t\tp.badVerb(verb)\n\t\t\t}\n\t\t}\n\tcase reflect.Bool:\n\t\tp.fmtBool(f.Bool(), verb)\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp.fmtInteger(uint64(f.Int()), signed, verb)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp.fmtInteger(f.Uint(), unsigned, verb)\n\tcase reflect.Float32:\n\t\tp.fmtFloat(f.Float(), 32, verb)\n\tcase reflect.Float64:\n\t\tp.fmtFloat(f.Float(), 64, verb)\n\tcase reflect.Complex64:\n\t\tp.fmtComplex(f.Complex(), 64, verb)\n\tcase reflect.Complex128:\n\t\tp.fmtComplex(f.Complex(), 128, verb)\n\tcase reflect.String:\n\t\tp.fmtString(f.String(), verb)\n\tcase reflect.Map:\n\t\tif p.fmt.sharpV {\n\t\t\tp.buf.writeString(f.Type().String())\n\t\t\tif f.IsNil() {\n\t\t\t\tp.buf.writeString(nilParenString)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.buf.writeByte('{')\n\t\t} else {\n\t\t\tp.buf.writeString(mapString)\n\t\t}\n\t\tsorted := fmtsort.Sort(f)\n\t\tfor i, key := range sorted.Key {\n\t\t\tif i > 0 {\n\t\t\t\tif p.fmt.sharpV {\n\t\t\t\t\tp.buf.writeString(commaSpaceString)\n\t\t\t\t} else {\n\t\t\t\t\tp.buf.writeByte(' ')\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.printValue(key, verb, depth+1)\n\t\t\tp.buf.writeByte(':')\n\t\t\tp.printValue(sorted.Value[i], verb, depth+1)\n\t\t}\n\t\tif p.fmt.sharpV {\n\t\t\tp.buf.writeByte('}')\n\t\t} else {\n\t\t\tp.buf.writeByte(']')\n\t\t}\n\tcase reflect.Struct:\n\t\tif p.fmt.sharpV {\n\t\t\tp.buf.writeString(f.Type().String())\n\t\t}\n\t\tp.buf.writeByte('{')\n\t\tfor i := 0; i < f.NumField(); i++ {\n\t\t\tif i > 0 {\n\t\t\t\tif p.fmt.sharpV {\n\t\t\t\t\tp.buf.writeString(commaSpaceString)\n\t\t\t\t} else {\n\t\t\t\t\tp.buf.writeByte(' ')\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p.fmt.plusV || p.fmt.sharpV {\n\t\t\t\tif name := f.Type().Field(i).Name; name != \"\" {\n\t\t\t\t\tp.buf.writeString(name)\n\t\t\t\t\tp.buf.writeByte(':')\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.printValue(getField(f, i), verb, depth+1)\n\t\t}\n\t\tp.buf.writeByte('}')\n\tcase reflect.Interface:\n\t\tvalue := f.Elem()\n\t\tif !value.IsValid() {\n\t\t\tif p.fmt.sharpV {\n\t\t\t\tp.buf.writeString(f.Type().String())\n\t\t\t\tp.buf.writeString(nilParenString)\n\t\t\t} else {\n\t\t\t\tp.buf.writeString(nilAngleString)\n\t\t\t}\n\t\t} else {\n\t\t\tp.printValue(value, verb, depth+1)\n\t\t}\n\tcase reflect.Array, reflect.Slice:\n\t\tswitch verb {\n\t\tcase 's', 'q', 'x', 'X':\n\t\t\t// Handle byte and uint8 slices and arrays special for the above verbs.\n\t\t\tt := f.Type()\n\t\t\tif t.Elem().Kind() == reflect.Uint8 {\n\t\t\t\tvar bytes []byte\n\t\t\t\tif f.Kind() == reflect.Slice {\n\t\t\t\t\tbytes = f.Bytes()\n\t\t\t\t} else if f.CanAddr() {\n\t\t\t\t\tbytes = f.Slice(0, f.Len()).Bytes()\n\t\t\t\t} else {\n\t\t\t\t\t// We have an array, but we cannot Slice() a non-addressable array,\n\t\t\t\t\t// so we build a slice by hand. This is a rare case but it would be nice\n\t\t\t\t\t// if reflection could help a little more.\n\t\t\t\t\tbytes = make([]byte, f.Len())\n\t\t\t\t\tfor i := range bytes {\n\t\t\t\t\t\tbytes[i] = byte(f.Index(i).Uint())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.fmtBytes(bytes, verb, t.String())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif p.fmt.sharpV {\n\t\t\tp.buf.writeString(f.Type().String())\n\t\t\tif f.Kind() == reflect.Slice && f.IsNil() {\n\t\t\t\tp.buf.writeString(nilParenString)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.buf.writeByte('{')\n\t\t\tfor i := 0; i < f.Len(); i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tp.buf.writeString(commaSpaceString)\n\t\t\t\t}\n\t\t\t\tp.printValue(f.Index(i), verb, depth+1)\n\t\t\t}\n\t\t\tp.buf.writeByte('}')\n\t\t} else {\n\t\t\tp.buf.writeByte('[')\n\t\t\tfor i := 0; i < f.Len(); i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tp.buf.writeByte(' ')\n\t\t\t\t}\n\t\t\t\tp.printValue(f.Index(i), verb, depth+1)\n\t\t\t}\n\t\t\tp.buf.writeByte(']')\n\t\t}\n\tcase reflect.Ptr:\n\t\t// pointer to array or slice or struct? ok at top level\n\t\t// but not embedded (avoid loops)\n\t\tif depth == 0 && f.Pointer() != 0 {\n\t\t\tswitch a := f.Elem(); a.Kind() {\n\t\t\tcase reflect.Array, reflect.Slice, reflect.Struct, reflect.Map:\n\t\t\t\tp.buf.writeByte('&')\n\t\t\t\tp.printValue(a, verb, depth+1)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tfallthrough\n\tcase reflect.Chan, reflect.Func, reflect.UnsafePointer:\n\t\tp.fmtPointer(f, verb)\n\tdefault:\n\t\tp.unknownType(f)\n\t}\n}\n\n// intFromArg gets the argNumth element of a. On return, isInt reports whether the argument has integer type.\nfunc intFromArg(a []interface{}, argNum int) (num int, isInt bool, newArgNum int) {\n\tnewArgNum = argNum\n\tif argNum < len(a) {\n\t\tnum, isInt = a[argNum].(int) // Almost always OK.\n\t\tif !isInt {\n\t\t\t// Work harder.\n\t\t\tswitch v := reflect.ValueOf(a[argNum]); v.Kind() {\n\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\t\tn := v.Int()\n\t\t\t\tif int64(int(n)) == n {\n\t\t\t\t\tnum = int(n)\n\t\t\t\t\tisInt = true\n\t\t\t\t}\n\t\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\t\t\tn := v.Uint()\n\t\t\t\tif int64(n) >= 0 && uint64(int(n)) == n {\n\t\t\t\t\tnum = int(n)\n\t\t\t\t\tisInt = true\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// Already 0, false.\n\t\t\t}\n\t\t}\n\t\tnewArgNum = argNum + 1\n\t\tif tooLarge(num) {\n\t\t\tnum = 0\n\t\t\tisInt = false\n\t\t}\n\t}\n\treturn\n}\n\n// parseArgNumber returns the value of the bracketed number, minus 1\n// (explicit argument numbers are one-indexed but we want zero-indexed).\n// The opening bracket is known to be present at format[0].\n// The returned values are the index, the number of bytes to consume\n// up to the closing paren, if present, and whether the number parsed\n// ok. The bytes to consume will be 1 if no closing paren is present.\nfunc parseArgNumber(format string) (index int, wid int, ok bool) {\n\t// There must be at least 3 bytes: [n].\n\tif len(format) < 3 {\n\t\treturn 0, 1, false\n\t}\n\n\t// Find closing bracket.\n\tfor i := 1; i < len(format); i++ {\n\t\tif format[i] == ']' {\n\t\t\twidth, ok, newi := parsenum(format, 1, i)\n\t\t\tif !ok || newi != i {\n\t\t\t\treturn 0, i + 1, false\n\t\t\t}\n\t\t\treturn width - 1, i + 1, true // arg numbers are one-indexed and skip paren.\n\t\t}\n\t}\n\treturn 0, 1, false\n}\n\n// argNumber returns the next argument to evaluate, which is either the value of the passed-in\n// argNum or the value of the bracketed integer that begins format[i:]. It also returns\n// the new value of i, that is, the index of the next byte of the format to process.\nfunc (p *pp) argNumber(argNum int, format string, i int, numArgs int) (newArgNum, newi int, found bool) {\n\tif len(format) <= i || format[i] != '[' {\n\t\treturn argNum, i, false\n\t}\n\tp.reordered = true\n\tindex, wid, ok := parseArgNumber(format[i:])\n\tif ok && 0 <= index && index < numArgs {\n\t\treturn index, i + wid, true\n\t}\n\tp.goodArgNum = false\n\treturn argNum, i + wid, ok\n}\n\nfunc (p *pp) badArgNum(verb rune) {\n\tp.buf.writeString(percentBangString)\n\tp.buf.writeRune(verb)\n\tp.buf.writeString(badIndexString)\n}\n\nfunc (p *pp) missingArg(verb rune) {\n\tp.buf.writeString(percentBangString)\n\tp.buf.writeRune(verb)\n\tp.buf.writeString(missingString)\n}\n\nfunc (p *pp) doPrintf(format string, a []interface{}) {\n\tend := len(format)\n\targNum := 0         // we process one argument per non-trivial format\n\tafterIndex := false // previous item in format was an index like [3].\n\tp.reordered = false\nformatLoop:\n\tfor i := 0; i < end; {\n\t\tp.goodArgNum = true\n\t\tlasti := i\n\t\tfor i < end && format[i] != '%' {\n\t\t\ti++\n\t\t}\n\t\tif i > lasti {\n\t\t\tp.buf.writeString(format[lasti:i])\n\t\t}\n\t\tif i >= end {\n\t\t\t// done processing format string\n\t\t\tbreak\n\t\t}\n\n\t\t// Process one verb\n\t\ti++\n\n\t\t// Do we have flags?\n\t\tp.fmt.clearflags()\n\tsimpleFormat:\n\t\tfor ; i < end; i++ {\n\t\t\tc := format[i]\n\t\t\tswitch c {\n\t\t\tcase '#':\n\t\t\t\tp.fmt.sharp = true\n\t\t\tcase '0':\n\t\t\t\tp.fmt.zero = !p.fmt.minus // Only allow zero padding to the left.\n\t\t\tcase '+':\n\t\t\t\tp.fmt.plus = true\n\t\t\tcase '-':\n\t\t\t\tp.fmt.minus = true\n\t\t\t\tp.fmt.zero = false // Do not pad with zeros to the right.\n\t\t\tcase ' ':\n\t\t\t\tp.fmt.space = true\n\t\t\tdefault:\n\t\t\t\t// Fast path for common case of ascii lower case simple verbs\n\t\t\t\t// without precision or width or argument indices.\n\t\t\t\tif 'a' <= c && c <= 'z' && argNum < len(a) {\n\t\t\t\t\tif c == 'v' {\n\t\t\t\t\t\t// Go syntax\n\t\t\t\t\t\tp.fmt.sharpV = p.fmt.sharp\n\t\t\t\t\t\tp.fmt.sharp = false\n\t\t\t\t\t\t// Struct-field syntax\n\t\t\t\t\t\tp.fmt.plusV = p.fmt.plus\n\t\t\t\t\t\tp.fmt.plus = false\n\t\t\t\t\t}\n\t\t\t\t\tp.printArg(a[argNum], rune(c))\n\t\t\t\t\targNum++\n\t\t\t\t\ti++\n\t\t\t\t\tcontinue formatLoop\n\t\t\t\t}\n\t\t\t\t// Format is more complex than simple flags and a verb or is malformed.\n\t\t\t\tbreak simpleFormat\n\t\t\t}\n\t\t}\n\n\t\t// Do we have an explicit argument index?\n\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\n\t\t// Do we have width?\n\t\tif i < end && format[i] == '*' {\n\t\t\ti++\n\t\t\tp.fmt.wid, p.fmt.widPresent, argNum = intFromArg(a, argNum)\n\n\t\t\tif !p.fmt.widPresent {\n\t\t\t\tp.buf.writeString(badWidthString)\n\t\t\t}\n\n\t\t\t// We have a negative width, so take its value and ensure\n\t\t\t// that the minus flag is set\n\t\t\tif p.fmt.wid < 0 {\n\t\t\t\tp.fmt.wid = -p.fmt.wid\n\t\t\t\tp.fmt.minus = true\n\t\t\t\tp.fmt.zero = false // Do not pad with zeros to the right.\n\t\t\t}\n\t\t\tafterIndex = false\n\t\t} else {\n\t\t\tp.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)\n\t\t\tif afterIndex && p.fmt.widPresent { // \"%[3]2d\"\n\t\t\t\tp.goodArgNum = false\n\t\t\t}\n\t\t}\n\n\t\t// Do we have precision?\n\t\tif i+1 < end && format[i] == '.' {\n\t\t\ti++\n\t\t\tif afterIndex { // \"%[3].2d\"\n\t\t\t\tp.goodArgNum = false\n\t\t\t}\n\t\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\t\t\tif i < end && format[i] == '*' {\n\t\t\t\ti++\n\t\t\t\tp.fmt.prec, p.fmt.precPresent, argNum = intFromArg(a, argNum)\n\t\t\t\t// Negative precision arguments don't make sense\n\t\t\t\tif p.fmt.prec < 0 {\n\t\t\t\t\tp.fmt.prec = 0\n\t\t\t\t\tp.fmt.precPresent = false\n\t\t\t\t}\n\t\t\t\tif !p.fmt.precPresent {\n\t\t\t\t\tp.buf.writeString(badPrecString)\n\t\t\t\t}\n\t\t\t\tafterIndex = false\n\t\t\t} else {\n\t\t\t\tp.fmt.prec, p.fmt.precPresent, i = parsenum(format, i, end)\n\t\t\t\tif !p.fmt.precPresent {\n\t\t\t\t\tp.fmt.prec = 0\n\t\t\t\t\tp.fmt.precPresent = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !afterIndex {\n\t\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\t\t}\n\n\t\tif i >= end {\n\t\t\tp.buf.writeString(noVerbString)\n\t\t\tbreak\n\t\t}\n\n\t\tverb, size := rune(format[i]), 1\n\t\tif verb >= utf8.RuneSelf {\n\t\t\tverb, size = utf8.DecodeRuneInString(format[i:])\n\t\t}\n\t\ti += size\n\n\t\tswitch {\n\t\tcase verb == '%': // Percent does not absorb operands and ignores f.wid and f.prec.\n\t\t\tp.buf.writeByte('%')\n\t\tcase !p.goodArgNum:\n\t\t\tp.badArgNum(verb)\n\t\tcase argNum >= len(a): // No argument left over to print for the current verb.\n\t\t\tp.missingArg(verb)\n\t\tcase verb == 'v':\n\t\t\t// Go syntax\n\t\t\tp.fmt.sharpV = p.fmt.sharp\n\t\t\tp.fmt.sharp = false\n\t\t\t// Struct-field syntax\n\t\t\tp.fmt.plusV = p.fmt.plus\n\t\t\tp.fmt.plus = false\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\tp.printArg(a[argNum], verb)\n\t\t\targNum++\n\t\t}\n\t}\n\n\t// Check for extra arguments unless the call accessed the arguments\n\t// out of order, in which case it's too expensive to detect if they've all\n\t// been used and arguably OK if they're not.\n\tif !p.reordered && argNum < len(a) {\n\t\tp.fmt.clearflags()\n\t\tp.buf.writeString(extraString)\n\t\tfor i, arg := range a[argNum:] {\n\t\t\tif i > 0 {\n\t\t\t\tp.buf.writeString(commaSpaceString)\n\t\t\t}\n\t\t\tif arg == nil {\n\t\t\t\tp.buf.writeString(nilAngleString)\n\t\t\t} else {\n\t\t\t\tp.buf.writeString(reflect.TypeOf(arg).String())\n\t\t\t\tp.buf.writeByte('=')\n\t\t\t\tp.printArg(arg, 'v')\n\t\t\t}\n\t\t}\n\t\tp.buf.writeByte(')')\n\t}\n}\n\nfunc (p *pp) doPrint(a []interface{}) {\n\tprevString := false\n\tfor argNum, arg := range a {\n\t\tisString := arg != nil && reflect.TypeOf(arg).Kind() == reflect.String\n\t\t// Add a space between two non-string arguments.\n\t\tif argNum > 0 && !isString && !prevString {\n\t\t\tp.buf.writeByte(' ')\n\t\t}\n\t\tp.printArg(arg, 'v')\n\t\tprevString = isString\n\t}\n}\n\n// doPrintln is like doPrint but always adds a space between arguments\n// and a newline after the last argument.\nfunc (p *pp) doPrintln(a []interface{}) {\n\tfor argNum, arg := range a {\n\t\tif argNum > 0 {\n\t\t\tp.buf.writeByte(' ')\n\t\t}\n\t\tp.printArg(arg, 'v')\n\t}\n\tp.buf.writeByte('\\n')\n}\n","package reflectlite\n\nimport \"reflect\"\n\nfunc Swapper(slice interface{}) func(i, j int) {\n\treturn reflect.Swapper(slice)\n}\n\ntype Kind = reflect.Kind\ntype Type = reflect.Type\ntype Value = reflect.Value\n\nconst (\n\tInvalid       Kind = reflect.Invalid\n\tBool          Kind = reflect.Bool\n\tInt           Kind = reflect.Int\n\tInt8          Kind = reflect.Int8\n\tInt16         Kind = reflect.Int16\n\tInt32         Kind = reflect.Int32\n\tInt64         Kind = reflect.Int64\n\tUint          Kind = reflect.Uint\n\tUint8         Kind = reflect.Uint8\n\tUint16        Kind = reflect.Uint16\n\tUint32        Kind = reflect.Uint32\n\tUint64        Kind = reflect.Uint64\n\tUintptr       Kind = reflect.Uintptr\n\tFloat32       Kind = reflect.Float32\n\tFloat64       Kind = reflect.Float64\n\tComplex64     Kind = reflect.Complex64\n\tComplex128    Kind = reflect.Complex128\n\tArray         Kind = reflect.Array\n\tChan          Kind = reflect.Chan\n\tFunc          Kind = reflect.Func\n\tInterface     Kind = reflect.Interface\n\tMap           Kind = reflect.Map\n\tPtr           Kind = reflect.Ptr\n\tSlice         Kind = reflect.Slice\n\tString        Kind = reflect.String\n\tStruct        Kind = reflect.Struct\n\tUnsafePointer Kind = reflect.UnsafePointer\n)\n\nfunc ValueOf(i interface{}) reflect.Value {\n\treturn reflect.ValueOf(i)\n}\n\nfunc TypeOf(i interface{}) reflect.Type {\n\treturn reflect.TypeOf(i)\n}\n\ntype ValueError = reflect.ValueError\n","package runtime\n\nimport (\n\t\"unsafe\"\n)\n\n//go:generate go run ../../tools/gen-critical-atomics -out ./atomics_critical.go\n\nconst Compiler = \"tinygo\"\n\n// The compiler will fill this with calls to the initialization function of each\n// package.\nfunc initAll()\n\n//go:linkname callMain main.main\nfunc callMain()\n\nfunc GOMAXPROCS(n int) int {\n\t// Note: setting GOMAXPROCS is ignored.\n\treturn 1\n}\n\nfunc GOROOT() string {\n\t// TODO: don't hardcode but take the one at compile time.\n\treturn \"/usr/local/go\"\n}\n\n// Copy size bytes from src to dst. The memory areas must not overlap.\n// Calls to this function are converted to LLVM intrinsic calls such as\n// llvm.memcpy.p0i8.p0i8.i32(dst, src, size, false).\nfunc memcpy(dst, src unsafe.Pointer, size uintptr)\n\n// Copy size bytes from src to dst. The memory areas may overlap and will do the\n// correct thing.\n// Calls to this function are converted to LLVM intrinsic calls such as\n// llvm.memmove.p0i8.p0i8.i32(dst, src, size, false).\nfunc memmove(dst, src unsafe.Pointer, size uintptr)\n\n// Set the given number of bytes to zero.\n// Calls to this function are converted to LLVM intrinsic calls such as\n// llvm.memset.p0i8.i32(ptr, 0, size, false).\nfunc memzero(ptr unsafe.Pointer, size uintptr)\n\n// This intrinsic returns the current stack pointer.\n// It is normally used together with llvm.stackrestore but also works to get the\n// current stack pointer in a platform-independent way.\n//export llvm.stacksave\nfunc stacksave() unsafe.Pointer\n\n//export strlen\nfunc strlen(ptr unsafe.Pointer) uintptr\n\n//export malloc\nfunc malloc(size uintptr) unsafe.Pointer\n\n// Compare two same-size buffers for equality.\nfunc memequal(x, y unsafe.Pointer, n uintptr) bool {\n\tfor i := uintptr(0); i < n; i++ {\n\t\tcx := *(*uint8)(unsafe.Pointer(uintptr(x) + i))\n\t\tcy := *(*uint8)(unsafe.Pointer(uintptr(y) + i))\n\t\tif cx != cy {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc nanotime() int64 {\n\treturn ticksToNanoseconds(ticks())\n}\n\n// Copied from the Go runtime source code.\n//go:linkname os_sigpipe os.sigpipe\nfunc os_sigpipe() {\n\truntimePanic(\"too many writes on closed pipe\")\n}\n","//go:build wasm && !wasi\n// +build wasm,!wasi\n\npackage runtime\n\nimport \"unsafe\"\n\ntype timeUnit float64 // time in milliseconds, just like Date.now() in JavaScript\n\n// wasmNested is used to detect scheduler nesting (WASM calls into JS calls back into WASM).\n// When this happens, we need to use a reduced version of the scheduler.\nvar wasmNested bool\n\n//export _start\nfunc _start() {\n\t// These need to be initialized early so that the heap can be initialized.\n\theapStart = uintptr(unsafe.Pointer(&heapStartSymbol))\n\theapEnd = uintptr(wasm_memory_size(0) * wasmPageSize)\n\n\twasmNested = true\n\trun()\n\twasmNested = false\n}\n\nvar handleEvent func()\n\n//go:linkname setEventHandler syscall/js.setEventHandler\nfunc setEventHandler(fn func()) {\n\thandleEvent = fn\n}\n\nfunc ticksToNanoseconds(ticks timeUnit) int64 {\n\t// The JavaScript API works in float64 milliseconds, so convert to\n\t// nanoseconds first before converting to a timeUnit (which is a float64),\n\t// to avoid precision loss.\n\treturn int64(ticks * 1e6)\n}\n\nfunc nanosecondsToTicks(ns int64) timeUnit {\n\t// The JavaScript API works in float64 milliseconds, so convert to timeUnit\n\t// (which is a float64) first before dividing, to avoid precision loss.\n\treturn timeUnit(ns) / 1e6\n}\n\n// This function is called by the scheduler.\n// Schedule a call to runtime.scheduler, do not actually sleep.\n//export runtime.sleepTicks\nfunc sleepTicks(d timeUnit)\n\n//export runtime.ticks\nfunc ticks() timeUnit\n","//go:build !scheduler.none\n// +build !scheduler.none\n\npackage runtime\n\nimport \"internal/task\"\n\n// Pause the current task for a given time.\n//go:linkname sleep time.Sleep\nfunc sleep(duration int64) {\n\tif duration <= 0 {\n\t\treturn\n\t}\n\n\taddSleepTask(task.Current(), nanosecondsToTicks(duration))\n\ttask.Pause()\n}\n\n// run is called by the program entry point to execute the go program.\n// With a scheduler, init and the main function are invoked in a goroutine before starting the scheduler.\nfunc run() {\n\tinitHeap()\n\tgo func() {\n\t\tinitAll()\n\t\tcallMain()\n\t\tschedulerDone = true\n\t}()\n\tscheduler()\n}\n\nconst hasScheduler = true\n","package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"nhooyr.io/websocket\"\n)\n\nvar (\n\tAPIBaseURL, _ = url.Parse(\"ws://localhost:42069\")\n)\n\nfunc testFunc()\nfunc main() {\n\tfmt.Println(\"Game runtime loaded\")\n\ttestFunc()\n\t// Setup bindings for JS to call into go\n\n\t// Wait forever to keep Go runtime alive, so JS can call into Go\n\twaitChan := make(chan bool)\n\t<-waitChan\n}\n\n//export NewGame\nfunc NewGame() {\n\treqURL := *APIBaseURL\n\treqURL.Path = \"/blitz/challenge\"\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tc, _, err := websocket.Dial(ctx, reqURL.String(), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tc.Close(websocket.StatusNormalClosure, \"\")\n}\n","// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage os\n\nimport (\n\t\"errors\"\n\t\"internal/itoa\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar minrandPreviousValue uint32\nvar minrandMutex sync.Mutex\n\nfunc init() {\n\t// Avoid getting same results on every run\n\tnow := time.Now()\n\tseed := uint32(Getpid()) ^ uint32(now.Nanosecond()) ^ uint32(now.Unix())\n\t// initial state must be odd\n\tminrandPreviousValue = seed | 1\n}\n\n// minrand() is a simple and rather poor placeholder for fastrand()\n// TODO: provide fastrand in runtime, as go does.  It is hard to implement properly elsewhere.\nfunc minrand() uint32 {\n\t// c++11's minstd_rand\n\t// https://en.wikipedia.org/wiki/Linear_congruential_generator\n\t// m=2^32, c=0, a=48271\n\tminrandMutex.Lock()\n\tminrandPreviousValue *= 48271\n\tval := minrandPreviousValue\n\tminrandMutex.Unlock()\n\treturn val\n}\n\n// We generate random temporary file names so that there's a good\n// chance the file doesn't exist yet - keeps the number of tries in\n// TempFile to a minimum.\nfunc nextRandom() string {\n\t// Discard lower four bits of minrand.\n\t// They're not very random, and we don't need the full range here.\n\treturn itoa.Uitoa(uint(minrand() >> 4))\n}\n\n// CreateTemp creates a new temporary file in the directory dir,\n// opens the file for reading and writing, and returns the resulting file.\n// The filename is generated by taking pattern and adding a random string to the end.\n// If pattern includes a \"*\", the random string replaces the last \"*\".\n// If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by TempDir.\n// Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.\n// The caller can use the file's Name method to find the pathname of the file.\n// It is the caller's responsibility to remove the file when it is no longer needed.\nfunc CreateTemp(dir, pattern string) (*File, error) {\n\tif dir == \"\" {\n\t\tdir = TempDir()\n\t}\n\n\tprefix, suffix, err := prefixAndSuffix(pattern)\n\tif err != nil {\n\t\treturn nil, &PathError{Op: \"createtemp\", Path: pattern, Err: err}\n\t}\n\tprefix = joinPath(dir, prefix)\n\n\ttry := 0\n\tfor {\n\t\tname := prefix + nextRandom() + suffix\n\t\tf, err := OpenFile(name, O_RDWR|O_CREATE|O_EXCL, 0600)\n\t\tif IsExist(err) {\n\t\t\tif try++; try < 10000 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, &PathError{Op: \"createtemp\", Path: dir + string(PathSeparator) + prefix + \"*\" + suffix, Err: ErrExist}\n\t\t}\n\t\treturn f, err\n\t}\n}\n\nvar errPatternHasSeparator = errors.New(\"pattern contains path separator\")\n\n// prefixAndSuffix splits pattern by the last wildcard \"*\", if applicable,\n// returning prefix as the part before \"*\" and suffix as the part after \"*\".\nfunc prefixAndSuffix(pattern string) (prefix, suffix string, err error) {\n\tfor i := 0; i < len(pattern); i++ {\n\t\tif IsPathSeparator(pattern[i]) {\n\t\t\treturn \"\", \"\", errPatternHasSeparator\n\t\t}\n\t}\n\tif pos := lastIndex(pattern, '*'); pos != -1 {\n\t\tprefix, suffix = pattern[:pos], pattern[pos+1:]\n\t} else {\n\t\tprefix = pattern\n\t}\n\treturn prefix, suffix, nil\n}\n\n// MkdirTemp creates a new temporary directory in the directory dir\n// and returns the pathname of the new directory.\n// The new directory's name is generated by adding a random string to the end of pattern.\n// If pattern includes a \"*\", the random string replaces the last \"*\" instead.\n// If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.\n// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.\n// It is the caller's responsibility to remove the directory when it is no longer needed.\nfunc MkdirTemp(dir, pattern string) (string, error) {\n\tif dir == \"\" {\n\t\tdir = TempDir()\n\t}\n\n\tprefix, suffix, err := prefixAndSuffix(pattern)\n\tif err != nil {\n\t\treturn \"\", &PathError{Op: \"mkdirtemp\", Path: pattern, Err: err}\n\t}\n\tprefix = joinPath(dir, prefix)\n\n\ttry := 0\n\tfor {\n\t\tname := prefix + nextRandom() + suffix\n\t\terr := Mkdir(name, 0700)\n\t\tif err == nil {\n\t\t\treturn name, nil\n\t\t}\n\t\tif IsExist(err) {\n\t\t\tif try++; try < 10000 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn \"\", &PathError{Op: \"mkdirtemp\", Path: dir + string(PathSeparator) + prefix + \"*\" + suffix, Err: ErrExist}\n\t\t}\n\t\tif IsNotExist(err) {\n\t\t\tif _, err := Stat(dir); IsNotExist(err) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\treturn \"\", err\n\t}\n}\n\nfunc joinPath(dir, name string) string {\n\tif len(dir) > 0 && IsPathSeparator(dir[len(dir)-1]) {\n\t\treturn dir + name\n\t}\n\treturn dir + string(PathSeparator) + name\n}\n\n// LastIndexByte from the strings package.\nfunc lastIndex(s string, sep byte) int {\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n","// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package testlog provides a back-channel communication path\n// between tests and package os, so that cmd/go can see which\n// environment variables and files a test consults.\npackage testlog\n\nimport \"sync/atomic\"\n\n// Interface is the interface required of test loggers.\n// The os package will invoke the interface's methods to indicate that\n// it is inspecting the given environment variables or files.\n// Multiple goroutines may call these methods simultaneously.\ntype Interface interface {\n\tGetenv(key string)\n\tStat(file string)\n\tOpen(file string)\n\tChdir(dir string)\n}\n\n// logger is the current logger Interface.\n// We use an atomic.Value in case test startup\n// is racing with goroutines started during init.\n// That must not cause a race detector failure,\n// although it will still result in limited visibility\n// into exactly what those goroutines do.\nvar logger atomic.Value\n\n// SetLogger sets the test logger implementation for the current process.\n// It must be called only once, at process startup.\nfunc SetLogger(impl Interface) {\n\tif logger.Load() != nil {\n\t\tpanic(\"testlog: SetLogger must be called only once\")\n\t}\n\tlogger.Store(&impl)\n}\n\n// Logger returns the current test logger implementation.\n// It returns nil if there is no logger.\nfunc Logger() Interface {\n\timpl := logger.Load()\n\tif impl == nil {\n\t\treturn nil\n\t}\n\treturn *impl.(*Interface)\n}\n\n// Getenv calls Logger().Getenv, if a logger has been set.\nfunc Getenv(name string) {\n\tif log := Logger(); log != nil {\n\t\tlog.Getenv(name)\n\t}\n}\n\n// Open calls Logger().Open, if a logger has been set.\nfunc Open(name string) {\n\tif log := Logger(); log != nil {\n\t\tlog.Open(name)\n\t}\n}\n\n// Stat calls Logger().Stat, if a logger has been set.\nfunc Stat(name string) {\n\tif log := Logger(); log != nil {\n\t\tlog.Stat(name)\n\t}\n}\n","//go:build wasm && !wasi && !scheduler.none\n// +build wasm,!wasi,!scheduler.none\n\npackage runtime\n\n//export resume\nfunc resume() {\n\tgo func() {\n\t\thandleEvent()\n\t}()\n\n\tif wasmNested {\n\t\tminSched()\n\t\treturn\n\t}\n\n\twasmNested = true\n\tscheduler()\n\twasmNested = false\n}\n\n//export go_scheduler\nfunc go_scheduler() {\n\tif wasmNested {\n\t\tminSched()\n\t\treturn\n\t}\n\n\twasmNested = true\n\tscheduler()\n\twasmNested = false\n}\n","// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build js,wasm\n\npackage js\n\nimport \"sync\"\n\nvar (\n\tfuncsMu    sync.Mutex\n\tfuncs             = make(map[uint32]func(Value, []Value) interface{})\n\tnextFuncID uint32 = 1\n)\n\nvar _ Wrapper = Func{} // Func must implement Wrapper\n\n// Func is a wrapped Go function to be called by JavaScript.\ntype Func struct {\n\tValue // the JavaScript function that invokes the Go function\n\tid    uint32\n}\n\n// FuncOf returns a function to be used by JavaScript.\n//\n// The Go function fn is called with the value of JavaScript's \"this\" keyword and the\n// arguments of the invocation. The return value of the invocation is\n// the result of the Go function mapped back to JavaScript according to ValueOf.\n//\n// Invoking the wrapped Go function from JavaScript will\n// pause the event loop and spawn a new goroutine.\n// Other wrapped functions which are triggered during a call from Go to JavaScript\n// get executed on the same goroutine.\n//\n// As a consequence, if one wrapped function blocks, JavaScript's event loop\n// is blocked until that function returns. Hence, calling any async JavaScript\n// API, which requires the event loop, like fetch (http.Client), will cause an\n// immediate deadlock. Therefore a blocking function should explicitly start a\n// new goroutine.\n//\n// Func.Release must be called to free up resources when the function will not be invoked any more.\nfunc FuncOf(fn func(this Value, args []Value) interface{}) Func {\n\tfuncsMu.Lock()\n\tid := nextFuncID\n\tnextFuncID++\n\tfuncs[id] = fn\n\tfuncsMu.Unlock()\n\treturn Func{\n\t\tid:    id,\n\t\tValue: jsGo.Call(\"_makeFuncWrapper\", id),\n\t}\n}\n\n// Release frees up resources allocated for the function.\n// The function must not be invoked after calling Release.\n// It is allowed to call Release while the function is still running.\nfunc (c Func) Release() {\n\tfuncsMu.Lock()\n\tdelete(funcs, c.id)\n\tfuncsMu.Unlock()\n}\n\n// setEventHandler is defined in the runtime package.\nfunc setEventHandler(fn func())\n\nfunc init() {\n\tsetEventHandler(handleEvent)\n}\n\nfunc handleEvent() {\n\tcb := jsGo.Get(\"_pendingEvent\")\n\tif cb.IsNull() {\n\t\treturn\n\t}\n\tjsGo.Set(\"_pendingEvent\", Null())\n\n\tid := uint32(cb.Get(\"id\").Int())\n\tif id == 0 { // zero indicates deadlock\n\t\tselect {}\n\t}\n\tfuncsMu.Lock()\n\tf, ok := funcs[id]\n\tfuncsMu.Unlock()\n\tif !ok {\n\t\tGlobal().Get(\"console\").Call(\"error\", \"call to released function\")\n\t\treturn\n\t}\n\n\tthis := cb.Get(\"this\")\n\targsObj := cb.Get(\"args\")\n\targs := make([]Value, argsObj.Length())\n\tfor i := range args {\n\t\targs[i] = argsObj.Index(i)\n\t}\n\tresult := f(this, args)\n\tcb.Set(\"result\", result)\n}\n","// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build js && wasm\n// +build js,wasm\n\npackage time\n\nimport (\n\t\"runtime\"\n\t\"syscall/js\"\n)\n\nvar zoneSources = []string{\n\t\"/usr/share/zoneinfo/\",\n\t\"/usr/share/lib/zoneinfo/\",\n\t\"/usr/lib/locale/TZ/\",\n\truntime.GOROOT() + \"/lib/time/zoneinfo.zip\",\n}\n\nfunc initLocal() {\n\tlocalLoc.name = \"Local\"\n\n\tz := zone{}\n\td := js.Global().Get(\"Date\").New()\n\toffset := d.Call(\"getTimezoneOffset\").Int() * -1\n\tz.offset = offset * 60\n\t// According to https://tc39.github.io/ecma262/#sec-timezoneestring,\n\t// the timezone name from (new Date()).toTimeString() is an implementation-dependent\n\t// result, and in Google Chrome, it gives the fully expanded name rather than\n\t// the abbreviation.\n\t// Hence, we construct the name from the offset.\n\tz.name = \"UTC\"\n\tif offset < 0 {\n\t\tz.name += \"-\"\n\t\toffset *= -1\n\t} else {\n\t\tz.name += \"+\"\n\t}\n\tz.name += itoa(offset / 60)\n\tmin := offset % 60\n\tif min != 0 {\n\t\tz.name += \":\" + itoa(min)\n\t}\n\tlocalLoc.zone = []zone{z}\n}\n\n// itoa is like strconv.Itoa but only works for values of i in range [0,99].\n// It panics if i is out of range.\nfunc itoa(i int) string {\n\tif i < 10 {\n\t\treturn digits[i : i+1]\n\t}\n\treturn smallsString[i*2 : i*2+2]\n}\n\nconst smallsString = \"00010203040506070809\" +\n\t\"10111213141516171819\" +\n\t\"20212223242526272829\" +\n\t\"30313233343536373839\" +\n\t\"40414243444546474849\" +\n\t\"50515253545556575859\" +\n\t\"60616263646566676869\" +\n\t\"70717273747576777879\" +\n\t\"80818283848586878889\" +\n\t\"90919293949596979899\"\nconst digits = \"0123456789\"\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage time\n\n// Sleep pauses the current goroutine for at least the duration d.\n// A negative or zero duration causes Sleep to return immediately.\nfunc Sleep(d Duration)\n\n// Interface to timers implemented in package runtime.\n// Must be in sync with ../runtime/time.go:/^type timer\ntype runtimeTimer struct {\n\tpp       uintptr\n\twhen     int64\n\tperiod   int64\n\tf        func(interface{}, uintptr) // NOTE: must not be closure\n\targ      interface{}\n\tseq      uintptr\n\tnextwhen int64\n\tstatus   uint32\n}\n\n// when is a helper function for setting the 'when' field of a runtimeTimer.\n// It returns what the time will be, in nanoseconds, Duration d in the future.\n// If d is negative, it is ignored. If the returned value would be less than\n// zero because of an overflow, MaxInt64 is returned.\nfunc when(d Duration) int64 {\n\tif d <= 0 {\n\t\treturn runtimeNano()\n\t}\n\tt := runtimeNano() + int64(d)\n\tif t < 0 {\n\t\t// N.B. runtimeNano() and d are always positive, so addition\n\t\t// (including overflow) will never result in t == 0.\n\t\tt = 1<<63 - 1 // math.MaxInt64\n\t}\n\treturn t\n}\n\nfunc startTimer(*runtimeTimer)\nfunc stopTimer(*runtimeTimer) bool\nfunc resetTimer(*runtimeTimer, int64) bool\nfunc modTimer(t *runtimeTimer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr)\n\n// The Timer type represents a single event.\n// When the Timer expires, the current time will be sent on C,\n// unless the Timer was created by AfterFunc.\n// A Timer must be created with NewTimer or AfterFunc.\ntype Timer struct {\n\tC <-chan Time\n\tr runtimeTimer\n}\n\n// Stop prevents the Timer from firing.\n// It returns true if the call stops the timer, false if the timer has already\n// expired or been stopped.\n// Stop does not close the channel, to prevent a read from the channel succeeding\n// incorrectly.\n//\n// To ensure the channel is empty after a call to Stop, check the\n// return value and drain the channel.\n// For example, assuming the program has not received from t.C already:\n//\n// \tif !t.Stop() {\n// \t\t<-t.C\n// \t}\n//\n// This cannot be done concurrent to other receives from the Timer's\n// channel or other calls to the Timer's Stop method.\n//\n// For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer\n// has already expired and the function f has been started in its own goroutine;\n// Stop does not wait for f to complete before returning.\n// If the caller needs to know whether f is completed, it must coordinate\n// with f explicitly.\nfunc (t *Timer) Stop() bool {\n\tif t.r.f == nil {\n\t\tpanic(\"time: Stop called on uninitialized Timer\")\n\t}\n\treturn stopTimer(&t.r)\n}\n\n// NewTimer creates a new Timer that will send\n// the current time on its channel after at least duration d.\nfunc NewTimer(d Duration) *Timer {\n\tc := make(chan Time, 1)\n\tt := &Timer{\n\t\tC: c,\n\t\tr: runtimeTimer{\n\t\t\twhen: when(d),\n\t\t\tf:    sendTime,\n\t\t\targ:  c,\n\t\t},\n\t}\n\tstartTimer(&t.r)\n\treturn t\n}\n\n// Reset changes the timer to expire after duration d.\n// It returns true if the timer had been active, false if the timer had\n// expired or been stopped.\n//\n// For a Timer created with NewTimer, Reset should be invoked only on\n// stopped or expired timers with drained channels.\n//\n// If a program has already received a value from t.C, the timer is known\n// to have expired and the channel drained, so t.Reset can be used directly.\n// If a program has not yet received a value from t.C, however,\n// the timer must be stopped and\u2014if Stop reports that the timer expired\n// before being stopped\u2014the channel explicitly drained:\n//\n// \tif !t.Stop() {\n// \t\t<-t.C\n// \t}\n// \tt.Reset(d)\n//\n// This should not be done concurrent to other receives from the Timer's\n// channel.\n//\n// Note that it is not possible to use Reset's return value correctly, as there\n// is a race condition between draining the channel and the new timer expiring.\n// Reset should always be invoked on stopped or expired channels, as described above.\n// The return value exists to preserve compatibility with existing programs.\n//\n// For a Timer created with AfterFunc(d, f), Reset either reschedules\n// when f will run, in which case Reset returns true, or schedules f\n// to run again, in which case it returns false.\n// When Reset returns false, Reset neither waits for the prior f to\n// complete before returning nor does it guarantee that the subsequent\n// goroutine running f does not run concurrently with the prior\n// one. If the caller needs to know whether the prior execution of\n// f is completed, it must coordinate with f explicitly.\nfunc (t *Timer) Reset(d Duration) bool {\n\tif t.r.f == nil {\n\t\tpanic(\"time: Reset called on uninitialized Timer\")\n\t}\n\tw := when(d)\n\treturn resetTimer(&t.r, w)\n}\n\nfunc sendTime(c interface{}, seq uintptr) {\n\t// Non-blocking send of time on c.\n\t// Used in NewTimer, it cannot block anyway (buffer).\n\t// Used in NewTicker, dropping sends on the floor is\n\t// the desired behavior when the reader gets behind,\n\t// because the sends are periodic.\n\tselect {\n\tcase c.(chan Time) <- Now():\n\tdefault:\n\t}\n}\n\n// After waits for the duration to elapse and then sends the current time\n// on the returned channel.\n// It is equivalent to NewTimer(d).C.\n// The underlying Timer is not recovered by the garbage collector\n// until the timer fires. If efficiency is a concern, use NewTimer\n// instead and call Timer.Stop if the timer is no longer needed.\nfunc After(d Duration) <-chan Time {\n\treturn NewTimer(d).C\n}\n\n// AfterFunc waits for the duration to elapse and then calls f\n// in its own goroutine. It returns a Timer that can\n// be used to cancel the call using its Stop method.\nfunc AfterFunc(d Duration, f func()) *Timer {\n\tt := &Timer{\n\t\tr: runtimeTimer{\n\t\t\twhen: when(d),\n\t\t\tf:    goFunc,\n\t\t\targ:  f,\n\t\t},\n\t}\n\tstartTimer(&t.r)\n\treturn t\n}\n\nfunc goFunc(arg interface{}, seq uintptr) {\n\tgo arg.(func())()\n}\n","// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package fmtsort provides a general stable ordering mechanism\n// for maps, on behalf of the fmt and text/template packages.\n// It is not guaranteed to be efficient and works only for types\n// that are valid map keys.\npackage fmtsort\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n)\n\n// Note: Throughout this package we avoid calling reflect.Value.Interface as\n// it is not always legal to do so and it's easier to avoid the issue than to face it.\n\n// SortedMap represents a map's keys and values. The keys and values are\n// aligned in index order: Value[i] is the value in the map corresponding to Key[i].\ntype SortedMap struct {\n\tKey   []reflect.Value\n\tValue []reflect.Value\n}\n\nfunc (o *SortedMap) Len() int           { return len(o.Key) }\nfunc (o *SortedMap) Less(i, j int) bool { return compare(o.Key[i], o.Key[j]) < 0 }\nfunc (o *SortedMap) Swap(i, j int) {\n\to.Key[i], o.Key[j] = o.Key[j], o.Key[i]\n\to.Value[i], o.Value[j] = o.Value[j], o.Value[i]\n}\n\n// Sort accepts a map and returns a SortedMap that has the same keys and\n// values but in a stable sorted order according to the keys, modulo issues\n// raised by unorderable key values such as NaNs.\n//\n// The ordering rules are more general than with Go's < operator:\n//\n//  - when applicable, nil compares low\n//  - ints, floats, and strings order by <\n//  - NaN compares less than non-NaN floats\n//  - bool compares false before true\n//  - complex compares real, then imag\n//  - pointers compare by machine address\n//  - channel values compare by machine address\n//  - structs compare each field in turn\n//  - arrays compare each element in turn.\n//    Otherwise identical arrays compare by length.\n//  - interface values compare first by reflect.Type describing the concrete type\n//    and then by concrete value as described in the previous rules.\n//\nfunc Sort(mapValue reflect.Value) *SortedMap {\n\tif mapValue.Type().Kind() != reflect.Map {\n\t\treturn nil\n\t}\n\t// Note: this code is arranged to not panic even in the presence\n\t// of a concurrent map update. The runtime is responsible for\n\t// yelling loudly if that happens. See issue 33275.\n\tn := mapValue.Len()\n\tkey := make([]reflect.Value, 0, n)\n\tvalue := make([]reflect.Value, 0, n)\n\titer := mapValue.MapRange()\n\tfor iter.Next() {\n\t\tkey = append(key, iter.Key())\n\t\tvalue = append(value, iter.Value())\n\t}\n\tsorted := &SortedMap{\n\t\tKey:   key,\n\t\tValue: value,\n\t}\n\tsort.Stable(sorted)\n\treturn sorted\n}\n\n// compare compares two values of the same type. It returns -1, 0, 1\n// according to whether a > b (1), a == b (0), or a < b (-1).\n// If the types differ, it returns -1.\n// See the comment on Sort for the comparison rules.\nfunc compare(aVal, bVal reflect.Value) int {\n\taType, bType := aVal.Type(), bVal.Type()\n\tif aType != bType {\n\t\treturn -1 // No good answer possible, but don't return 0: they're not equal.\n\t}\n\tswitch aVal.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\ta, b := aVal.Int(), bVal.Int()\n\t\tswitch {\n\t\tcase a < b:\n\t\t\treturn -1\n\t\tcase a > b:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\ta, b := aVal.Uint(), bVal.Uint()\n\t\tswitch {\n\t\tcase a < b:\n\t\t\treturn -1\n\t\tcase a > b:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\tcase reflect.String:\n\t\ta, b := aVal.String(), bVal.String()\n\t\tswitch {\n\t\tcase a < b:\n\t\t\treturn -1\n\t\tcase a > b:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn floatCompare(aVal.Float(), bVal.Float())\n\tcase reflect.Complex64, reflect.Complex128:\n\t\ta, b := aVal.Complex(), bVal.Complex()\n\t\tif c := floatCompare(real(a), real(b)); c != 0 {\n\t\t\treturn c\n\t\t}\n\t\treturn floatCompare(imag(a), imag(b))\n\tcase reflect.Bool:\n\t\ta, b := aVal.Bool(), bVal.Bool()\n\t\tswitch {\n\t\tcase a == b:\n\t\t\treturn 0\n\t\tcase a:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn -1\n\t\t}\n\tcase reflect.Ptr, reflect.UnsafePointer:\n\t\ta, b := aVal.Pointer(), bVal.Pointer()\n\t\tswitch {\n\t\tcase a < b:\n\t\t\treturn -1\n\t\tcase a > b:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\tcase reflect.Chan:\n\t\tif c, ok := nilCompare(aVal, bVal); ok {\n\t\t\treturn c\n\t\t}\n\t\tap, bp := aVal.Pointer(), bVal.Pointer()\n\t\tswitch {\n\t\tcase ap < bp:\n\t\t\treturn -1\n\t\tcase ap > bp:\n\t\t\treturn 1\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\tcase reflect.Struct:\n\t\tfor i := 0; i < aVal.NumField(); i++ {\n\t\t\tif c := compare(aVal.Field(i), bVal.Field(i)); c != 0 {\n\t\t\t\treturn c\n\t\t\t}\n\t\t}\n\t\treturn 0\n\tcase reflect.Array:\n\t\tfor i := 0; i < aVal.Len(); i++ {\n\t\t\tif c := compare(aVal.Index(i), bVal.Index(i)); c != 0 {\n\t\t\t\treturn c\n\t\t\t}\n\t\t}\n\t\treturn 0\n\tcase reflect.Interface:\n\t\tif c, ok := nilCompare(aVal, bVal); ok {\n\t\t\treturn c\n\t\t}\n\t\tc := compare(reflect.ValueOf(aVal.Elem().Type()), reflect.ValueOf(bVal.Elem().Type()))\n\t\tif c != 0 {\n\t\t\treturn c\n\t\t}\n\t\treturn compare(aVal.Elem(), bVal.Elem())\n\tdefault:\n\t\t// Certain types cannot appear as keys (maps, funcs, slices), but be explicit.\n\t\tpanic(\"bad type in compare: \" + aType.String())\n\t}\n}\n\n// nilCompare checks whether either value is nil. If not, the boolean is false.\n// If either value is nil, the boolean is true and the integer is the comparison\n// value. The comparison is defined to be 0 if both are nil, otherwise the one\n// nil value compares low. Both arguments must represent a chan, func,\n// interface, map, pointer, or slice.\nfunc nilCompare(aVal, bVal reflect.Value) (int, bool) {\n\tif aVal.IsNil() {\n\t\tif bVal.IsNil() {\n\t\t\treturn 0, true\n\t\t}\n\t\treturn -1, true\n\t}\n\tif bVal.IsNil() {\n\t\treturn 1, true\n\t}\n\treturn 0, false\n}\n\n// floatCompare compares two floating-point values. NaNs compare low.\nfunc floatCompare(a, b float64) int {\n\tswitch {\n\tcase isNaN(a):\n\t\treturn -1 // No good answer if b is a NaN so don't bother checking.\n\tcase isNaN(b):\n\t\treturn 1\n\tcase a < b:\n\t\treturn -1\n\tcase a > b:\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc isNaN(a float64) bool {\n\treturn a != a\n}\n","// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:generate go run make_tables.go\n\n// Package bits implements bit counting and manipulation\n// functions for the predeclared unsigned integer types.\npackage bits\n\nconst uintSize = 32 << (^uint(0) >> 63) // 32 or 64\n\n// UintSize is the size of a uint in bits.\nconst UintSize = uintSize\n\n// --- LeadingZeros ---\n\n// LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\nfunc LeadingZeros(x uint) int { return UintSize - Len(x) }\n\n// LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\nfunc LeadingZeros8(x uint8) int { return 8 - Len8(x) }\n\n// LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\nfunc LeadingZeros16(x uint16) int { return 16 - Len16(x) }\n\n// LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\nfunc LeadingZeros32(x uint32) int { return 32 - Len32(x) }\n\n// LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\nfunc LeadingZeros64(x uint64) int { return 64 - Len64(x) }\n\n// --- TrailingZeros ---\n\n// See http://supertech.csail.mit.edu/papers/debruijn.pdf\nconst deBruijn32 = 0x077CB531\n\nvar deBruijn32tab = [32]byte{\n\t0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n\t31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9,\n}\n\nconst deBruijn64 = 0x03f79d71b4ca8b09\n\nvar deBruijn64tab = [64]byte{\n\t0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4,\n\t62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5,\n\t63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11,\n\t54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6,\n}\n\n// TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\nfunc TrailingZeros(x uint) int {\n\tif UintSize == 32 {\n\t\treturn TrailingZeros32(uint32(x))\n\t}\n\treturn TrailingZeros64(uint64(x))\n}\n\n// TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\nfunc TrailingZeros8(x uint8) int {\n\treturn int(ntz8tab[x])\n}\n\n// TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\nfunc TrailingZeros16(x uint16) int {\n\tif x == 0 {\n\t\treturn 16\n\t}\n\t// see comment in TrailingZeros64\n\treturn int(deBruijn32tab[uint32(x&-x)*deBruijn32>>(32-5)])\n}\n\n// TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\nfunc TrailingZeros32(x uint32) int {\n\tif x == 0 {\n\t\treturn 32\n\t}\n\t// see comment in TrailingZeros64\n\treturn int(deBruijn32tab[(x&-x)*deBruijn32>>(32-5)])\n}\n\n// TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\nfunc TrailingZeros64(x uint64) int {\n\tif x == 0 {\n\t\treturn 64\n\t}\n\t// If popcount is fast, replace code below with return popcount(^x & (x - 1)).\n\t//\n\t// x & -x leaves only the right-most bit set in the word. Let k be the\n\t// index of that bit. Since only a single bit is set, the value is two\n\t// to the power of k. Multiplying by a power of two is equivalent to\n\t// left shifting, in this case by k bits. The de Bruijn (64 bit) constant\n\t// is such that all six bit, consecutive substrings are distinct.\n\t// Therefore, if we have a left shifted version of this constant we can\n\t// find by how many bits it was shifted by looking at which six bit\n\t// substring ended up at the top of the word.\n\t// (Knuth, volume 4, section 7.3.1)\n\treturn int(deBruijn64tab[(x&-x)*deBruijn64>>(64-6)])\n}\n\n// --- OnesCount ---\n\nconst m0 = 0x5555555555555555 // 01010101 ...\nconst m1 = 0x3333333333333333 // 00110011 ...\nconst m2 = 0x0f0f0f0f0f0f0f0f // 00001111 ...\nconst m3 = 0x00ff00ff00ff00ff // etc.\nconst m4 = 0x0000ffff0000ffff\n\n// OnesCount returns the number of one bits (\"population count\") in x.\nfunc OnesCount(x uint) int {\n\tif UintSize == 32 {\n\t\treturn OnesCount32(uint32(x))\n\t}\n\treturn OnesCount64(uint64(x))\n}\n\n// OnesCount8 returns the number of one bits (\"population count\") in x.\nfunc OnesCount8(x uint8) int {\n\treturn int(pop8tab[x])\n}\n\n// OnesCount16 returns the number of one bits (\"population count\") in x.\nfunc OnesCount16(x uint16) int {\n\treturn int(pop8tab[x>>8] + pop8tab[x&0xff])\n}\n\n// OnesCount32 returns the number of one bits (\"population count\") in x.\nfunc OnesCount32(x uint32) int {\n\treturn int(pop8tab[x>>24] + pop8tab[x>>16&0xff] + pop8tab[x>>8&0xff] + pop8tab[x&0xff])\n}\n\n// OnesCount64 returns the number of one bits (\"population count\") in x.\nfunc OnesCount64(x uint64) int {\n\t// Implementation: Parallel summing of adjacent bits.\n\t// See \"Hacker's Delight\", Chap. 5: Counting Bits.\n\t// The following pattern shows the general approach:\n\t//\n\t//   x = x>>1&(m0&m) + x&(m0&m)\n\t//   x = x>>2&(m1&m) + x&(m1&m)\n\t//   x = x>>4&(m2&m) + x&(m2&m)\n\t//   x = x>>8&(m3&m) + x&(m3&m)\n\t//   x = x>>16&(m4&m) + x&(m4&m)\n\t//   x = x>>32&(m5&m) + x&(m5&m)\n\t//   return int(x)\n\t//\n\t// Masking (& operations) can be left away when there's no\n\t// danger that a field's sum will carry over into the next\n\t// field: Since the result cannot be > 64, 8 bits is enough\n\t// and we can ignore the masks for the shifts by 8 and up.\n\t// Per \"Hacker's Delight\", the first line can be simplified\n\t// more, but it saves at best one instruction, so we leave\n\t// it alone for clarity.\n\tconst m = 1<<64 - 1\n\tx = x>>1&(m0&m) + x&(m0&m)\n\tx = x>>2&(m1&m) + x&(m1&m)\n\tx = (x>>4 + x) & (m2 & m)\n\tx += x >> 8\n\tx += x >> 16\n\tx += x >> 32\n\treturn int(x) & (1<<7 - 1)\n}\n\n// --- RotateLeft ---\n\n// RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\n// To rotate x right by k bits, call RotateLeft(x, -k).\n//\n// This function's execution time does not depend on the inputs.\nfunc RotateLeft(x uint, k int) uint {\n\tif UintSize == 32 {\n\t\treturn uint(RotateLeft32(uint32(x), k))\n\t}\n\treturn uint(RotateLeft64(uint64(x), k))\n}\n\n// RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\n// To rotate x right by k bits, call RotateLeft8(x, -k).\n//\n// This function's execution time does not depend on the inputs.\nfunc RotateLeft8(x uint8, k int) uint8 {\n\tconst n = 8\n\ts := uint(k) & (n - 1)\n\treturn x<<s | x>>(n-s)\n}\n\n// RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\n// To rotate x right by k bits, call RotateLeft16(x, -k).\n//\n// This function's execution time does not depend on the inputs.\nfunc RotateLeft16(x uint16, k int) uint16 {\n\tconst n = 16\n\ts := uint(k) & (n - 1)\n\treturn x<<s | x>>(n-s)\n}\n\n// RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\n// To rotate x right by k bits, call RotateLeft32(x, -k).\n//\n// This function's execution time does not depend on the inputs.\nfunc RotateLeft32(x uint32, k int) uint32 {\n\tconst n = 32\n\ts := uint(k) & (n - 1)\n\treturn x<<s | x>>(n-s)\n}\n\n// RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\n// To rotate x right by k bits, call RotateLeft64(x, -k).\n//\n// This function's execution time does not depend on the inputs.\nfunc RotateLeft64(x uint64, k int) uint64 {\n\tconst n = 64\n\ts := uint(k) & (n - 1)\n\treturn x<<s | x>>(n-s)\n}\n\n// --- Reverse ---\n\n// Reverse returns the value of x with its bits in reversed order.\nfunc Reverse(x uint) uint {\n\tif UintSize == 32 {\n\t\treturn uint(Reverse32(uint32(x)))\n\t}\n\treturn uint(Reverse64(uint64(x)))\n}\n\n// Reverse8 returns the value of x with its bits in reversed order.\nfunc Reverse8(x uint8) uint8 {\n\treturn rev8tab[x]\n}\n\n// Reverse16 returns the value of x with its bits in reversed order.\nfunc Reverse16(x uint16) uint16 {\n\treturn uint16(rev8tab[x>>8]) | uint16(rev8tab[x&0xff])<<8\n}\n\n// Reverse32 returns the value of x with its bits in reversed order.\nfunc Reverse32(x uint32) uint32 {\n\tconst m = 1<<32 - 1\n\tx = x>>1&(m0&m) | x&(m0&m)<<1\n\tx = x>>2&(m1&m) | x&(m1&m)<<2\n\tx = x>>4&(m2&m) | x&(m2&m)<<4\n\treturn ReverseBytes32(x)\n}\n\n// Reverse64 returns the value of x with its bits in reversed order.\nfunc Reverse64(x uint64) uint64 {\n\tconst m = 1<<64 - 1\n\tx = x>>1&(m0&m) | x&(m0&m)<<1\n\tx = x>>2&(m1&m) | x&(m1&m)<<2\n\tx = x>>4&(m2&m) | x&(m2&m)<<4\n\treturn ReverseBytes64(x)\n}\n\n// --- ReverseBytes ---\n\n// ReverseBytes returns the value of x with its bytes in reversed order.\n//\n// This function's execution time does not depend on the inputs.\nfunc ReverseBytes(x uint) uint {\n\tif UintSize == 32 {\n\t\treturn uint(ReverseBytes32(uint32(x)))\n\t}\n\treturn uint(ReverseBytes64(uint64(x)))\n}\n\n// ReverseBytes16 returns the value of x with its bytes in reversed order.\n//\n// This function's execution time does not depend on the inputs.\nfunc ReverseBytes16(x uint16) uint16 {\n\treturn x>>8 | x<<8\n}\n\n// ReverseBytes32 returns the value of x with its bytes in reversed order.\n//\n// This function's execution time does not depend on the inputs.\nfunc ReverseBytes32(x uint32) uint32 {\n\tconst m = 1<<32 - 1\n\tx = x>>8&(m3&m) | x&(m3&m)<<8\n\treturn x>>16 | x<<16\n}\n\n// ReverseBytes64 returns the value of x with its bytes in reversed order.\n//\n// This function's execution time does not depend on the inputs.\nfunc ReverseBytes64(x uint64) uint64 {\n\tconst m = 1<<64 - 1\n\tx = x>>8&(m3&m) | x&(m3&m)<<8\n\tx = x>>16&(m4&m) | x&(m4&m)<<16\n\treturn x>>32 | x<<32\n}\n\n// --- Len ---\n\n// Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nfunc Len(x uint) int {\n\tif UintSize == 32 {\n\t\treturn Len32(uint32(x))\n\t}\n\treturn Len64(uint64(x))\n}\n\n// Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nfunc Len8(x uint8) int {\n\treturn int(len8tab[x])\n}\n\n// Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nfunc Len16(x uint16) (n int) {\n\tif x >= 1<<8 {\n\t\tx >>= 8\n\t\tn = 8\n\t}\n\treturn n + int(len8tab[x])\n}\n\n// Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nfunc Len32(x uint32) (n int) {\n\tif x >= 1<<16 {\n\t\tx >>= 16\n\t\tn = 16\n\t}\n\tif x >= 1<<8 {\n\t\tx >>= 8\n\t\tn += 8\n\t}\n\treturn n + int(len8tab[x])\n}\n\n// Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\nfunc Len64(x uint64) (n int) {\n\tif x >= 1<<32 {\n\t\tx >>= 32\n\t\tn = 32\n\t}\n\tif x >= 1<<16 {\n\t\tx >>= 16\n\t\tn += 16\n\t}\n\tif x >= 1<<8 {\n\t\tx >>= 8\n\t\tn += 8\n\t}\n\treturn n + int(len8tab[x])\n}\n\n// --- Add with carry ---\n\n// Add returns the sum with carry of x, y and carry: sum = x + y + carry.\n// The carry input must be 0 or 1; otherwise the behavior is undefined.\n// The carryOut output is guaranteed to be 0 or 1.\n//\n// This function's execution time does not depend on the inputs.\nfunc Add(x, y, carry uint) (sum, carryOut uint) {\n\tif UintSize == 32 {\n\t\ts32, c32 := Add32(uint32(x), uint32(y), uint32(carry))\n\t\treturn uint(s32), uint(c32)\n\t}\n\ts64, c64 := Add64(uint64(x), uint64(y), uint64(carry))\n\treturn uint(s64), uint(c64)\n}\n\n// Add32 returns the sum with carry of x, y and carry: sum = x + y + carry.\n// The carry input must be 0 or 1; otherwise the behavior is undefined.\n// The carryOut output is guaranteed to be 0 or 1.\n//\n// This function's execution time does not depend on the inputs.\nfunc Add32(x, y, carry uint32) (sum, carryOut uint32) {\n\tsum64 := uint64(x) + uint64(y) + uint64(carry)\n\tsum = uint32(sum64)\n\tcarryOut = uint32(sum64 >> 32)\n\treturn\n}\n\n// Add64 returns the sum with carry of x, y and carry: sum = x + y + carry.\n// The carry input must be 0 or 1; otherwise the behavior is undefined.\n// The carryOut output is guaranteed to be 0 or 1.\n//\n// This function's execution time does not depend on the inputs.\nfunc Add64(x, y, carry uint64) (sum, carryOut uint64) {\n\tsum = x + y + carry\n\t// The sum will overflow if both top bits are set (x & y) or if one of them\n\t// is (x | y), and a carry from the lower place happened. If such a carry\n\t// happens, the top bit will be 1 + 0 + 1 = 0 (&^ sum).\n\tcarryOut = ((x & y) | ((x | y) &^ sum)) >> 63\n\treturn\n}\n\n// --- Subtract with borrow ---\n\n// Sub returns the difference of x, y and borrow: diff = x - y - borrow.\n// The borrow input must be 0 or 1; otherwise the behavior is undefined.\n// The borrowOut output is guaranteed to be 0 or 1.\n//\n// This function's execution time does not depend on the inputs.\nfunc Sub(x, y, borrow uint) (diff, borrowOut uint) {\n\tif UintSize == 32 {\n\t\td32, b32 := Sub32(uint32(x), uint32(y), uint32(borrow))\n\t\treturn uint(d32), uint(b32)\n\t}\n\td64, b64 := Sub64(uint64(x), uint64(y), uint64(borrow))\n\treturn uint(d64), uint(b64)\n}\n\n// Sub32 returns the difference of x, y and borrow, diff = x - y - borrow.\n// The borrow input must be 0 or 1; otherwise the behavior is undefined.\n// The borrowOut output is guaranteed to be 0 or 1.\n//\n// This function's execution time does not depend on the inputs.\nfunc Sub32(x, y, borrow uint32) (diff, borrowOut uint32) {\n\tdiff = x - y - borrow\n\t// The difference will underflow if the top bit of x is not set and the top\n\t// bit of y is set (^x & y) or if they are the same (^(x ^ y)) and a borrow\n\t// from the lower place happens. If that borrow happens, the result will be\n\t// 1 - 1 - 1 = 0 - 0 - 1 = 1 (& diff).\n\tborrowOut = ((^x & y) | (^(x ^ y) & diff)) >> 31\n\treturn\n}\n\n// Sub64 returns the difference of x, y and borrow: diff = x - y - borrow.\n// The borrow input must be 0 or 1; otherwise the behavior is undefined.\n// The borrowOut output is guaranteed to be 0 or 1.\n//\n// This function's execution time does not depend on the inputs.\nfunc Sub64(x, y, borrow uint64) (diff, borrowOut uint64) {\n\tdiff = x - y - borrow\n\t// See Sub32 for the bit logic.\n\tborrowOut = ((^x & y) | (^(x ^ y) & diff)) >> 63\n\treturn\n}\n\n// --- Full-width multiply ---\n\n// Mul returns the full-width product of x and y: (hi, lo) = x * y\n// with the product bits' upper half returned in hi and the lower\n// half returned in lo.\n//\n// This function's execution time does not depend on the inputs.\nfunc Mul(x, y uint) (hi, lo uint) {\n\tif UintSize == 32 {\n\t\th, l := Mul32(uint32(x), uint32(y))\n\t\treturn uint(h), uint(l)\n\t}\n\th, l := Mul64(uint64(x), uint64(y))\n\treturn uint(h), uint(l)\n}\n\n// Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y\n// with the product bits' upper half returned in hi and the lower\n// half returned in lo.\n//\n// This function's execution time does not depend on the inputs.\nfunc Mul32(x, y uint32) (hi, lo uint32) {\n\ttmp := uint64(x) * uint64(y)\n\thi, lo = uint32(tmp>>32), uint32(tmp)\n\treturn\n}\n\n// Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y\n// with the product bits' upper half returned in hi and the lower\n// half returned in lo.\n//\n// This function's execution time does not depend on the inputs.\nfunc Mul64(x, y uint64) (hi, lo uint64) {\n\tconst mask32 = 1<<32 - 1\n\tx0 := x & mask32\n\tx1 := x >> 32\n\ty0 := y & mask32\n\ty1 := y >> 32\n\tw0 := x0 * y0\n\tt := x1*y0 + w0>>32\n\tw1 := t & mask32\n\tw2 := t >> 32\n\tw1 += x0 * y1\n\thi = x1*y1 + w2 + w1>>32\n\tlo = x * y\n\treturn\n}\n\n// --- Full-width divide ---\n\n// Div returns the quotient and remainder of (hi, lo) divided by y:\n// quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\n// half in parameter hi and the lower half in parameter lo.\n// Div panics for y == 0 (division by zero) or y <= hi (quotient overflow).\nfunc Div(hi, lo, y uint) (quo, rem uint) {\n\tif UintSize == 32 {\n\t\tq, r := Div32(uint32(hi), uint32(lo), uint32(y))\n\t\treturn uint(q), uint(r)\n\t}\n\tq, r := Div64(uint64(hi), uint64(lo), uint64(y))\n\treturn uint(q), uint(r)\n}\n\n// Div32 returns the quotient and remainder of (hi, lo) divided by y:\n// quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\n// half in parameter hi and the lower half in parameter lo.\n// Div32 panics for y == 0 (division by zero) or y <= hi (quotient overflow).\nfunc Div32(hi, lo, y uint32) (quo, rem uint32) {\n\tif y != 0 && y <= hi {\n\t\tpanic(overflowError)\n\t}\n\tz := uint64(hi)<<32 | uint64(lo)\n\tquo, rem = uint32(z/uint64(y)), uint32(z%uint64(y))\n\treturn\n}\n\n// Div64 returns the quotient and remainder of (hi, lo) divided by y:\n// quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\n// half in parameter hi and the lower half in parameter lo.\n// Div64 panics for y == 0 (division by zero) or y <= hi (quotient overflow).\nfunc Div64(hi, lo, y uint64) (quo, rem uint64) {\n\tconst (\n\t\ttwo32  = 1 << 32\n\t\tmask32 = two32 - 1\n\t)\n\tif y == 0 {\n\t\tpanic(divideError)\n\t}\n\tif y <= hi {\n\t\tpanic(overflowError)\n\t}\n\n\ts := uint(LeadingZeros64(y))\n\ty <<= s\n\n\tyn1 := y >> 32\n\tyn0 := y & mask32\n\tun32 := hi<<s | lo>>(64-s)\n\tun10 := lo << s\n\tun1 := un10 >> 32\n\tun0 := un10 & mask32\n\tq1 := un32 / yn1\n\trhat := un32 - q1*yn1\n\n\tfor q1 >= two32 || q1*yn0 > two32*rhat+un1 {\n\t\tq1--\n\t\trhat += yn1\n\t\tif rhat >= two32 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tun21 := un32*two32 + un1 - q1*y\n\tq0 := un21 / yn1\n\trhat = un21 - q0*yn1\n\n\tfor q0 >= two32 || q0*yn0 > two32*rhat+un0 {\n\t\tq0--\n\t\trhat += yn1\n\t\tif rhat >= two32 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn q1*two32 + q0, (un21*two32 + un0 - q0*y) >> s\n}\n\n// Rem returns the remainder of (hi, lo) divided by y. Rem panics for\n// y == 0 (division by zero) but, unlike Div, it doesn't panic on a\n// quotient overflow.\nfunc Rem(hi, lo, y uint) uint {\n\tif UintSize == 32 {\n\t\treturn uint(Rem32(uint32(hi), uint32(lo), uint32(y)))\n\t}\n\treturn uint(Rem64(uint64(hi), uint64(lo), uint64(y)))\n}\n\n// Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics\n// for y == 0 (division by zero) but, unlike Div32, it doesn't panic\n// on a quotient overflow.\nfunc Rem32(hi, lo, y uint32) uint32 {\n\treturn uint32((uint64(hi)<<32 | uint64(lo)) % uint64(y))\n}\n\n// Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics\n// for y == 0 (division by zero) but, unlike Div64, it doesn't panic\n// on a quotient overflow.\nfunc Rem64(hi, lo, y uint64) uint64 {\n\t// We scale down hi so that hi < y, then use Div64 to compute the\n\t// rem with the guarantee that it won't panic on quotient overflow.\n\t// Given that\n\t//   hi \u2261 hi%y    (mod y)\n\t// we have\n\t//   hi<<64 + lo \u2261 (hi%y)<<64 + lo    (mod y)\n\t_, rem := Div64(hi%y, lo, y)\n\treturn rem\n}\n","// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage strings\n\nimport (\n\t\"unicode/utf8\"\n\t\"unsafe\"\n)\n\n// A Builder is used to efficiently build a string using Write methods.\n// It minimizes memory copying. The zero value is ready to use.\n// Do not copy a non-zero Builder.\ntype Builder struct {\n\taddr *Builder // of receiver, to detect copies by value\n\tbuf  []byte\n}\n\n// noescape hides a pointer from escape analysis.  noescape is\n// the identity function but escape analysis doesn't think the\n// output depends on the input. noescape is inlined and currently\n// compiles down to zero instructions.\n// USE CAREFULLY!\n// This was copied from the runtime; see issues 23382 and 7921.\n//go:nosplit\n//go:nocheckptr\nfunc noescape(p unsafe.Pointer) unsafe.Pointer {\n\tx := uintptr(p)\n\treturn unsafe.Pointer(x ^ 0)\n}\n\nfunc (b *Builder) copyCheck() {\n\tif b.addr == nil {\n\t\t// This hack works around a failing of Go's escape analysis\n\t\t// that was causing b to escape and be heap allocated.\n\t\t// See issue 23382.\n\t\t// TODO: once issue 7921 is fixed, this should be reverted to\n\t\t// just \"b.addr = b\".\n\t\tb.addr = (*Builder)(noescape(unsafe.Pointer(b)))\n\t} else if b.addr != b {\n\t\tpanic(\"strings: illegal use of non-zero Builder copied by value\")\n\t}\n}\n\n// String returns the accumulated string.\nfunc (b *Builder) String() string {\n\treturn *(*string)(unsafe.Pointer(&b.buf))\n}\n\n// Len returns the number of accumulated bytes; b.Len() == len(b.String()).\nfunc (b *Builder) Len() int { return len(b.buf) }\n\n// Cap returns the capacity of the builder's underlying byte slice. It is the\n// total space allocated for the string being built and includes any bytes\n// already written.\nfunc (b *Builder) Cap() int { return cap(b.buf) }\n\n// Reset resets the Builder to be empty.\nfunc (b *Builder) Reset() {\n\tb.addr = nil\n\tb.buf = nil\n}\n\n// grow copies the buffer to a new, larger buffer so that there are at least n\n// bytes of capacity beyond len(b.buf).\nfunc (b *Builder) grow(n int) {\n\tbuf := make([]byte, len(b.buf), 2*cap(b.buf)+n)\n\tcopy(buf, b.buf)\n\tb.buf = buf\n}\n\n// Grow grows b's capacity, if necessary, to guarantee space for\n// another n bytes. After Grow(n), at least n bytes can be written to b\n// without another allocation. If n is negative, Grow panics.\nfunc (b *Builder) Grow(n int) {\n\tb.copyCheck()\n\tif n < 0 {\n\t\tpanic(\"strings.Builder.Grow: negative count\")\n\t}\n\tif cap(b.buf)-len(b.buf) < n {\n\t\tb.grow(n)\n\t}\n}\n\n// Write appends the contents of p to b's buffer.\n// Write always returns len(p), nil.\nfunc (b *Builder) Write(p []byte) (int, error) {\n\tb.copyCheck()\n\tb.buf = append(b.buf, p...)\n\treturn len(p), nil\n}\n\n// WriteByte appends the byte c to b's buffer.\n// The returned error is always nil.\nfunc (b *Builder) WriteByte(c byte) error {\n\tb.copyCheck()\n\tb.buf = append(b.buf, c)\n\treturn nil\n}\n\n// WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer.\n// It returns the length of r and a nil error.\nfunc (b *Builder) WriteRune(r rune) (int, error) {\n\tb.copyCheck()\n\t// Compare as uint32 to correctly handle negative runes.\n\tif uint32(r) < utf8.RuneSelf {\n\t\tb.buf = append(b.buf, byte(r))\n\t\treturn 1, nil\n\t}\n\tl := len(b.buf)\n\tif cap(b.buf)-l < utf8.UTFMax {\n\t\tb.grow(utf8.UTFMax)\n\t}\n\tn := utf8.EncodeRune(b.buf[l:l+utf8.UTFMax], r)\n\tb.buf = b.buf[:l+n]\n\treturn n, nil\n}\n\n// WriteString appends the contents of s to b's buffer.\n// It returns the length of s and a nil error.\nfunc (b *Builder) WriteString(s string) (int, error) {\n\tb.copyCheck()\n\tb.buf = append(b.buf, s...)\n\treturn len(s), nil\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package strings implements simple functions to manipulate UTF-8 encoded strings.\n//\n// For information about UTF-8 strings in Go, see https://blog.golang.org/strings.\npackage strings\n\nimport (\n\t\"internal/bytealg\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\n// explode splits s into a slice of UTF-8 strings,\n// one string per Unicode character up to a maximum of n (n < 0 means no limit).\n// Invalid UTF-8 sequences become correct encodings of U+FFFD.\nfunc explode(s string, n int) []string {\n\tl := utf8.RuneCountInString(s)\n\tif n < 0 || n > l {\n\t\tn = l\n\t}\n\ta := make([]string, n)\n\tfor i := 0; i < n-1; i++ {\n\t\tch, size := utf8.DecodeRuneInString(s)\n\t\ta[i] = s[:size]\n\t\ts = s[size:]\n\t\tif ch == utf8.RuneError {\n\t\t\ta[i] = string(utf8.RuneError)\n\t\t}\n\t}\n\tif n > 0 {\n\t\ta[n-1] = s\n\t}\n\treturn a\n}\n\n// Count counts the number of non-overlapping instances of substr in s.\n// If substr is an empty string, Count returns 1 + the number of Unicode code points in s.\nfunc Count(s, substr string) int {\n\t// special case\n\tif len(substr) == 0 {\n\t\treturn utf8.RuneCountInString(s) + 1\n\t}\n\tif len(substr) == 1 {\n\t\treturn bytealg.CountString(s, substr[0])\n\t}\n\tn := 0\n\tfor {\n\t\ti := Index(s, substr)\n\t\tif i == -1 {\n\t\t\treturn n\n\t\t}\n\t\tn++\n\t\ts = s[i+len(substr):]\n\t}\n}\n\n// Contains reports whether substr is within s.\nfunc Contains(s, substr string) bool {\n\treturn Index(s, substr) >= 0\n}\n\n// ContainsAny reports whether any Unicode code points in chars are within s.\nfunc ContainsAny(s, chars string) bool {\n\treturn IndexAny(s, chars) >= 0\n}\n\n// ContainsRune reports whether the Unicode code point r is within s.\nfunc ContainsRune(s string, r rune) bool {\n\treturn IndexRune(s, r) >= 0\n}\n\n// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\nfunc LastIndex(s, substr string) int {\n\tn := len(substr)\n\tswitch {\n\tcase n == 0:\n\t\treturn len(s)\n\tcase n == 1:\n\t\treturn LastIndexByte(s, substr[0])\n\tcase n == len(s):\n\t\tif substr == s {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n > len(s):\n\t\treturn -1\n\t}\n\t// Rabin-Karp search from the end of the string\n\thashss, pow := bytealg.HashStrRev(substr)\n\tlast := len(s) - n\n\tvar h uint32\n\tfor i := len(s) - 1; i >= last; i-- {\n\t\th = h*bytealg.PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && s[last:] == substr {\n\t\treturn last\n\t}\n\tfor i := last - 1; i >= 0; i-- {\n\t\th *= bytealg.PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashss && s[i:i+n] == substr {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\nfunc IndexByte(s string, c byte) int {\n\treturn bytealg.IndexByteString(s, c)\n}\n\n// IndexRune returns the index of the first instance of the Unicode code point\n// r, or -1 if rune is not present in s.\n// If r is utf8.RuneError, it returns the first instance of any\n// invalid UTF-8 byte sequence.\nfunc IndexRune(s string, r rune) int {\n\tswitch {\n\tcase 0 <= r && r < utf8.RuneSelf:\n\t\treturn IndexByte(s, byte(r))\n\tcase r == utf8.RuneError:\n\t\tfor i, r := range s {\n\t\t\tif r == utf8.RuneError {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\tcase !utf8.ValidRune(r):\n\t\treturn -1\n\tdefault:\n\t\treturn Index(s, string(r))\n\t}\n}\n\n// IndexAny returns the index of the first instance of any Unicode code point\n// from chars in s, or -1 if no Unicode code point from chars is present in s.\nfunc IndexAny(s, chars string) int {\n\tif chars == \"\" {\n\t\t// Avoid scanning all of s.\n\t\treturn -1\n\t}\n\tif len(chars) == 1 {\n\t\t// Avoid scanning all of s.\n\t\tr := rune(chars[0])\n\t\tif r >= utf8.RuneSelf {\n\t\t\tr = utf8.RuneError\n\t\t}\n\t\treturn IndexRune(s, r)\n\t}\n\tif len(s) > 8 {\n\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n\t\t\tfor i := 0; i < len(s); i++ {\n\t\t\t\tif as.contains(s[i]) {\n\t\t\t\t\treturn i\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1\n\t\t}\n\t}\n\tfor i, c := range s {\n\t\tif IndexRune(chars, c) >= 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// LastIndexAny returns the index of the last instance of any Unicode code\n// point from chars in s, or -1 if no Unicode code point from chars is\n// present in s.\nfunc LastIndexAny(s, chars string) int {\n\tif chars == \"\" {\n\t\t// Avoid scanning all of s.\n\t\treturn -1\n\t}\n\tif len(s) == 1 {\n\t\trc := rune(s[0])\n\t\tif rc >= utf8.RuneSelf {\n\t\t\trc = utf8.RuneError\n\t\t}\n\t\tif IndexRune(chars, rc) >= 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\t}\n\tif len(s) > 8 {\n\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n\t\t\tfor i := len(s) - 1; i >= 0; i-- {\n\t\t\t\tif as.contains(s[i]) {\n\t\t\t\t\treturn i\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1\n\t\t}\n\t}\n\tif len(chars) == 1 {\n\t\trc := rune(chars[0])\n\t\tif rc >= utf8.RuneSelf {\n\t\t\trc = utf8.RuneError\n\t\t}\n\t\tfor i := len(s); i > 0; {\n\t\t\tr, size := utf8.DecodeLastRuneInString(s[:i])\n\t\t\ti -= size\n\t\t\tif rc == r {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tfor i := len(s); i > 0; {\n\t\tr, size := utf8.DecodeLastRuneInString(s[:i])\n\t\ti -= size\n\t\tif IndexRune(chars, r) >= 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\nfunc LastIndexByte(s string, c byte) int {\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// Generic split: splits after each instance of sep,\n// including sepSave bytes of sep in the subarrays.\nfunc genSplit(s, sep string, sepSave, n int) []string {\n\tif n == 0 {\n\t\treturn nil\n\t}\n\tif sep == \"\" {\n\t\treturn explode(s, n)\n\t}\n\tif n < 0 {\n\t\tn = Count(s, sep) + 1\n\t}\n\n\ta := make([]string, n)\n\tn--\n\ti := 0\n\tfor i < n {\n\t\tm := Index(s, sep)\n\t\tif m < 0 {\n\t\t\tbreak\n\t\t}\n\t\ta[i] = s[:m+sepSave]\n\t\ts = s[m+len(sep):]\n\t\ti++\n\t}\n\ta[i] = s\n\treturn a[:i+1]\n}\n\n// SplitN slices s into substrings separated by sep and returns a slice of\n// the substrings between those separators.\n//\n// The count determines the number of substrings to return:\n//   n > 0: at most n substrings; the last substring will be the unsplit remainder.\n//   n == 0: the result is nil (zero substrings)\n//   n < 0: all substrings\n//\n// Edge cases for s and sep (for example, empty strings) are handled\n// as described in the documentation for Split.\nfunc SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }\n\n// SplitAfterN slices s into substrings after each instance of sep and\n// returns a slice of those substrings.\n//\n// The count determines the number of substrings to return:\n//   n > 0: at most n substrings; the last substring will be the unsplit remainder.\n//   n == 0: the result is nil (zero substrings)\n//   n < 0: all substrings\n//\n// Edge cases for s and sep (for example, empty strings) are handled\n// as described in the documentation for SplitAfter.\nfunc SplitAfterN(s, sep string, n int) []string {\n\treturn genSplit(s, sep, len(sep), n)\n}\n\n// Split slices s into all substrings separated by sep and returns a slice of\n// the substrings between those separators.\n//\n// If s does not contain sep and sep is not empty, Split returns a\n// slice of length 1 whose only element is s.\n//\n// If sep is empty, Split splits after each UTF-8 sequence. If both s\n// and sep are empty, Split returns an empty slice.\n//\n// It is equivalent to SplitN with a count of -1.\nfunc Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }\n\n// SplitAfter slices s into all substrings after each instance of sep and\n// returns a slice of those substrings.\n//\n// If s does not contain sep and sep is not empty, SplitAfter returns\n// a slice of length 1 whose only element is s.\n//\n// If sep is empty, SplitAfter splits after each UTF-8 sequence. If\n// both s and sep are empty, SplitAfter returns an empty slice.\n//\n// It is equivalent to SplitAfterN with a count of -1.\nfunc SplitAfter(s, sep string) []string {\n\treturn genSplit(s, sep, len(sep), -1)\n}\n\nvar asciiSpace = [256]uint8{'\\t': 1, '\\n': 1, '\\v': 1, '\\f': 1, '\\r': 1, ' ': 1}\n\n// Fields splits the string s around each instance of one or more consecutive white space\n// characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\n// empty slice if s contains only white space.\nfunc Fields(s string) []string {\n\t// First count the fields.\n\t// This is an exact count if s is ASCII, otherwise it is an approximation.\n\tn := 0\n\twasSpace := 1\n\t// setBits is used to track which bits are set in the bytes of s.\n\tsetBits := uint8(0)\n\tfor i := 0; i < len(s); i++ {\n\t\tr := s[i]\n\t\tsetBits |= r\n\t\tisSpace := int(asciiSpace[r])\n\t\tn += wasSpace & ^isSpace\n\t\twasSpace = isSpace\n\t}\n\n\tif setBits >= utf8.RuneSelf {\n\t\t// Some runes in the input string are not ASCII.\n\t\treturn FieldsFunc(s, unicode.IsSpace)\n\t}\n\t// ASCII fast path\n\ta := make([]string, n)\n\tna := 0\n\tfieldStart := 0\n\ti := 0\n\t// Skip spaces in the front of the input.\n\tfor i < len(s) && asciiSpace[s[i]] != 0 {\n\t\ti++\n\t}\n\tfieldStart = i\n\tfor i < len(s) {\n\t\tif asciiSpace[s[i]] == 0 {\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\ta[na] = s[fieldStart:i]\n\t\tna++\n\t\ti++\n\t\t// Skip spaces in between fields.\n\t\tfor i < len(s) && asciiSpace[s[i]] != 0 {\n\t\t\ti++\n\t\t}\n\t\tfieldStart = i\n\t}\n\tif fieldStart < len(s) { // Last field might end at EOF.\n\t\ta[na] = s[fieldStart:]\n\t}\n\treturn a\n}\n\n// FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\n// and returns an array of slices of s. If all code points in s satisfy f(c) or the\n// string is empty, an empty slice is returned.\n//\n// FieldsFunc makes no guarantees about the order in which it calls f(c)\n// and assumes that f always returns the same value for a given c.\nfunc FieldsFunc(s string, f func(rune) bool) []string {\n\t// A span is used to record a slice of s of the form s[start:end].\n\t// The start index is inclusive and the end index is exclusive.\n\ttype span struct {\n\t\tstart int\n\t\tend   int\n\t}\n\tspans := make([]span, 0, 32)\n\n\t// Find the field start and end indices.\n\t// Doing this in a separate pass (rather than slicing the string s\n\t// and collecting the result substrings right away) is significantly\n\t// more efficient, possibly due to cache effects.\n\tstart := -1 // valid span start if >= 0\n\tfor end, rune := range s {\n\t\tif f(rune) {\n\t\t\tif start >= 0 {\n\t\t\t\tspans = append(spans, span{start, end})\n\t\t\t\t// Set start to a negative value.\n\t\t\t\t// Note: using -1 here consistently and reproducibly\n\t\t\t\t// slows down this code by a several percent on amd64.\n\t\t\t\tstart = ^start\n\t\t\t}\n\t\t} else {\n\t\t\tif start < 0 {\n\t\t\t\tstart = end\n\t\t\t}\n\t\t}\n\t}\n\n\t// Last field might end at EOF.\n\tif start >= 0 {\n\t\tspans = append(spans, span{start, len(s)})\n\t}\n\n\t// Create strings from recorded field indices.\n\ta := make([]string, len(spans))\n\tfor i, span := range spans {\n\t\ta[i] = s[span.start:span.end]\n\t}\n\n\treturn a\n}\n\n// Join concatenates the elements of its first argument to create a single string. The separator\n// string sep is placed between elements in the resulting string.\nfunc Join(elems []string, sep string) string {\n\tswitch len(elems) {\n\tcase 0:\n\t\treturn \"\"\n\tcase 1:\n\t\treturn elems[0]\n\t}\n\tn := len(sep) * (len(elems) - 1)\n\tfor i := 0; i < len(elems); i++ {\n\t\tn += len(elems[i])\n\t}\n\n\tvar b Builder\n\tb.Grow(n)\n\tb.WriteString(elems[0])\n\tfor _, s := range elems[1:] {\n\t\tb.WriteString(sep)\n\t\tb.WriteString(s)\n\t}\n\treturn b.String()\n}\n\n// HasPrefix tests whether the string s begins with prefix.\nfunc HasPrefix(s, prefix string) bool {\n\treturn len(s) >= len(prefix) && s[0:len(prefix)] == prefix\n}\n\n// HasSuffix tests whether the string s ends with suffix.\nfunc HasSuffix(s, suffix string) bool {\n\treturn len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix\n}\n\n// Map returns a copy of the string s with all its characters modified\n// according to the mapping function. If mapping returns a negative value, the character is\n// dropped from the string with no replacement.\nfunc Map(mapping func(rune) rune, s string) string {\n\t// In the worst case, the string can grow when mapped, making\n\t// things unpleasant. But it's so rare we barge in assuming it's\n\t// fine. It could also shrink but that falls out naturally.\n\n\t// The output buffer b is initialized on demand, the first\n\t// time a character differs.\n\tvar b Builder\n\n\tfor i, c := range s {\n\t\tr := mapping(c)\n\t\tif r == c && c != utf8.RuneError {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar width int\n\t\tif c == utf8.RuneError {\n\t\t\tc, width = utf8.DecodeRuneInString(s[i:])\n\t\t\tif width != 1 && r == c {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else {\n\t\t\twidth = utf8.RuneLen(c)\n\t\t}\n\n\t\tb.Grow(len(s) + utf8.UTFMax)\n\t\tb.WriteString(s[:i])\n\t\tif r >= 0 {\n\t\t\tb.WriteRune(r)\n\t\t}\n\n\t\ts = s[i+width:]\n\t\tbreak\n\t}\n\n\t// Fast path for unchanged input\n\tif b.Cap() == 0 { // didn't call b.Grow above\n\t\treturn s\n\t}\n\n\tfor _, c := range s {\n\t\tr := mapping(c)\n\n\t\tif r >= 0 {\n\t\t\t// common case\n\t\t\t// Due to inlining, it is more performant to determine if WriteByte should be\n\t\t\t// invoked rather than always call WriteRune\n\t\t\tif r < utf8.RuneSelf {\n\t\t\t\tb.WriteByte(byte(r))\n\t\t\t} else {\n\t\t\t\t// r is not a ASCII rune.\n\t\t\t\tb.WriteRune(r)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// Repeat returns a new string consisting of count copies of the string s.\n//\n// It panics if count is negative or if\n// the result of (len(s) * count) overflows.\nfunc Repeat(s string, count int) string {\n\tif count == 0 {\n\t\treturn \"\"\n\t}\n\n\t// Since we cannot return an error on overflow,\n\t// we should panic if the repeat will generate\n\t// an overflow.\n\t// See Issue golang.org/issue/16237\n\tif count < 0 {\n\t\tpanic(\"strings: negative Repeat count\")\n\t} else if len(s)*count/count != len(s) {\n\t\tpanic(\"strings: Repeat count causes overflow\")\n\t}\n\n\tn := len(s) * count\n\tvar b Builder\n\tb.Grow(n)\n\tb.WriteString(s)\n\tfor b.Len() < n {\n\t\tif b.Len() <= n/2 {\n\t\t\tb.WriteString(b.String())\n\t\t} else {\n\t\t\tb.WriteString(b.String()[:n-b.Len()])\n\t\t\tbreak\n\t\t}\n\t}\n\treturn b.String()\n}\n\n// ToUpper returns s with all Unicode letters mapped to their upper case.\nfunc ToUpper(s string) string {\n\tisASCII, hasLower := true, false\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c >= utf8.RuneSelf {\n\t\t\tisASCII = false\n\t\t\tbreak\n\t\t}\n\t\thasLower = hasLower || ('a' <= c && c <= 'z')\n\t}\n\n\tif isASCII { // optimize for ASCII-only strings.\n\t\tif !hasLower {\n\t\t\treturn s\n\t\t}\n\t\tvar b Builder\n\t\tb.Grow(len(s))\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tc := s[i]\n\t\t\tif 'a' <= c && c <= 'z' {\n\t\t\t\tc -= 'a' - 'A'\n\t\t\t}\n\t\t\tb.WriteByte(c)\n\t\t}\n\t\treturn b.String()\n\t}\n\treturn Map(unicode.ToUpper, s)\n}\n\n// ToLower returns s with all Unicode letters mapped to their lower case.\nfunc ToLower(s string) string {\n\tisASCII, hasUpper := true, false\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c >= utf8.RuneSelf {\n\t\t\tisASCII = false\n\t\t\tbreak\n\t\t}\n\t\thasUpper = hasUpper || ('A' <= c && c <= 'Z')\n\t}\n\n\tif isASCII { // optimize for ASCII-only strings.\n\t\tif !hasUpper {\n\t\t\treturn s\n\t\t}\n\t\tvar b Builder\n\t\tb.Grow(len(s))\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tc := s[i]\n\t\t\tif 'A' <= c && c <= 'Z' {\n\t\t\t\tc += 'a' - 'A'\n\t\t\t}\n\t\t\tb.WriteByte(c)\n\t\t}\n\t\treturn b.String()\n\t}\n\treturn Map(unicode.ToLower, s)\n}\n\n// ToTitle returns a copy of the string s with all Unicode letters mapped to\n// their Unicode title case.\nfunc ToTitle(s string) string { return Map(unicode.ToTitle, s) }\n\n// ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\n// upper case using the case mapping specified by c.\nfunc ToUpperSpecial(c unicode.SpecialCase, s string) string {\n\treturn Map(c.ToUpper, s)\n}\n\n// ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\n// lower case using the case mapping specified by c.\nfunc ToLowerSpecial(c unicode.SpecialCase, s string) string {\n\treturn Map(c.ToLower, s)\n}\n\n// ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\n// Unicode title case, giving priority to the special casing rules.\nfunc ToTitleSpecial(c unicode.SpecialCase, s string) string {\n\treturn Map(c.ToTitle, s)\n}\n\n// ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences\n// replaced by the replacement string, which may be empty.\nfunc ToValidUTF8(s, replacement string) string {\n\tvar b Builder\n\n\tfor i, c := range s {\n\t\tif c != utf8.RuneError {\n\t\t\tcontinue\n\t\t}\n\n\t\t_, wid := utf8.DecodeRuneInString(s[i:])\n\t\tif wid == 1 {\n\t\t\tb.Grow(len(s) + len(replacement))\n\t\t\tb.WriteString(s[:i])\n\t\t\ts = s[i:]\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Fast path for unchanged input\n\tif b.Cap() == 0 { // didn't call b.Grow above\n\t\treturn s\n\t}\n\n\tinvalid := false // previous byte was from an invalid UTF-8 sequence\n\tfor i := 0; i < len(s); {\n\t\tc := s[i]\n\t\tif c < utf8.RuneSelf {\n\t\t\ti++\n\t\t\tinvalid = false\n\t\t\tb.WriteByte(c)\n\t\t\tcontinue\n\t\t}\n\t\t_, wid := utf8.DecodeRuneInString(s[i:])\n\t\tif wid == 1 {\n\t\t\ti++\n\t\t\tif !invalid {\n\t\t\t\tinvalid = true\n\t\t\t\tb.WriteString(replacement)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tinvalid = false\n\t\tb.WriteString(s[i : i+wid])\n\t\ti += wid\n\t}\n\n\treturn b.String()\n}\n\n// isSeparator reports whether the rune could mark a word boundary.\n// TODO: update when package unicode captures more of the properties.\nfunc isSeparator(r rune) bool {\n\t// ASCII alphanumerics and underscore are not separators\n\tif r <= 0x7F {\n\t\tswitch {\n\t\tcase '0' <= r && r <= '9':\n\t\t\treturn false\n\t\tcase 'a' <= r && r <= 'z':\n\t\t\treturn false\n\t\tcase 'A' <= r && r <= 'Z':\n\t\t\treturn false\n\t\tcase r == '_':\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\t// Letters and digits are not separators\n\tif unicode.IsLetter(r) || unicode.IsDigit(r) {\n\t\treturn false\n\t}\n\t// Otherwise, all we can do for now is treat spaces as separators.\n\treturn unicode.IsSpace(r)\n}\n\n// Title returns a copy of the string s with all Unicode letters that begin words\n// mapped to their Unicode title case.\n//\n// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\nfunc Title(s string) string {\n\t// Use a closure here to remember state.\n\t// Hackish but effective. Depends on Map scanning in order and calling\n\t// the closure once per rune.\n\tprev := ' '\n\treturn Map(\n\t\tfunc(r rune) rune {\n\t\t\tif isSeparator(prev) {\n\t\t\t\tprev = r\n\t\t\t\treturn unicode.ToTitle(r)\n\t\t\t}\n\t\t\tprev = r\n\t\t\treturn r\n\t\t},\n\t\ts)\n}\n\n// TrimLeftFunc returns a slice of the string s with all leading\n// Unicode code points c satisfying f(c) removed.\nfunc TrimLeftFunc(s string, f func(rune) bool) string {\n\ti := indexFunc(s, f, false)\n\tif i == -1 {\n\t\treturn \"\"\n\t}\n\treturn s[i:]\n}\n\n// TrimRightFunc returns a slice of the string s with all trailing\n// Unicode code points c satisfying f(c) removed.\nfunc TrimRightFunc(s string, f func(rune) bool) string {\n\ti := lastIndexFunc(s, f, false)\n\tif i >= 0 && s[i] >= utf8.RuneSelf {\n\t\t_, wid := utf8.DecodeRuneInString(s[i:])\n\t\ti += wid\n\t} else {\n\t\ti++\n\t}\n\treturn s[0:i]\n}\n\n// TrimFunc returns a slice of the string s with all leading\n// and trailing Unicode code points c satisfying f(c) removed.\nfunc TrimFunc(s string, f func(rune) bool) string {\n\treturn TrimRightFunc(TrimLeftFunc(s, f), f)\n}\n\n// IndexFunc returns the index into s of the first Unicode\n// code point satisfying f(c), or -1 if none do.\nfunc IndexFunc(s string, f func(rune) bool) int {\n\treturn indexFunc(s, f, true)\n}\n\n// LastIndexFunc returns the index into s of the last\n// Unicode code point satisfying f(c), or -1 if none do.\nfunc LastIndexFunc(s string, f func(rune) bool) int {\n\treturn lastIndexFunc(s, f, true)\n}\n\n// indexFunc is the same as IndexFunc except that if\n// truth==false, the sense of the predicate function is\n// inverted.\nfunc indexFunc(s string, f func(rune) bool, truth bool) int {\n\tfor i, r := range s {\n\t\tif f(r) == truth {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// lastIndexFunc is the same as LastIndexFunc except that if\n// truth==false, the sense of the predicate function is\n// inverted.\nfunc lastIndexFunc(s string, f func(rune) bool, truth bool) int {\n\tfor i := len(s); i > 0; {\n\t\tr, size := utf8.DecodeLastRuneInString(s[0:i])\n\t\ti -= size\n\t\tif f(r) == truth {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// asciiSet is a 32-byte value, where each bit represents the presence of a\n// given ASCII character in the set. The 128-bits of the lower 16 bytes,\n// starting with the least-significant bit of the lowest word to the\n// most-significant bit of the highest word, map to the full range of all\n// 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,\n// ensuring that any non-ASCII character will be reported as not in the set.\ntype asciiSet [8]uint32\n\n// makeASCIISet creates a set of ASCII characters and reports whether all\n// characters in chars are ASCII.\nfunc makeASCIISet(chars string) (as asciiSet, ok bool) {\n\tfor i := 0; i < len(chars); i++ {\n\t\tc := chars[i]\n\t\tif c >= utf8.RuneSelf {\n\t\t\treturn as, false\n\t\t}\n\t\tas[c>>5] |= 1 << uint(c&31)\n\t}\n\treturn as, true\n}\n\n// contains reports whether c is inside the set.\nfunc (as *asciiSet) contains(c byte) bool {\n\treturn (as[c>>5] & (1 << uint(c&31))) != 0\n}\n\nfunc makeCutsetFunc(cutset string) func(rune) bool {\n\tif len(cutset) == 1 && cutset[0] < utf8.RuneSelf {\n\t\treturn func(r rune) bool {\n\t\t\treturn r == rune(cutset[0])\n\t\t}\n\t}\n\tif as, isASCII := makeASCIISet(cutset); isASCII {\n\t\treturn func(r rune) bool {\n\t\t\treturn r < utf8.RuneSelf && as.contains(byte(r))\n\t\t}\n\t}\n\treturn func(r rune) bool { return IndexRune(cutset, r) >= 0 }\n}\n\n// Trim returns a slice of the string s with all leading and\n// trailing Unicode code points contained in cutset removed.\nfunc Trim(s, cutset string) string {\n\tif s == \"\" || cutset == \"\" {\n\t\treturn s\n\t}\n\treturn TrimFunc(s, makeCutsetFunc(cutset))\n}\n\n// TrimLeft returns a slice of the string s with all leading\n// Unicode code points contained in cutset removed.\n//\n// To remove a prefix, use TrimPrefix instead.\nfunc TrimLeft(s, cutset string) string {\n\tif s == \"\" || cutset == \"\" {\n\t\treturn s\n\t}\n\treturn TrimLeftFunc(s, makeCutsetFunc(cutset))\n}\n\n// TrimRight returns a slice of the string s, with all trailing\n// Unicode code points contained in cutset removed.\n//\n// To remove a suffix, use TrimSuffix instead.\nfunc TrimRight(s, cutset string) string {\n\tif s == \"\" || cutset == \"\" {\n\t\treturn s\n\t}\n\treturn TrimRightFunc(s, makeCutsetFunc(cutset))\n}\n\n// TrimSpace returns a slice of the string s, with all leading\n// and trailing white space removed, as defined by Unicode.\nfunc TrimSpace(s string) string {\n\t// Fast path for ASCII: look for the first ASCII non-space byte\n\tstart := 0\n\tfor ; start < len(s); start++ {\n\t\tc := s[start]\n\t\tif c >= utf8.RuneSelf {\n\t\t\t// If we run into a non-ASCII byte, fall back to the\n\t\t\t// slower unicode-aware method on the remaining bytes\n\t\t\treturn TrimFunc(s[start:], unicode.IsSpace)\n\t\t}\n\t\tif asciiSpace[c] == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Now look for the first ASCII non-space byte from the end\n\tstop := len(s)\n\tfor ; stop > start; stop-- {\n\t\tc := s[stop-1]\n\t\tif c >= utf8.RuneSelf {\n\t\t\treturn TrimFunc(s[start:stop], unicode.IsSpace)\n\t\t}\n\t\tif asciiSpace[c] == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// At this point s[start:stop] starts and ends with an ASCII\n\t// non-space bytes, so we're done. Non-ASCII cases have already\n\t// been handled above.\n\treturn s[start:stop]\n}\n\n// TrimPrefix returns s without the provided leading prefix string.\n// If s doesn't start with prefix, s is returned unchanged.\nfunc TrimPrefix(s, prefix string) string {\n\tif HasPrefix(s, prefix) {\n\t\treturn s[len(prefix):]\n\t}\n\treturn s\n}\n\n// TrimSuffix returns s without the provided trailing suffix string.\n// If s doesn't end with suffix, s is returned unchanged.\nfunc TrimSuffix(s, suffix string) string {\n\tif HasSuffix(s, suffix) {\n\t\treturn s[:len(s)-len(suffix)]\n\t}\n\treturn s\n}\n\n// Replace returns a copy of the string s with the first n\n// non-overlapping instances of old replaced by new.\n// If old is empty, it matches at the beginning of the string\n// and after each UTF-8 sequence, yielding up to k+1 replacements\n// for a k-rune string.\n// If n < 0, there is no limit on the number of replacements.\nfunc Replace(s, old, new string, n int) string {\n\tif old == new || n == 0 {\n\t\treturn s // avoid allocation\n\t}\n\n\t// Compute number of replacements.\n\tif m := Count(s, old); m == 0 {\n\t\treturn s // avoid allocation\n\t} else if n < 0 || m < n {\n\t\tn = m\n\t}\n\n\t// Apply replacements to buffer.\n\tvar b Builder\n\tb.Grow(len(s) + n*(len(new)-len(old)))\n\tstart := 0\n\tfor i := 0; i < n; i++ {\n\t\tj := start\n\t\tif len(old) == 0 {\n\t\t\tif i > 0 {\n\t\t\t\t_, wid := utf8.DecodeRuneInString(s[start:])\n\t\t\t\tj += wid\n\t\t\t}\n\t\t} else {\n\t\t\tj += Index(s[start:], old)\n\t\t}\n\t\tb.WriteString(s[start:j])\n\t\tb.WriteString(new)\n\t\tstart = j + len(old)\n\t}\n\tb.WriteString(s[start:])\n\treturn b.String()\n}\n\n// ReplaceAll returns a copy of the string s with all\n// non-overlapping instances of old replaced by new.\n// If old is empty, it matches at the beginning of the string\n// and after each UTF-8 sequence, yielding up to k+1 replacements\n// for a k-rune string.\nfunc ReplaceAll(s, old, new string) string {\n\treturn Replace(s, old, new, -1)\n}\n\n// EqualFold reports whether s and t, interpreted as UTF-8 strings,\n// are equal under Unicode case-folding, which is a more general\n// form of case-insensitivity.\nfunc EqualFold(s, t string) bool {\n\tfor s != \"\" && t != \"\" {\n\t\t// Extract first rune from each string.\n\t\tvar sr, tr rune\n\t\tif s[0] < utf8.RuneSelf {\n\t\t\tsr, s = rune(s[0]), s[1:]\n\t\t} else {\n\t\t\tr, size := utf8.DecodeRuneInString(s)\n\t\t\tsr, s = r, s[size:]\n\t\t}\n\t\tif t[0] < utf8.RuneSelf {\n\t\t\ttr, t = rune(t[0]), t[1:]\n\t\t} else {\n\t\t\tr, size := utf8.DecodeRuneInString(t)\n\t\t\ttr, t = r, t[size:]\n\t\t}\n\n\t\t// If they match, keep going; if not, return false.\n\n\t\t// Easy case.\n\t\tif tr == sr {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Make sr < tr to simplify what follows.\n\t\tif tr < sr {\n\t\t\ttr, sr = sr, tr\n\t\t}\n\t\t// Fast check for ASCII.\n\t\tif tr < utf8.RuneSelf {\n\t\t\t// ASCII only, sr/tr must be upper/lower case\n\t\t\tif 'A' <= sr && sr <= 'Z' && tr == sr+'a'-'A' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\n\t\t// General case. SimpleFold(x) returns the next equivalent rune > x\n\t\t// or wraps around to smaller values.\n\t\tr := unicode.SimpleFold(sr)\n\t\tfor r != sr && r < tr {\n\t\t\tr = unicode.SimpleFold(r)\n\t\t}\n\t\tif r == tr {\n\t\t\tcontinue\n\t\t}\n\t\treturn false\n\t}\n\n\t// One string is empty. Are both?\n\treturn s == t\n}\n\n// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\nfunc Index(s, substr string) int {\n\tn := len(substr)\n\tswitch {\n\tcase n == 0:\n\t\treturn 0\n\tcase n == 1:\n\t\treturn IndexByte(s, substr[0])\n\tcase n == len(s):\n\t\tif substr == s {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n > len(s):\n\t\treturn -1\n\tcase n <= bytealg.MaxLen:\n\t\t// Use brute force when s and substr both are small\n\t\tif len(s) <= bytealg.MaxBruteForce {\n\t\t\treturn bytealg.IndexString(s, substr)\n\t\t}\n\t\tc0 := substr[0]\n\t\tc1 := substr[1]\n\t\ti := 0\n\t\tt := len(s) - n + 1\n\t\tfails := 0\n\t\tfor i < t {\n\t\t\tif s[i] != c0 {\n\t\t\t\t// IndexByte is faster than bytealg.IndexString, so use it as long as\n\t\t\t\t// we're not getting lots of false positives.\n\t\t\t\to := IndexByte(s[i+1:t], c0)\n\t\t\t\tif o < 0 {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t\ti += o + 1\n\t\t\t}\n\t\t\tif s[i+1] == c1 && s[i:i+n] == substr {\n\t\t\t\treturn i\n\t\t\t}\n\t\t\tfails++\n\t\t\ti++\n\t\t\t// Switch to bytealg.IndexString when IndexByte produces too many false positives.\n\t\t\tif fails > bytealg.Cutover(i) {\n\t\t\t\tr := bytealg.IndexString(s[i:], substr)\n\t\t\t\tif r >= 0 {\n\t\t\t\t\treturn r + i\n\t\t\t\t}\n\t\t\t\treturn -1\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\tc0 := substr[0]\n\tc1 := substr[1]\n\ti := 0\n\tt := len(s) - n + 1\n\tfails := 0\n\tfor i < t {\n\t\tif s[i] != c0 {\n\t\t\to := IndexByte(s[i+1:t], c0)\n\t\t\tif o < 0 {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\ti += o + 1\n\t\t}\n\t\tif s[i+1] == c1 && s[i:i+n] == substr {\n\t\t\treturn i\n\t\t}\n\t\ti++\n\t\tfails++\n\t\tif fails >= 4+i>>4 && i < t {\n\t\t\t// See comment in ../bytes/bytes.go.\n\t\t\tj := bytealg.IndexRabinKarp(s[i:], substr)\n\t\t\tif j < 0 {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\treturn i + j\n\t\t}\n\t}\n\treturn -1\n}\n","package bytealg\n\nconst (\n\t// Index can search any valid length of string.\n\n\tMaxLen        = int(-1) >> 31\n\tMaxBruteForce = MaxLen\n)\n\n// Compare two byte slices.\n// Returns -1 if the first differing byte is lower in a, or 1 if the first differing byte is greater in b.\n// If the byte slices are equal, returns 0.\n// If the lengths are different and there are no differing bytes, compares based on length.\nfunc Compare(a, b []byte) int {\n\t// Compare for differing bytes.\n\tfor i := 0; i < len(a) && i < len(b); i++ {\n\t\tswitch {\n\t\tcase a[i] < b[i]:\n\t\t\treturn -1\n\t\tcase a[i] > b[i]:\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t// Compare lengths.\n\tswitch {\n\tcase len(a) > len(b):\n\t\treturn 1\n\tcase len(a) < len(b):\n\t\treturn -1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\n// Count the number of instances of a byte in a slice.\nfunc Count(b []byte, c byte) int {\n\t// Use a simple implementation, as there is no intrinsic that does this like we want.\n\tn := 0\n\tfor _, v := range b {\n\t\tif v == c {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}\n\n// Count the number of instances of a byte in a string.\nfunc CountString(s string, c byte) int {\n\t// Use a simple implementation, as there is no intrinsic that does this like we want.\n\t// Currently, the compiler does not generate zero-copy byte-string conversions, so this needs to be seperate from Count.\n\tn := 0\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}\n\n// Cutover is not reachable in TinyGo, but must exist as it is referenced.\nfunc Cutover(n int) int {\n\t// Setting MaxLen and MaxBruteForce should force a different path to be taken.\n\t// This should never be called.\n\tpanic(\"cutover is unreachable\")\n}\n\n// Equal checks if two byte slices are equal.\n// It is equivalent to bytes.Equal.\nfunc Equal(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// Index finds the base index of the first instance of the byte sequence b in a.\n// If a does not contain b, this returns -1.\nfunc Index(a, b []byte) int {\n\tfor i := 0; i <= len(a)-len(b); i++ {\n\t\tif Equal(a[i:i+len(b)], b) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// Index finds the index of the first instance of the specified byte in the slice.\n// If the byte is not found, this returns -1.\nfunc IndexByte(b []byte, c byte) int {\n\tfor i, v := range b {\n\t\tif v == c {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// Index finds the index of the first instance of the specified byte in the string.\n// If the byte is not found, this returns -1.\nfunc IndexByteString(s string, c byte) int {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// Index finds the base index of the first instance of a substring in a string.\n// If the substring is not found, this returns -1.\nfunc IndexString(str, sub string) int {\n\tfor i := 0; i <= len(str)-len(sub); i++ {\n\t\tif str[i:i+len(sub)] == sub {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// Copyright 2020 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// The following code has been copied from the Go 1.15 release tree.\n\n// PrimeRK is the prime base used in Rabin-Karp algorithm.\nconst PrimeRK = 16777619\n\n// HashStrBytes returns the hash and the appropriate multiplicative\n// factor for use in Rabin-Karp algorithm.\nfunc HashStrBytes(sep []byte) (uint32, uint32) {\n\thash := uint32(0)\n\tfor i := 0; i < len(sep); i++ {\n\t\thash = hash*PrimeRK + uint32(sep[i])\n\t}\n\tvar pow, sq uint32 = 1, PrimeRK\n\tfor i := len(sep); i > 0; i >>= 1 {\n\t\tif i&1 != 0 {\n\t\t\tpow *= sq\n\t\t}\n\t\tsq *= sq\n\t}\n\treturn hash, pow\n}\n\n// HashStr returns the hash and the appropriate multiplicative\n// factor for use in Rabin-Karp algorithm.\nfunc HashStr(sep string) (uint32, uint32) {\n\thash := uint32(0)\n\tfor i := 0; i < len(sep); i++ {\n\t\thash = hash*PrimeRK + uint32(sep[i])\n\t}\n\tvar pow, sq uint32 = 1, PrimeRK\n\tfor i := len(sep); i > 0; i >>= 1 {\n\t\tif i&1 != 0 {\n\t\t\tpow *= sq\n\t\t}\n\t\tsq *= sq\n\t}\n\treturn hash, pow\n}\n\n// HashStrRevBytes returns the hash of the reverse of sep and the\n// appropriate multiplicative factor for use in Rabin-Karp algorithm.\nfunc HashStrRevBytes(sep []byte) (uint32, uint32) {\n\thash := uint32(0)\n\tfor i := len(sep) - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(sep[i])\n\t}\n\tvar pow, sq uint32 = 1, PrimeRK\n\tfor i := len(sep); i > 0; i >>= 1 {\n\t\tif i&1 != 0 {\n\t\t\tpow *= sq\n\t\t}\n\t\tsq *= sq\n\t}\n\treturn hash, pow\n}\n\n// HashStrRev returns the hash of the reverse of sep and the\n// appropriate multiplicative factor for use in Rabin-Karp algorithm.\nfunc HashStrRev(sep string) (uint32, uint32) {\n\thash := uint32(0)\n\tfor i := len(sep) - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(sep[i])\n\t}\n\tvar pow, sq uint32 = 1, PrimeRK\n\tfor i := len(sep); i > 0; i >>= 1 {\n\t\tif i&1 != 0 {\n\t\t\tpow *= sq\n\t\t}\n\t\tsq *= sq\n\t}\n\treturn hash, pow\n}\n\n// IndexRabinKarpBytes uses the Rabin-Karp search algorithm to return the index of the\n// first occurence of substr in s, or -1 if not present.\nfunc IndexRabinKarpBytes(s, sep []byte) int {\n\t// Rabin-Karp search\n\thashsep, pow := HashStrBytes(sep)\n\tn := len(sep)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashsep && Equal(s[:n], sep) {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashsep && Equal(s[i-n:i], sep) {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}\n\n// IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the\n// first occurence of substr in s, or -1 if not present.\nfunc IndexRabinKarp(s, substr string) int {\n\t// Rabin-Karp search\n\thashss, pow := HashStr(substr)\n\tn := len(substr)\n\tvar h uint32\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[i])\n\t}\n\tif h == hashss && s[:n] == substr {\n\t\treturn 0\n\t}\n\tfor i := n; i < len(s); {\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i-n])\n\t\ti++\n\t\tif h == hashss && s[i-n:i] == substr {\n\t\t\treturn i - n\n\t\t}\n\t}\n\treturn -1\n}\n","// +build baremetal wasm,!wasi\n\npackage os\n\nimport (\n\t_ \"unsafe\"\n)\n\n// Stdin, Stdout, and Stderr are open Files pointing to the standard input,\n// standard output, and standard error file descriptors.\nvar (\n\tStdin  = &File{stdioFileHandle(0), \"/dev/stdin\"}\n\tStdout = &File{stdioFileHandle(1), \"/dev/stdout\"}\n\tStderr = &File{stdioFileHandle(2), \"/dev/stderr\"}\n)\n\n// isOS indicates whether we're running on a real operating system with\n// filesystem support.\nconst isOS = false\n\n// stdioFileHandle represents one of stdin, stdout, or stderr depending on the\n// number. It implements the FileHandle interface.\ntype stdioFileHandle uint8\n\n// Read is unsupported on this system.\nfunc (f stdioFileHandle) Read(b []byte) (n int, err error) {\n\treturn 0, ErrUnsupported\n}\n\nfunc (f stdioFileHandle) ReadAt(b []byte, off int64) (n int, err error) {\n\treturn 0, ErrNotImplemented\n}\n\n// Write writes len(b) bytes to the output. It returns the number of bytes\n// written or an error if this file is not stdout or stderr.\nfunc (f stdioFileHandle) Write(b []byte) (n int, err error) {\n\tswitch f {\n\tcase 1, 2: // stdout, stderr\n\t\tfor _, c := range b {\n\t\t\tputchar(c)\n\t\t}\n\t\treturn len(b), nil\n\tdefault:\n\t\treturn 0, ErrUnsupported\n\t}\n}\n\n// Close is unsupported on this system.\nfunc (f stdioFileHandle) Close() error {\n\treturn ErrUnsupported\n}\n\n// Seek wraps syscall.Seek.\nfunc (f stdioFileHandle) Seek(offset int64, whence int) (int64, error) {\n\treturn -1, ErrUnsupported\n}\n\n//go:linkname putchar runtime.putchar\nfunc putchar(c byte)\n\nfunc Pipe() (r *File, w *File, err error) {\n\treturn nil, nil, ErrNotImplemented\n}\n\nfunc Readlink(name string) (string, error) {\n\treturn \"\", ErrNotImplemented\n}\n\nfunc tempDir() string {\n\treturn \"/tmp\"\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:generate go run makeisprint.go -output isprint.go\n\npackage strconv\n\nimport (\n\t\"unicode/utf8\"\n)\n\nconst (\n\tlowerhex = \"0123456789abcdef\"\n\tupperhex = \"0123456789ABCDEF\"\n)\n\n// contains reports whether the string contains the byte c.\nfunc contains(s string, c byte) bool {\n\treturn index(s, c) != -1\n}\n\nfunc quoteWith(s string, quote byte, ASCIIonly, graphicOnly bool) string {\n\treturn string(appendQuotedWith(make([]byte, 0, 3*len(s)/2), s, quote, ASCIIonly, graphicOnly))\n}\n\nfunc quoteRuneWith(r rune, quote byte, ASCIIonly, graphicOnly bool) string {\n\treturn string(appendQuotedRuneWith(nil, r, quote, ASCIIonly, graphicOnly))\n}\n\nfunc appendQuotedWith(buf []byte, s string, quote byte, ASCIIonly, graphicOnly bool) []byte {\n\t// Often called with big strings, so preallocate. If there's quoting,\n\t// this is conservative but still helps a lot.\n\tif cap(buf)-len(buf) < len(s) {\n\t\tnBuf := make([]byte, len(buf), len(buf)+1+len(s)+1)\n\t\tcopy(nBuf, buf)\n\t\tbuf = nBuf\n\t}\n\tbuf = append(buf, quote)\n\tfor width := 0; len(s) > 0; s = s[width:] {\n\t\tr := rune(s[0])\n\t\twidth = 1\n\t\tif r >= utf8.RuneSelf {\n\t\t\tr, width = utf8.DecodeRuneInString(s)\n\t\t}\n\t\tif width == 1 && r == utf8.RuneError {\n\t\t\tbuf = append(buf, `\\x`...)\n\t\t\tbuf = append(buf, lowerhex[s[0]>>4])\n\t\t\tbuf = append(buf, lowerhex[s[0]&0xF])\n\t\t\tcontinue\n\t\t}\n\t\tbuf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly)\n\t}\n\tbuf = append(buf, quote)\n\treturn buf\n}\n\nfunc appendQuotedRuneWith(buf []byte, r rune, quote byte, ASCIIonly, graphicOnly bool) []byte {\n\tbuf = append(buf, quote)\n\tif !utf8.ValidRune(r) {\n\t\tr = utf8.RuneError\n\t}\n\tbuf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly)\n\tbuf = append(buf, quote)\n\treturn buf\n}\n\nfunc appendEscapedRune(buf []byte, r rune, quote byte, ASCIIonly, graphicOnly bool) []byte {\n\tvar runeTmp [utf8.UTFMax]byte\n\tif r == rune(quote) || r == '\\\\' { // always backslashed\n\t\tbuf = append(buf, '\\\\')\n\t\tbuf = append(buf, byte(r))\n\t\treturn buf\n\t}\n\tif ASCIIonly {\n\t\tif r < utf8.RuneSelf && IsPrint(r) {\n\t\t\tbuf = append(buf, byte(r))\n\t\t\treturn buf\n\t\t}\n\t} else if IsPrint(r) || graphicOnly && isInGraphicList(r) {\n\t\tn := utf8.EncodeRune(runeTmp[:], r)\n\t\tbuf = append(buf, runeTmp[:n]...)\n\t\treturn buf\n\t}\n\tswitch r {\n\tcase '\\a':\n\t\tbuf = append(buf, `\\a`...)\n\tcase '\\b':\n\t\tbuf = append(buf, `\\b`...)\n\tcase '\\f':\n\t\tbuf = append(buf, `\\f`...)\n\tcase '\\n':\n\t\tbuf = append(buf, `\\n`...)\n\tcase '\\r':\n\t\tbuf = append(buf, `\\r`...)\n\tcase '\\t':\n\t\tbuf = append(buf, `\\t`...)\n\tcase '\\v':\n\t\tbuf = append(buf, `\\v`...)\n\tdefault:\n\t\tswitch {\n\t\tcase r < ' ':\n\t\t\tbuf = append(buf, `\\x`...)\n\t\t\tbuf = append(buf, lowerhex[byte(r)>>4])\n\t\t\tbuf = append(buf, lowerhex[byte(r)&0xF])\n\t\tcase r > utf8.MaxRune:\n\t\t\tr = 0xFFFD\n\t\t\tfallthrough\n\t\tcase r < 0x10000:\n\t\t\tbuf = append(buf, `\\u`...)\n\t\t\tfor s := 12; s >= 0; s -= 4 {\n\t\t\t\tbuf = append(buf, lowerhex[r>>uint(s)&0xF])\n\t\t\t}\n\t\tdefault:\n\t\t\tbuf = append(buf, `\\U`...)\n\t\t\tfor s := 28; s >= 0; s -= 4 {\n\t\t\t\tbuf = append(buf, lowerhex[r>>uint(s)&0xF])\n\t\t\t}\n\t\t}\n\t}\n\treturn buf\n}\n\n// Quote returns a double-quoted Go string literal representing s. The\n// returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n// control characters and non-printable characters as defined by\n// IsPrint.\nfunc Quote(s string) string {\n\treturn quoteWith(s, '\"', false, false)\n}\n\n// AppendQuote appends a double-quoted Go string literal representing s,\n// as generated by Quote, to dst and returns the extended buffer.\nfunc AppendQuote(dst []byte, s string) []byte {\n\treturn appendQuotedWith(dst, s, '\"', false, false)\n}\n\n// QuoteToASCII returns a double-quoted Go string literal representing s.\n// The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n// non-ASCII characters and non-printable characters as defined by IsPrint.\nfunc QuoteToASCII(s string) string {\n\treturn quoteWith(s, '\"', true, false)\n}\n\n// AppendQuoteToASCII appends a double-quoted Go string literal representing s,\n// as generated by QuoteToASCII, to dst and returns the extended buffer.\nfunc AppendQuoteToASCII(dst []byte, s string) []byte {\n\treturn appendQuotedWith(dst, s, '\"', true, false)\n}\n\n// QuoteToGraphic returns a double-quoted Go string literal representing s.\n// The returned string leaves Unicode graphic characters, as defined by\n// IsGraphic, unchanged and uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\n// for non-graphic characters.\nfunc QuoteToGraphic(s string) string {\n\treturn quoteWith(s, '\"', false, true)\n}\n\n// AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\n// as generated by QuoteToGraphic, to dst and returns the extended buffer.\nfunc AppendQuoteToGraphic(dst []byte, s string) []byte {\n\treturn appendQuotedWith(dst, s, '\"', false, true)\n}\n\n// QuoteRune returns a single-quoted Go character literal representing the\n// rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\n// for control characters and non-printable characters as defined by IsPrint.\nfunc QuoteRune(r rune) string {\n\treturn quoteRuneWith(r, '\\'', false, false)\n}\n\n// AppendQuoteRune appends a single-quoted Go character literal representing the rune,\n// as generated by QuoteRune, to dst and returns the extended buffer.\nfunc AppendQuoteRune(dst []byte, r rune) []byte {\n\treturn appendQuotedRuneWith(dst, r, '\\'', false, false)\n}\n\n// QuoteRuneToASCII returns a single-quoted Go character literal representing\n// the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n// \\u0100) for non-ASCII characters and non-printable characters as defined\n// by IsPrint.\nfunc QuoteRuneToASCII(r rune) string {\n\treturn quoteRuneWith(r, '\\'', true, false)\n}\n\n// AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\n// as generated by QuoteRuneToASCII, to dst and returns the extended buffer.\nfunc AppendQuoteRuneToASCII(dst []byte, r rune) []byte {\n\treturn appendQuotedRuneWith(dst, r, '\\'', true, false)\n}\n\n// QuoteRuneToGraphic returns a single-quoted Go character literal representing\n// the rune. If the rune is not a Unicode graphic character,\n// as defined by IsGraphic, the returned string will use a Go escape sequence\n// (\\t, \\n, \\xFF, \\u0100).\nfunc QuoteRuneToGraphic(r rune) string {\n\treturn quoteRuneWith(r, '\\'', false, true)\n}\n\n// AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\n// as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\nfunc AppendQuoteRuneToGraphic(dst []byte, r rune) []byte {\n\treturn appendQuotedRuneWith(dst, r, '\\'', false, true)\n}\n\n// CanBackquote reports whether the string s can be represented\n// unchanged as a single-line backquoted string without control\n// characters other than tab.\nfunc CanBackquote(s string) bool {\n\tfor len(s) > 0 {\n\t\tr, wid := utf8.DecodeRuneInString(s)\n\t\ts = s[wid:]\n\t\tif wid > 1 {\n\t\t\tif r == '\\ufeff' {\n\t\t\t\treturn false // BOMs are invisible and should not be quoted.\n\t\t\t}\n\t\t\tcontinue // All other multibyte runes are correctly encoded and assumed printable.\n\t\t}\n\t\tif r == utf8.RuneError {\n\t\t\treturn false\n\t\t}\n\t\tif (r < ' ' && r != '\\t') || r == '`' || r == '\\u007F' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc unhex(b byte) (v rune, ok bool) {\n\tc := rune(b)\n\tswitch {\n\tcase '0' <= c && c <= '9':\n\t\treturn c - '0', true\n\tcase 'a' <= c && c <= 'f':\n\t\treturn c - 'a' + 10, true\n\tcase 'A' <= c && c <= 'F':\n\t\treturn c - 'A' + 10, true\n\t}\n\treturn\n}\n\n// UnquoteChar decodes the first character or byte in the escaped string\n// or character literal represented by the string s.\n// It returns four values:\n//\n//\t1) value, the decoded Unicode code point or byte value;\n//\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n//\t3) tail, the remainder of the string after the character; and\n//\t4) an error that will be nil if the character is syntactically valid.\n//\n// The second argument, quote, specifies the type of literal being parsed\n// and therefore which escaped quote character is permitted.\n// If set to a single quote, it permits the sequence \\' and disallows unescaped '.\n// If set to a double quote, it permits \\\" and disallows unescaped \".\n// If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\nfunc UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) {\n\t// easy cases\n\tif len(s) == 0 {\n\t\terr = ErrSyntax\n\t\treturn\n\t}\n\tswitch c := s[0]; {\n\tcase c == quote && (quote == '\\'' || quote == '\"'):\n\t\terr = ErrSyntax\n\t\treturn\n\tcase c >= utf8.RuneSelf:\n\t\tr, size := utf8.DecodeRuneInString(s)\n\t\treturn r, true, s[size:], nil\n\tcase c != '\\\\':\n\t\treturn rune(s[0]), false, s[1:], nil\n\t}\n\n\t// hard case: c is backslash\n\tif len(s) <= 1 {\n\t\terr = ErrSyntax\n\t\treturn\n\t}\n\tc := s[1]\n\ts = s[2:]\n\n\tswitch c {\n\tcase 'a':\n\t\tvalue = '\\a'\n\tcase 'b':\n\t\tvalue = '\\b'\n\tcase 'f':\n\t\tvalue = '\\f'\n\tcase 'n':\n\t\tvalue = '\\n'\n\tcase 'r':\n\t\tvalue = '\\r'\n\tcase 't':\n\t\tvalue = '\\t'\n\tcase 'v':\n\t\tvalue = '\\v'\n\tcase 'x', 'u', 'U':\n\t\tn := 0\n\t\tswitch c {\n\t\tcase 'x':\n\t\t\tn = 2\n\t\tcase 'u':\n\t\t\tn = 4\n\t\tcase 'U':\n\t\t\tn = 8\n\t\t}\n\t\tvar v rune\n\t\tif len(s) < n {\n\t\t\terr = ErrSyntax\n\t\t\treturn\n\t\t}\n\t\tfor j := 0; j < n; j++ {\n\t\t\tx, ok := unhex(s[j])\n\t\t\tif !ok {\n\t\t\t\terr = ErrSyntax\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = v<<4 | x\n\t\t}\n\t\ts = s[n:]\n\t\tif c == 'x' {\n\t\t\t// single-byte string, possibly not UTF-8\n\t\t\tvalue = v\n\t\t\tbreak\n\t\t}\n\t\tif v > utf8.MaxRune {\n\t\t\terr = ErrSyntax\n\t\t\treturn\n\t\t}\n\t\tvalue = v\n\t\tmultibyte = true\n\tcase '0', '1', '2', '3', '4', '5', '6', '7':\n\t\tv := rune(c) - '0'\n\t\tif len(s) < 2 {\n\t\t\terr = ErrSyntax\n\t\t\treturn\n\t\t}\n\t\tfor j := 0; j < 2; j++ { // one digit already; two more\n\t\t\tx := rune(s[j]) - '0'\n\t\t\tif x < 0 || x > 7 {\n\t\t\t\terr = ErrSyntax\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = (v << 3) | x\n\t\t}\n\t\ts = s[2:]\n\t\tif v > 255 {\n\t\t\terr = ErrSyntax\n\t\t\treturn\n\t\t}\n\t\tvalue = v\n\tcase '\\\\':\n\t\tvalue = '\\\\'\n\tcase '\\'', '\"':\n\t\tif c != quote {\n\t\t\terr = ErrSyntax\n\t\t\treturn\n\t\t}\n\t\tvalue = rune(c)\n\tdefault:\n\t\terr = ErrSyntax\n\t\treturn\n\t}\n\ttail = s\n\treturn\n}\n\n// QuotedPrefix returns the quoted string (as understood by Unquote) at the prefix of s.\n// If s does not start with a valid quoted string, QuotedPrefix returns an error.\nfunc QuotedPrefix(s string) (string, error) {\n\tout, _, err := unquote(s, false)\n\treturn out, err\n}\n\n// Unquote interprets s as a single-quoted, double-quoted,\n// or backquoted Go string literal, returning the string value\n// that s quotes.  (If s is single-quoted, it would be a Go\n// character literal; Unquote returns the corresponding\n// one-character string.)\nfunc Unquote(s string) (string, error) {\n\tout, rem, err := unquote(s, true)\n\tif len(rem) > 0 {\n\t\treturn \"\", ErrSyntax\n\t}\n\treturn out, err\n}\n\n// unquote parses a quoted string at the start of the input,\n// returning the parsed prefix, the remaining suffix, and any parse errors.\n// If unescape is true, the parsed prefix is unescaped,\n// otherwise the input prefix is provided verbatim.\nfunc unquote(in string, unescape bool) (out, rem string, err error) {\n\t// Determine the quote form and optimistically find the terminating quote.\n\tif len(in) < 2 {\n\t\treturn \"\", in, ErrSyntax\n\t}\n\tquote := in[0]\n\tend := index(in[1:], quote)\n\tif end < 0 {\n\t\treturn \"\", in, ErrSyntax\n\t}\n\tend += 2 // position after terminating quote; may be wrong if escape sequences are present\n\n\tswitch quote {\n\tcase '`':\n\t\tswitch {\n\t\tcase !unescape:\n\t\t\tout = in[:end] // include quotes\n\t\tcase !contains(in[:end], '\\r'):\n\t\t\tout = in[len(\"`\") : end-len(\"`\")] // exclude quotes\n\t\tdefault:\n\t\t\t// Carriage return characters ('\\r') inside raw string literals\n\t\t\t// are discarded from the raw string value.\n\t\t\tbuf := make([]byte, 0, end-len(\"`\")-len(\"\\r\")-len(\"`\"))\n\t\t\tfor i := len(\"`\"); i < end-len(\"`\"); i++ {\n\t\t\t\tif in[i] != '\\r' {\n\t\t\t\t\tbuf = append(buf, in[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tout = string(buf)\n\t\t}\n\t\t// NOTE: Prior implementations did not verify that raw strings consist\n\t\t// of valid UTF-8 characters and we continue to not verify it as such.\n\t\t// The Go specification does not explicitly require valid UTF-8,\n\t\t// but only mention that it is implicitly valid for Go source code\n\t\t// (which must be valid UTF-8).\n\t\treturn out, in[end:], nil\n\tcase '\"', '\\'':\n\t\t// Handle quoted strings without any escape sequences.\n\t\tif !contains(in[:end], '\\\\') && !contains(in[:end], '\\n') {\n\t\t\tvar valid bool\n\t\t\tswitch quote {\n\t\t\tcase '\"':\n\t\t\t\tvalid = utf8.ValidString(in[len(`\"`) : end-len(`\"`)])\n\t\t\tcase '\\'':\n\t\t\t\tr, n := utf8.DecodeRuneInString(in[len(\"'\") : end-len(\"'\")])\n\t\t\t\tvalid = len(\"'\")+n+len(\"'\") == end && (r != utf8.RuneError || n != 1)\n\t\t\t}\n\t\t\tif valid {\n\t\t\t\tout = in[:end]\n\t\t\t\tif unescape {\n\t\t\t\t\tout = out[1 : end-1] // exclude quotes\n\t\t\t\t}\n\t\t\t\treturn out, in[end:], nil\n\t\t\t}\n\t\t}\n\n\t\t// Handle quoted strings with escape sequences.\n\t\tvar buf []byte\n\t\tin0 := in\n\t\tin = in[1:] // skip starting quote\n\t\tif unescape {\n\t\t\tbuf = make([]byte, 0, 3*end/2) // try to avoid more allocations\n\t\t}\n\t\tfor len(in) > 0 && in[0] != quote {\n\t\t\t// Process the next character,\n\t\t\t// rejecting any unescaped newline characters which are invalid.\n\t\t\tr, multibyte, rem, err := UnquoteChar(in, quote)\n\t\t\tif in[0] == '\\n' || err != nil {\n\t\t\t\treturn \"\", in0, ErrSyntax\n\t\t\t}\n\t\t\tin = rem\n\n\t\t\t// Append the character if unescaping the input.\n\t\t\tif unescape {\n\t\t\t\tif r < utf8.RuneSelf || !multibyte {\n\t\t\t\t\tbuf = append(buf, byte(r))\n\t\t\t\t} else {\n\t\t\t\t\tvar arr [utf8.UTFMax]byte\n\t\t\t\t\tn := utf8.EncodeRune(arr[:], r)\n\t\t\t\t\tbuf = append(buf, arr[:n]...)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Single quoted strings must be a single character.\n\t\t\tif quote == '\\'' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Verify that the string ends with a terminating quote.\n\t\tif !(len(in) > 0 && in[0] == quote) {\n\t\t\treturn \"\", in0, ErrSyntax\n\t\t}\n\t\tin = in[1:] // skip terminating quote\n\n\t\tif unescape {\n\t\t\treturn string(buf), in, nil\n\t\t}\n\t\treturn in0[:len(in0)-len(in)], in, nil\n\tdefault:\n\t\treturn \"\", in, ErrSyntax\n\t}\n}\n\n// bsearch16 returns the smallest i such that a[i] >= x.\n// If there is no such i, bsearch16 returns len(a).\nfunc bsearch16(a []uint16, x uint16) int {\n\ti, j := 0, len(a)\n\tfor i < j {\n\t\th := i + (j-i)>>1\n\t\tif a[h] < x {\n\t\t\ti = h + 1\n\t\t} else {\n\t\t\tj = h\n\t\t}\n\t}\n\treturn i\n}\n\n// bsearch32 returns the smallest i such that a[i] >= x.\n// If there is no such i, bsearch32 returns len(a).\nfunc bsearch32(a []uint32, x uint32) int {\n\ti, j := 0, len(a)\n\tfor i < j {\n\t\th := i + (j-i)>>1\n\t\tif a[h] < x {\n\t\t\ti = h + 1\n\t\t} else {\n\t\t\tj = h\n\t\t}\n\t}\n\treturn i\n}\n\n// TODO: IsPrint is a local implementation of unicode.IsPrint, verified by the tests\n// to give the same answer. It allows this package not to depend on unicode,\n// and therefore not pull in all the Unicode tables. If the linker were better\n// at tossing unused tables, we could get rid of this implementation.\n// That would be nice.\n\n// IsPrint reports whether the rune is defined as printable by Go, with\n// the same definition as unicode.IsPrint: letters, numbers, punctuation,\n// symbols and ASCII space.\nfunc IsPrint(r rune) bool {\n\t// Fast check for Latin-1\n\tif r <= 0xFF {\n\t\tif 0x20 <= r && r <= 0x7E {\n\t\t\t// All the ASCII is printable from space through DEL-1.\n\t\t\treturn true\n\t\t}\n\t\tif 0xA1 <= r && r <= 0xFF {\n\t\t\t// Similarly for \u00a1 through \u00ff...\n\t\t\treturn r != 0xAD // ...except for the bizarre soft hyphen.\n\t\t}\n\t\treturn false\n\t}\n\n\t// Same algorithm, either on uint16 or uint32 value.\n\t// First, find first i such that isPrint[i] >= x.\n\t// This is the index of either the start or end of a pair that might span x.\n\t// The start is even (isPrint[i&^1]) and the end is odd (isPrint[i|1]).\n\t// If we find x in a range, make sure x is not in isNotPrint list.\n\n\tif 0 <= r && r < 1<<16 {\n\t\trr, isPrint, isNotPrint := uint16(r), isPrint16, isNotPrint16\n\t\ti := bsearch16(isPrint, rr)\n\t\tif i >= len(isPrint) || rr < isPrint[i&^1] || isPrint[i|1] < rr {\n\t\t\treturn false\n\t\t}\n\t\tj := bsearch16(isNotPrint, rr)\n\t\treturn j >= len(isNotPrint) || isNotPrint[j] != rr\n\t}\n\n\trr, isPrint, isNotPrint := uint32(r), isPrint32, isNotPrint32\n\ti := bsearch32(isPrint, rr)\n\tif i >= len(isPrint) || rr < isPrint[i&^1] || isPrint[i|1] < rr {\n\t\treturn false\n\t}\n\tif r >= 0x20000 {\n\t\treturn true\n\t}\n\tr -= 0x10000\n\tj := bsearch16(isNotPrint, uint16(r))\n\treturn j >= len(isNotPrint) || isNotPrint[j] != uint16(r)\n}\n\n// IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\n// characters include letters, marks, numbers, punctuation, symbols, and\n// spaces, from categories L, M, N, P, S, and Zs.\nfunc IsGraphic(r rune) bool {\n\tif IsPrint(r) {\n\t\treturn true\n\t}\n\treturn isInGraphicList(r)\n}\n\n// isInGraphicList reports whether the rune is in the isGraphic list. This separation\n// from IsGraphic allows quoteWith to avoid two calls to IsPrint.\n// Should be called only if IsPrint fails.\nfunc isInGraphicList(r rune) bool {\n\t// We know r must fit in 16 bits - see makeisprint.go.\n\tif r > 0xFFFF {\n\t\treturn false\n\t}\n\trr := uint16(r)\n\ti := bsearch16(isGraphic, rr)\n\treturn i < len(isGraphic) && rr == isGraphic[i]\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Multiprecision decimal numbers.\n// For floating-point formatting only; not general purpose.\n// Only operations are assign and (binary) left/right shift.\n// Can do binary floating point in multiprecision decimal precisely\n// because 2 divides 10; cannot do decimal floating point\n// in multiprecision binary precisely.\n\npackage strconv\n\ntype decimal struct {\n\td     [800]byte // digits, big-endian representation\n\tnd    int       // number of digits used\n\tdp    int       // decimal point\n\tneg   bool      // negative flag\n\ttrunc bool      // discarded nonzero digits beyond d[:nd]\n}\n\nfunc (a *decimal) String() string {\n\tn := 10 + a.nd\n\tif a.dp > 0 {\n\t\tn += a.dp\n\t}\n\tif a.dp < 0 {\n\t\tn += -a.dp\n\t}\n\n\tbuf := make([]byte, n)\n\tw := 0\n\tswitch {\n\tcase a.nd == 0:\n\t\treturn \"0\"\n\n\tcase a.dp <= 0:\n\t\t// zeros fill space between decimal point and digits\n\t\tbuf[w] = '0'\n\t\tw++\n\t\tbuf[w] = '.'\n\t\tw++\n\t\tw += digitZero(buf[w : w+-a.dp])\n\t\tw += copy(buf[w:], a.d[0:a.nd])\n\n\tcase a.dp < a.nd:\n\t\t// decimal point in middle of digits\n\t\tw += copy(buf[w:], a.d[0:a.dp])\n\t\tbuf[w] = '.'\n\t\tw++\n\t\tw += copy(buf[w:], a.d[a.dp:a.nd])\n\n\tdefault:\n\t\t// zeros fill space between digits and decimal point\n\t\tw += copy(buf[w:], a.d[0:a.nd])\n\t\tw += digitZero(buf[w : w+a.dp-a.nd])\n\t}\n\treturn string(buf[0:w])\n}\n\nfunc digitZero(dst []byte) int {\n\tfor i := range dst {\n\t\tdst[i] = '0'\n\t}\n\treturn len(dst)\n}\n\n// trim trailing zeros from number.\n// (They are meaningless; the decimal point is tracked\n// independent of the number of digits.)\nfunc trim(a *decimal) {\n\tfor a.nd > 0 && a.d[a.nd-1] == '0' {\n\t\ta.nd--\n\t}\n\tif a.nd == 0 {\n\t\ta.dp = 0\n\t}\n}\n\n// Assign v to a.\nfunc (a *decimal) Assign(v uint64) {\n\tvar buf [24]byte\n\n\t// Write reversed decimal in buf.\n\tn := 0\n\tfor v > 0 {\n\t\tv1 := v / 10\n\t\tv -= 10 * v1\n\t\tbuf[n] = byte(v + '0')\n\t\tn++\n\t\tv = v1\n\t}\n\n\t// Reverse again to produce forward decimal in a.d.\n\ta.nd = 0\n\tfor n--; n >= 0; n-- {\n\t\ta.d[a.nd] = buf[n]\n\t\ta.nd++\n\t}\n\ta.dp = a.nd\n\ttrim(a)\n}\n\n// Maximum shift that we can do in one pass without overflow.\n// A uint has 32 or 64 bits, and we have to be able to accommodate 9<<k.\nconst uintSize = 32 << (^uint(0) >> 63)\nconst maxShift = uintSize - 4\n\n// Binary shift right (/ 2) by k bits.  k <= maxShift to avoid overflow.\nfunc rightShift(a *decimal, k uint) {\n\tr := 0 // read pointer\n\tw := 0 // write pointer\n\n\t// Pick up enough leading digits to cover first shift.\n\tvar n uint\n\tfor ; n>>k == 0; r++ {\n\t\tif r >= a.nd {\n\t\t\tif n == 0 {\n\t\t\t\t// a == 0; shouldn't get here, but handle anyway.\n\t\t\t\ta.nd = 0\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor n>>k == 0 {\n\t\t\t\tn = n * 10\n\t\t\t\tr++\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tc := uint(a.d[r])\n\t\tn = n*10 + c - '0'\n\t}\n\ta.dp -= r - 1\n\n\tvar mask uint = (1 << k) - 1\n\n\t// Pick up a digit, put down a digit.\n\tfor ; r < a.nd; r++ {\n\t\tc := uint(a.d[r])\n\t\tdig := n >> k\n\t\tn &= mask\n\t\ta.d[w] = byte(dig + '0')\n\t\tw++\n\t\tn = n*10 + c - '0'\n\t}\n\n\t// Put down extra digits.\n\tfor n > 0 {\n\t\tdig := n >> k\n\t\tn &= mask\n\t\tif w < len(a.d) {\n\t\t\ta.d[w] = byte(dig + '0')\n\t\t\tw++\n\t\t} else if dig > 0 {\n\t\t\ta.trunc = true\n\t\t}\n\t\tn = n * 10\n\t}\n\n\ta.nd = w\n\ttrim(a)\n}\n\n// Cheat sheet for left shift: table indexed by shift count giving\n// number of new digits that will be introduced by that shift.\n//\n// For example, leftcheats[4] = {2, \"625\"}.  That means that\n// if we are shifting by 4 (multiplying by 16), it will add 2 digits\n// when the string prefix is \"625\" through \"999\", and one fewer digit\n// if the string prefix is \"000\" through \"624\".\n//\n// Credit for this trick goes to Ken.\n\ntype leftCheat struct {\n\tdelta  int    // number of new digits\n\tcutoff string // minus one digit if original < a.\n}\n\nvar leftcheats = []leftCheat{\n\t// Leading digits of 1/2^i = 5^i.\n\t// 5^23 is not an exact 64-bit floating point number,\n\t// so have to use bc for the math.\n\t// Go up to 60 to be large enough for 32bit and 64bit platforms.\n\t/*\n\t\tseq 60 | sed 's/^/5^/' | bc |\n\t\tawk 'BEGIN{ print \"\\t{ 0, \\\"\\\" },\" }\n\t\t{\n\t\t\tlog2 = log(2)/log(10)\n\t\t\tprintf(\"\\t{ %d, \\\"%s\\\" },\\t// * %d\\n\",\n\t\t\t\tint(log2*NR+1), $0, 2**NR)\n\t\t}'\n\t*/\n\t{0, \"\"},\n\t{1, \"5\"},                                           // * 2\n\t{1, \"25\"},                                          // * 4\n\t{1, \"125\"},                                         // * 8\n\t{2, \"625\"},                                         // * 16\n\t{2, \"3125\"},                                        // * 32\n\t{2, \"15625\"},                                       // * 64\n\t{3, \"78125\"},                                       // * 128\n\t{3, \"390625\"},                                      // * 256\n\t{3, \"1953125\"},                                     // * 512\n\t{4, \"9765625\"},                                     // * 1024\n\t{4, \"48828125\"},                                    // * 2048\n\t{4, \"244140625\"},                                   // * 4096\n\t{4, \"1220703125\"},                                  // * 8192\n\t{5, \"6103515625\"},                                  // * 16384\n\t{5, \"30517578125\"},                                 // * 32768\n\t{5, \"152587890625\"},                                // * 65536\n\t{6, \"762939453125\"},                                // * 131072\n\t{6, \"3814697265625\"},                               // * 262144\n\t{6, \"19073486328125\"},                              // * 524288\n\t{7, \"95367431640625\"},                              // * 1048576\n\t{7, \"476837158203125\"},                             // * 2097152\n\t{7, \"2384185791015625\"},                            // * 4194304\n\t{7, \"11920928955078125\"},                           // * 8388608\n\t{8, \"59604644775390625\"},                           // * 16777216\n\t{8, \"298023223876953125\"},                          // * 33554432\n\t{8, \"1490116119384765625\"},                         // * 67108864\n\t{9, \"7450580596923828125\"},                         // * 134217728\n\t{9, \"37252902984619140625\"},                        // * 268435456\n\t{9, \"186264514923095703125\"},                       // * 536870912\n\t{10, \"931322574615478515625\"},                      // * 1073741824\n\t{10, \"4656612873077392578125\"},                     // * 2147483648\n\t{10, \"23283064365386962890625\"},                    // * 4294967296\n\t{10, \"116415321826934814453125\"},                   // * 8589934592\n\t{11, \"582076609134674072265625\"},                   // * 17179869184\n\t{11, \"2910383045673370361328125\"},                  // * 34359738368\n\t{11, \"14551915228366851806640625\"},                 // * 68719476736\n\t{12, \"72759576141834259033203125\"},                 // * 137438953472\n\t{12, \"363797880709171295166015625\"},                // * 274877906944\n\t{12, \"1818989403545856475830078125\"},               // * 549755813888\n\t{13, \"9094947017729282379150390625\"},               // * 1099511627776\n\t{13, \"45474735088646411895751953125\"},              // * 2199023255552\n\t{13, \"227373675443232059478759765625\"},             // * 4398046511104\n\t{13, \"1136868377216160297393798828125\"},            // * 8796093022208\n\t{14, \"5684341886080801486968994140625\"},            // * 17592186044416\n\t{14, \"28421709430404007434844970703125\"},           // * 35184372088832\n\t{14, \"142108547152020037174224853515625\"},          // * 70368744177664\n\t{15, \"710542735760100185871124267578125\"},          // * 140737488355328\n\t{15, \"3552713678800500929355621337890625\"},         // * 281474976710656\n\t{15, \"17763568394002504646778106689453125\"},        // * 562949953421312\n\t{16, \"88817841970012523233890533447265625\"},        // * 1125899906842624\n\t{16, \"444089209850062616169452667236328125\"},       // * 2251799813685248\n\t{16, \"2220446049250313080847263336181640625\"},      // * 4503599627370496\n\t{16, \"11102230246251565404236316680908203125\"},     // * 9007199254740992\n\t{17, \"55511151231257827021181583404541015625\"},     // * 18014398509481984\n\t{17, \"277555756156289135105907917022705078125\"},    // * 36028797018963968\n\t{17, \"1387778780781445675529539585113525390625\"},   // * 72057594037927936\n\t{18, \"6938893903907228377647697925567626953125\"},   // * 144115188075855872\n\t{18, \"34694469519536141888238489627838134765625\"},  // * 288230376151711744\n\t{18, \"173472347597680709441192448139190673828125\"}, // * 576460752303423488\n\t{19, \"867361737988403547205962240695953369140625\"}, // * 1152921504606846976\n}\n\n// Is the leading prefix of b lexicographically less than s?\nfunc prefixIsLessThan(b []byte, s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif i >= len(b) {\n\t\t\treturn true\n\t\t}\n\t\tif b[i] != s[i] {\n\t\t\treturn b[i] < s[i]\n\t\t}\n\t}\n\treturn false\n}\n\n// Binary shift left (* 2) by k bits.  k <= maxShift to avoid overflow.\nfunc leftShift(a *decimal, k uint) {\n\tdelta := leftcheats[k].delta\n\tif prefixIsLessThan(a.d[0:a.nd], leftcheats[k].cutoff) {\n\t\tdelta--\n\t}\n\n\tr := a.nd         // read index\n\tw := a.nd + delta // write index\n\n\t// Pick up a digit, put down a digit.\n\tvar n uint\n\tfor r--; r >= 0; r-- {\n\t\tn += (uint(a.d[r]) - '0') << k\n\t\tquo := n / 10\n\t\trem := n - 10*quo\n\t\tw--\n\t\tif w < len(a.d) {\n\t\t\ta.d[w] = byte(rem + '0')\n\t\t} else if rem != 0 {\n\t\t\ta.trunc = true\n\t\t}\n\t\tn = quo\n\t}\n\n\t// Put down extra digits.\n\tfor n > 0 {\n\t\tquo := n / 10\n\t\trem := n - 10*quo\n\t\tw--\n\t\tif w < len(a.d) {\n\t\t\ta.d[w] = byte(rem + '0')\n\t\t} else if rem != 0 {\n\t\t\ta.trunc = true\n\t\t}\n\t\tn = quo\n\t}\n\n\ta.nd += delta\n\tif a.nd >= len(a.d) {\n\t\ta.nd = len(a.d)\n\t}\n\ta.dp += delta\n\ttrim(a)\n}\n\n// Binary shift left (k > 0) or right (k < 0).\nfunc (a *decimal) Shift(k int) {\n\tswitch {\n\tcase a.nd == 0:\n\t\t// nothing to do: a == 0\n\tcase k > 0:\n\t\tfor k > maxShift {\n\t\t\tleftShift(a, maxShift)\n\t\t\tk -= maxShift\n\t\t}\n\t\tleftShift(a, uint(k))\n\tcase k < 0:\n\t\tfor k < -maxShift {\n\t\t\trightShift(a, maxShift)\n\t\t\tk += maxShift\n\t\t}\n\t\trightShift(a, uint(-k))\n\t}\n}\n\n// If we chop a at nd digits, should we round up?\nfunc shouldRoundUp(a *decimal, nd int) bool {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn false\n\t}\n\tif a.d[nd] == '5' && nd+1 == a.nd { // exactly halfway - round to even\n\t\t// if we truncated, a little higher than what's recorded - always round up\n\t\tif a.trunc {\n\t\t\treturn true\n\t\t}\n\t\treturn nd > 0 && (a.d[nd-1]-'0')%2 != 0\n\t}\n\t// not halfway - digit tells all\n\treturn a.d[nd] >= '5'\n}\n\n// Round a to nd digits (or fewer).\n// If nd is zero, it means we're rounding\n// just to the left of the digits, as in\n// 0.09 -> 0.1.\nfunc (a *decimal) Round(nd int) {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn\n\t}\n\tif shouldRoundUp(a, nd) {\n\t\ta.RoundUp(nd)\n\t} else {\n\t\ta.RoundDown(nd)\n\t}\n}\n\n// Round a down to nd digits (or fewer).\nfunc (a *decimal) RoundDown(nd int) {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn\n\t}\n\ta.nd = nd\n\ttrim(a)\n}\n\n// Round a up to nd digits (or fewer).\nfunc (a *decimal) RoundUp(nd int) {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn\n\t}\n\n\t// round up\n\tfor i := nd - 1; i >= 0; i-- {\n\t\tc := a.d[i]\n\t\tif c < '9' { // can stop after this digit\n\t\t\ta.d[i]++\n\t\t\ta.nd = i + 1\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Number is all 9s.\n\t// Change to single 1 with adjusted decimal point.\n\ta.d[0] = '1'\n\ta.nd = 1\n\ta.dp++\n}\n\n// Extract integer part, rounded appropriately.\n// No guarantees about overflow.\nfunc (a *decimal) RoundedInteger() uint64 {\n\tif a.dp > 20 {\n\t\treturn 0xFFFFFFFFFFFFFFFF\n\t}\n\tvar i int\n\tn := uint64(0)\n\tfor i = 0; i < a.dp && i < a.nd; i++ {\n\t\tn = n*10 + uint64(a.d[i]-'0')\n\t}\n\tfor ; i < a.dp; i++ {\n\t\tn *= 10\n\t}\n\tif shouldRoundUp(a, a.dp) {\n\t\tn++\n\t}\n\treturn n\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage strconv\n\nimport \"math/bits\"\n\nconst fastSmalls = true // enable fast path for small integers\n\n// FormatUint returns the string representation of i in the given base,\n// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\n// for digit values >= 10.\nfunc FormatUint(i uint64, base int) string {\n\tif fastSmalls && i < nSmalls && base == 10 {\n\t\treturn small(int(i))\n\t}\n\t_, s := formatBits(nil, i, base, false, false)\n\treturn s\n}\n\n// FormatInt returns the string representation of i in the given base,\n// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\n// for digit values >= 10.\nfunc FormatInt(i int64, base int) string {\n\tif fastSmalls && 0 <= i && i < nSmalls && base == 10 {\n\t\treturn small(int(i))\n\t}\n\t_, s := formatBits(nil, uint64(i), base, i < 0, false)\n\treturn s\n}\n\n// Itoa is equivalent to FormatInt(int64(i), 10).\nfunc Itoa(i int) string {\n\treturn FormatInt(int64(i), 10)\n}\n\n// AppendInt appends the string form of the integer i,\n// as generated by FormatInt, to dst and returns the extended buffer.\nfunc AppendInt(dst []byte, i int64, base int) []byte {\n\tif fastSmalls && 0 <= i && i < nSmalls && base == 10 {\n\t\treturn append(dst, small(int(i))...)\n\t}\n\tdst, _ = formatBits(dst, uint64(i), base, i < 0, true)\n\treturn dst\n}\n\n// AppendUint appends the string form of the unsigned integer i,\n// as generated by FormatUint, to dst and returns the extended buffer.\nfunc AppendUint(dst []byte, i uint64, base int) []byte {\n\tif fastSmalls && i < nSmalls && base == 10 {\n\t\treturn append(dst, small(int(i))...)\n\t}\n\tdst, _ = formatBits(dst, i, base, false, true)\n\treturn dst\n}\n\n// small returns the string for an i with 0 <= i < nSmalls.\nfunc small(i int) string {\n\tif i < 10 {\n\t\treturn digits[i : i+1]\n\t}\n\treturn smallsString[i*2 : i*2+2]\n}\n\nconst nSmalls = 100\n\nconst smallsString = \"00010203040506070809\" +\n\t\"10111213141516171819\" +\n\t\"20212223242526272829\" +\n\t\"30313233343536373839\" +\n\t\"40414243444546474849\" +\n\t\"50515253545556575859\" +\n\t\"60616263646566676869\" +\n\t\"70717273747576777879\" +\n\t\"80818283848586878889\" +\n\t\"90919293949596979899\"\n\nconst host32bit = ^uint(0)>>32 == 0\n\nconst digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n// formatBits computes the string representation of u in the given base.\n// If neg is set, u is treated as negative int64 value. If append_ is\n// set, the string is appended to dst and the resulting byte slice is\n// returned as the first result value; otherwise the string is returned\n// as the second result value.\n//\nfunc formatBits(dst []byte, u uint64, base int, neg, append_ bool) (d []byte, s string) {\n\tif base < 2 || base > len(digits) {\n\t\tpanic(\"strconv: illegal AppendInt/FormatInt base\")\n\t}\n\t// 2 <= base && base <= len(digits)\n\n\tvar a [64 + 1]byte // +1 for sign of 64bit value in base 2\n\ti := len(a)\n\n\tif neg {\n\t\tu = -u\n\t}\n\n\t// convert bits\n\t// We use uint values where we can because those will\n\t// fit into a single register even on a 32bit machine.\n\tif base == 10 {\n\t\t// common case: use constants for / because\n\t\t// the compiler can optimize it into a multiply+shift\n\n\t\tif host32bit {\n\t\t\t// convert the lower digits using 32bit operations\n\t\t\tfor u >= 1e9 {\n\t\t\t\t// Avoid using r = a%b in addition to q = a/b\n\t\t\t\t// since 64bit division and modulo operations\n\t\t\t\t// are calculated by runtime functions on 32bit machines.\n\t\t\t\tq := u / 1e9\n\t\t\t\tus := uint(u - q*1e9) // u % 1e9 fits into a uint\n\t\t\t\tfor j := 4; j > 0; j-- {\n\t\t\t\t\tis := us % 100 * 2\n\t\t\t\t\tus /= 100\n\t\t\t\t\ti -= 2\n\t\t\t\t\ta[i+1] = smallsString[is+1]\n\t\t\t\t\ta[i+0] = smallsString[is+0]\n\t\t\t\t}\n\n\t\t\t\t// us < 10, since it contains the last digit\n\t\t\t\t// from the initial 9-digit us.\n\t\t\t\ti--\n\t\t\t\ta[i] = smallsString[us*2+1]\n\n\t\t\t\tu = q\n\t\t\t}\n\t\t\t// u < 1e9\n\t\t}\n\n\t\t// u guaranteed to fit into a uint\n\t\tus := uint(u)\n\t\tfor us >= 100 {\n\t\t\tis := us % 100 * 2\n\t\t\tus /= 100\n\t\t\ti -= 2\n\t\t\ta[i+1] = smallsString[is+1]\n\t\t\ta[i+0] = smallsString[is+0]\n\t\t}\n\n\t\t// us < 100\n\t\tis := us * 2\n\t\ti--\n\t\ta[i] = smallsString[is+1]\n\t\tif us >= 10 {\n\t\t\ti--\n\t\t\ta[i] = smallsString[is]\n\t\t}\n\n\t} else if isPowerOfTwo(base) {\n\t\t// Use shifts and masks instead of / and %.\n\t\t// Base is a power of 2 and 2 <= base <= len(digits) where len(digits) is 36.\n\t\t// The largest power of 2 below or equal to 36 is 32, which is 1 << 5;\n\t\t// i.e., the largest possible shift count is 5. By &-ind that value with\n\t\t// the constant 7 we tell the compiler that the shift count is always\n\t\t// less than 8 which is smaller than any register width. This allows\n\t\t// the compiler to generate better code for the shift operation.\n\t\tshift := uint(bits.TrailingZeros(uint(base))) & 7\n\t\tb := uint64(base)\n\t\tm := uint(base) - 1 // == 1<<shift - 1\n\t\tfor u >= b {\n\t\t\ti--\n\t\t\ta[i] = digits[uint(u)&m]\n\t\t\tu >>= shift\n\t\t}\n\t\t// u < base\n\t\ti--\n\t\ta[i] = digits[uint(u)]\n\t} else {\n\t\t// general case\n\t\tb := uint64(base)\n\t\tfor u >= b {\n\t\t\ti--\n\t\t\t// Avoid using r = a%b in addition to q = a/b\n\t\t\t// since 64bit division and modulo operations\n\t\t\t// are calculated by runtime functions on 32bit machines.\n\t\t\tq := u / b\n\t\t\ta[i] = digits[uint(u-q*b)]\n\t\t\tu = q\n\t\t}\n\t\t// u < base\n\t\ti--\n\t\ta[i] = digits[uint(u)]\n\t}\n\n\t// add sign, if any\n\tif neg {\n\t\ti--\n\t\ta[i] = '-'\n\t}\n\n\tif append_ {\n\t\td = append(dst, a[i:]...)\n\t\treturn\n\t}\n\ts = string(a[i:])\n\treturn\n}\n\nfunc isPowerOfTwo(x int) bool {\n\treturn x&(x-1) == 0\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage math\n\nimport \"unsafe\"\n\n// Float32bits returns the IEEE 754 binary representation of f,\n// with the sign bit of f and the result in the same bit position.\n// Float32bits(Float32frombits(x)) == x.\nfunc Float32bits(f float32) uint32 { return *(*uint32)(unsafe.Pointer(&f)) }\n\n// Float32frombits returns the floating-point number corresponding\n// to the IEEE 754 binary representation b, with the sign bit of b\n// and the result in the same bit position.\n// Float32frombits(Float32bits(x)) == x.\nfunc Float32frombits(b uint32) float32 { return *(*float32)(unsafe.Pointer(&b)) }\n\n// Float64bits returns the IEEE 754 binary representation of f,\n// with the sign bit of f and the result in the same bit position,\n// and Float64bits(Float64frombits(x)) == x.\nfunc Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&f)) }\n\n// Float64frombits returns the floating-point number corresponding\n// to the IEEE 754 binary representation b, with the sign bit of b\n// and the result in the same bit position.\n// Float64frombits(Float64bits(x)) == x.\nfunc Float64frombits(b uint64) float64 { return *(*float64)(unsafe.Pointer(&b)) }\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Binary to decimal floating point conversion.\n// Algorithm:\n//   1) store mantissa in multiprecision decimal\n//   2) shift decimal by exponent\n//   3) read digits out & format\n\npackage strconv\n\nimport \"math\"\n\n// TODO: move elsewhere?\ntype floatInfo struct {\n\tmantbits uint\n\texpbits  uint\n\tbias     int\n}\n\nvar float32info = floatInfo{23, 8, -127}\nvar float64info = floatInfo{52, 11, -1023}\n\n// FormatFloat converts the floating-point number f to a string,\n// according to the format fmt and precision prec. It rounds the\n// result assuming that the original was obtained from a floating-point\n// value of bitSize bits (32 for float32, 64 for float64).\n//\n// The format fmt is one of\n// 'b' (-ddddp\u00b1ddd, a binary exponent),\n// 'e' (-d.dddde\u00b1dd, a decimal exponent),\n// 'E' (-d.ddddE\u00b1dd, a decimal exponent),\n// 'f' (-ddd.dddd, no exponent),\n// 'g' ('e' for large exponents, 'f' otherwise),\n// 'G' ('E' for large exponents, 'f' otherwise),\n// 'x' (-0xd.ddddp\u00b1ddd, a hexadecimal fraction and binary exponent), or\n// 'X' (-0Xd.ddddP\u00b1ddd, a hexadecimal fraction and binary exponent).\n//\n// The precision prec controls the number of digits (excluding the exponent)\n// printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats.\n// For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point.\n// For 'g' and 'G' it is the maximum number of significant digits (trailing\n// zeros are removed).\n// The special precision -1 uses the smallest number of digits\n// necessary such that ParseFloat will return f exactly.\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string {\n\treturn string(genericFtoa(make([]byte, 0, max(prec+4, 24)), f, fmt, prec, bitSize))\n}\n\n// AppendFloat appends the string form of the floating-point number f,\n// as generated by FormatFloat, to dst and returns the extended buffer.\nfunc AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte {\n\treturn genericFtoa(dst, f, fmt, prec, bitSize)\n}\n\nfunc genericFtoa(dst []byte, val float64, fmt byte, prec, bitSize int) []byte {\n\tvar bits uint64\n\tvar flt *floatInfo\n\tswitch bitSize {\n\tcase 32:\n\t\tbits = uint64(math.Float32bits(float32(val)))\n\t\tflt = &float32info\n\tcase 64:\n\t\tbits = math.Float64bits(val)\n\t\tflt = &float64info\n\tdefault:\n\t\tpanic(\"strconv: illegal AppendFloat/FormatFloat bitSize\")\n\t}\n\n\tneg := bits>>(flt.expbits+flt.mantbits) != 0\n\texp := int(bits>>flt.mantbits) & (1<<flt.expbits - 1)\n\tmant := bits & (uint64(1)<<flt.mantbits - 1)\n\n\tswitch exp {\n\tcase 1<<flt.expbits - 1:\n\t\t// Inf, NaN\n\t\tvar s string\n\t\tswitch {\n\t\tcase mant != 0:\n\t\t\ts = \"NaN\"\n\t\tcase neg:\n\t\t\ts = \"-Inf\"\n\t\tdefault:\n\t\t\ts = \"+Inf\"\n\t\t}\n\t\treturn append(dst, s...)\n\n\tcase 0:\n\t\t// denormalized\n\t\texp++\n\n\tdefault:\n\t\t// add implicit top bit\n\t\tmant |= uint64(1) << flt.mantbits\n\t}\n\texp += flt.bias\n\n\t// Pick off easy binary, hex formats.\n\tif fmt == 'b' {\n\t\treturn fmtB(dst, neg, mant, exp, flt)\n\t}\n\tif fmt == 'x' || fmt == 'X' {\n\t\treturn fmtX(dst, prec, fmt, neg, mant, exp, flt)\n\t}\n\n\tif !optimize {\n\t\treturn bigFtoa(dst, prec, fmt, neg, mant, exp, flt)\n\t}\n\n\tvar digs decimalSlice\n\tok := false\n\t// Negative precision means \"only as much as needed to be exact.\"\n\tshortest := prec < 0\n\tif shortest {\n\t\t// Use Ryu algorithm.\n\t\tvar buf [32]byte\n\t\tdigs.d = buf[:]\n\t\tryuFtoaShortest(&digs, mant, exp-int(flt.mantbits), flt)\n\t\tok = true\n\t\t// Precision for shortest representation mode.\n\t\tswitch fmt {\n\t\tcase 'e', 'E':\n\t\t\tprec = max(digs.nd-1, 0)\n\t\tcase 'f':\n\t\t\tprec = max(digs.nd-digs.dp, 0)\n\t\tcase 'g', 'G':\n\t\t\tprec = digs.nd\n\t\t}\n\t} else if fmt != 'f' {\n\t\t// Fixed number of digits.\n\t\tdigits := prec\n\t\tswitch fmt {\n\t\tcase 'e', 'E':\n\t\t\tdigits++\n\t\tcase 'g', 'G':\n\t\t\tif prec == 0 {\n\t\t\t\tprec = 1\n\t\t\t}\n\t\t\tdigits = prec\n\t\t}\n\t\tvar buf [24]byte\n\t\tif bitSize == 32 && digits <= 9 {\n\t\t\tdigs.d = buf[:]\n\t\t\tryuFtoaFixed32(&digs, uint32(mant), exp-int(flt.mantbits), digits)\n\t\t\tok = true\n\t\t} else if digits <= 18 {\n\t\t\tdigs.d = buf[:]\n\t\t\tryuFtoaFixed64(&digs, mant, exp-int(flt.mantbits), digits)\n\t\t\tok = true\n\t\t}\n\t}\n\tif !ok {\n\t\treturn bigFtoa(dst, prec, fmt, neg, mant, exp, flt)\n\t}\n\treturn formatDigits(dst, shortest, neg, digs, prec, fmt)\n}\n\n// bigFtoa uses multiprecision computations to format a float.\nfunc bigFtoa(dst []byte, prec int, fmt byte, neg bool, mant uint64, exp int, flt *floatInfo) []byte {\n\td := new(decimal)\n\td.Assign(mant)\n\td.Shift(exp - int(flt.mantbits))\n\tvar digs decimalSlice\n\tshortest := prec < 0\n\tif shortest {\n\t\troundShortest(d, mant, exp, flt)\n\t\tdigs = decimalSlice{d: d.d[:], nd: d.nd, dp: d.dp}\n\t\t// Precision for shortest representation mode.\n\t\tswitch fmt {\n\t\tcase 'e', 'E':\n\t\t\tprec = digs.nd - 1\n\t\tcase 'f':\n\t\t\tprec = max(digs.nd-digs.dp, 0)\n\t\tcase 'g', 'G':\n\t\t\tprec = digs.nd\n\t\t}\n\t} else {\n\t\t// Round appropriately.\n\t\tswitch fmt {\n\t\tcase 'e', 'E':\n\t\t\td.Round(prec + 1)\n\t\tcase 'f':\n\t\t\td.Round(d.dp + prec)\n\t\tcase 'g', 'G':\n\t\t\tif prec == 0 {\n\t\t\t\tprec = 1\n\t\t\t}\n\t\t\td.Round(prec)\n\t\t}\n\t\tdigs = decimalSlice{d: d.d[:], nd: d.nd, dp: d.dp}\n\t}\n\treturn formatDigits(dst, shortest, neg, digs, prec, fmt)\n}\n\nfunc formatDigits(dst []byte, shortest bool, neg bool, digs decimalSlice, prec int, fmt byte) []byte {\n\tswitch fmt {\n\tcase 'e', 'E':\n\t\treturn fmtE(dst, neg, digs, prec, fmt)\n\tcase 'f':\n\t\treturn fmtF(dst, neg, digs, prec)\n\tcase 'g', 'G':\n\t\t// trailing fractional zeros in 'e' form will be trimmed.\n\t\teprec := prec\n\t\tif eprec > digs.nd && digs.nd >= digs.dp {\n\t\t\teprec = digs.nd\n\t\t}\n\t\t// %e is used if the exponent from the conversion\n\t\t// is less than -4 or greater than or equal to the precision.\n\t\t// if precision was the shortest possible, use precision 6 for this decision.\n\t\tif shortest {\n\t\t\teprec = 6\n\t\t}\n\t\texp := digs.dp - 1\n\t\tif exp < -4 || exp >= eprec {\n\t\t\tif prec > digs.nd {\n\t\t\t\tprec = digs.nd\n\t\t\t}\n\t\t\treturn fmtE(dst, neg, digs, prec-1, fmt+'e'-'g')\n\t\t}\n\t\tif prec > digs.dp {\n\t\t\tprec = digs.nd\n\t\t}\n\t\treturn fmtF(dst, neg, digs, max(prec-digs.dp, 0))\n\t}\n\n\t// unknown format\n\treturn append(dst, '%', fmt)\n}\n\n// roundShortest rounds d (= mant * 2^exp) to the shortest number of digits\n// that will let the original floating point value be precisely reconstructed.\nfunc roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n\t// If mantissa is zero, the number is zero; stop now.\n\tif mant == 0 {\n\t\td.nd = 0\n\t\treturn\n\t}\n\n\t// Compute upper and lower such that any decimal number\n\t// between upper and lower (possibly inclusive)\n\t// will round to the original floating point number.\n\n\t// We may see at once that the number is already shortest.\n\t//\n\t// Suppose d is not denormal, so that 2^exp <= d < 10^dp.\n\t// The closest shorter number is at least 10^(dp-nd) away.\n\t// The lower/upper bounds computed below are at distance\n\t// at most 2^(exp-mantbits).\n\t//\n\t// So the number is already shortest if 10^(dp-nd) > 2^(exp-mantbits),\n\t// or equivalently log2(10)*(dp-nd) > exp-mantbits.\n\t// It is true if 332/100*(dp-nd) >= exp-mantbits (log2(10) > 3.32).\n\tminexp := flt.bias + 1 // minimum possible exponent\n\tif exp > minexp && 332*(d.dp-d.nd) >= 100*(exp-int(flt.mantbits)) {\n\t\t// The number is already shortest.\n\t\treturn\n\t}\n\n\t// d = mant << (exp - mantbits)\n\t// Next highest floating point number is mant+1 << exp-mantbits.\n\t// Our upper bound is halfway between, mant*2+1 << exp-mantbits-1.\n\tupper := new(decimal)\n\tupper.Assign(mant*2 + 1)\n\tupper.Shift(exp - int(flt.mantbits) - 1)\n\n\t// d = mant << (exp - mantbits)\n\t// Next lowest floating point number is mant-1 << exp-mantbits,\n\t// unless mant-1 drops the significant bit and exp is not the minimum exp,\n\t// in which case the next lowest is mant*2-1 << exp-mantbits-1.\n\t// Either way, call it mantlo << explo-mantbits.\n\t// Our lower bound is halfway between, mantlo*2+1 << explo-mantbits-1.\n\tvar mantlo uint64\n\tvar explo int\n\tif mant > 1<<flt.mantbits || exp == minexp {\n\t\tmantlo = mant - 1\n\t\texplo = exp\n\t} else {\n\t\tmantlo = mant*2 - 1\n\t\texplo = exp - 1\n\t}\n\tlower := new(decimal)\n\tlower.Assign(mantlo*2 + 1)\n\tlower.Shift(explo - int(flt.mantbits) - 1)\n\n\t// The upper and lower bounds are possible outputs only if\n\t// the original mantissa is even, so that IEEE round-to-even\n\t// would round to the original mantissa and not the neighbors.\n\tinclusive := mant%2 == 0\n\n\t// As we walk the digits we want to know whether rounding up would fall\n\t// within the upper bound. This is tracked by upperdelta:\n\t//\n\t// If upperdelta == 0, the digits of d and upper are the same so far.\n\t//\n\t// If upperdelta == 1, we saw a difference of 1 between d and upper on a\n\t// previous digit and subsequently only 9s for d and 0s for upper.\n\t// (Thus rounding up may fall outside the bound, if it is exclusive.)\n\t//\n\t// If upperdelta == 2, then the difference is greater than 1\n\t// and we know that rounding up falls within the bound.\n\tvar upperdelta uint8\n\n\t// Now we can figure out the minimum number of digits required.\n\t// Walk along until d has distinguished itself from upper and lower.\n\tfor ui := 0; ; ui++ {\n\t\t// lower, d, and upper may have the decimal points at different\n\t\t// places. In this case upper is the longest, so we iterate from\n\t\t// ui==0 and start li and mi at (possibly) -1.\n\t\tmi := ui - upper.dp + d.dp\n\t\tif mi >= d.nd {\n\t\t\tbreak\n\t\t}\n\t\tli := ui - upper.dp + lower.dp\n\t\tl := byte('0') // lower digit\n\t\tif li >= 0 && li < lower.nd {\n\t\t\tl = lower.d[li]\n\t\t}\n\t\tm := byte('0') // middle digit\n\t\tif mi >= 0 {\n\t\t\tm = d.d[mi]\n\t\t}\n\t\tu := byte('0') // upper digit\n\t\tif ui < upper.nd {\n\t\t\tu = upper.d[ui]\n\t\t}\n\n\t\t// Okay to round down (truncate) if lower has a different digit\n\t\t// or if lower is inclusive and is exactly the result of rounding\n\t\t// down (i.e., and we have reached the final digit of lower).\n\t\tokdown := l != m || inclusive && li+1 == lower.nd\n\n\t\tswitch {\n\t\tcase upperdelta == 0 && m+1 < u:\n\t\t\t// Example:\n\t\t\t// m = 12345xxx\n\t\t\t// u = 12347xxx\n\t\t\tupperdelta = 2\n\t\tcase upperdelta == 0 && m != u:\n\t\t\t// Example:\n\t\t\t// m = 12345xxx\n\t\t\t// u = 12346xxx\n\t\t\tupperdelta = 1\n\t\tcase upperdelta == 1 && (m != '9' || u != '0'):\n\t\t\t// Example:\n\t\t\t// m = 1234598x\n\t\t\t// u = 1234600x\n\t\t\tupperdelta = 2\n\t\t}\n\t\t// Okay to round up if upper has a different digit and either upper\n\t\t// is inclusive or upper is bigger than the result of rounding up.\n\t\tokup := upperdelta > 0 && (inclusive || upperdelta > 1 || ui+1 < upper.nd)\n\n\t\t// If it's okay to do either, then round to the nearest one.\n\t\t// If it's okay to do only one, do it.\n\t\tswitch {\n\t\tcase okdown && okup:\n\t\t\td.Round(mi + 1)\n\t\t\treturn\n\t\tcase okdown:\n\t\t\td.RoundDown(mi + 1)\n\t\t\treturn\n\t\tcase okup:\n\t\t\td.RoundUp(mi + 1)\n\t\t\treturn\n\t\t}\n\t}\n}\n\ntype decimalSlice struct {\n\td      []byte\n\tnd, dp int\n\tneg    bool\n}\n\n// %e: -d.ddddde\u00b1dd\nfunc fmtE(dst []byte, neg bool, d decimalSlice, prec int, fmt byte) []byte {\n\t// sign\n\tif neg {\n\t\tdst = append(dst, '-')\n\t}\n\n\t// first digit\n\tch := byte('0')\n\tif d.nd != 0 {\n\t\tch = d.d[0]\n\t}\n\tdst = append(dst, ch)\n\n\t// .moredigits\n\tif prec > 0 {\n\t\tdst = append(dst, '.')\n\t\ti := 1\n\t\tm := min(d.nd, prec+1)\n\t\tif i < m {\n\t\t\tdst = append(dst, d.d[i:m]...)\n\t\t\ti = m\n\t\t}\n\t\tfor ; i <= prec; i++ {\n\t\t\tdst = append(dst, '0')\n\t\t}\n\t}\n\n\t// e\u00b1\n\tdst = append(dst, fmt)\n\texp := d.dp - 1\n\tif d.nd == 0 { // special case: 0 has exponent 0\n\t\texp = 0\n\t}\n\tif exp < 0 {\n\t\tch = '-'\n\t\texp = -exp\n\t} else {\n\t\tch = '+'\n\t}\n\tdst = append(dst, ch)\n\n\t// dd or ddd\n\tswitch {\n\tcase exp < 10:\n\t\tdst = append(dst, '0', byte(exp)+'0')\n\tcase exp < 100:\n\t\tdst = append(dst, byte(exp/10)+'0', byte(exp%10)+'0')\n\tdefault:\n\t\tdst = append(dst, byte(exp/100)+'0', byte(exp/10)%10+'0', byte(exp%10)+'0')\n\t}\n\n\treturn dst\n}\n\n// %f: -ddddddd.ddddd\nfunc fmtF(dst []byte, neg bool, d decimalSlice, prec int) []byte {\n\t// sign\n\tif neg {\n\t\tdst = append(dst, '-')\n\t}\n\n\t// integer, padded with zeros as needed.\n\tif d.dp > 0 {\n\t\tm := min(d.nd, d.dp)\n\t\tdst = append(dst, d.d[:m]...)\n\t\tfor ; m < d.dp; m++ {\n\t\t\tdst = append(dst, '0')\n\t\t}\n\t} else {\n\t\tdst = append(dst, '0')\n\t}\n\n\t// fraction\n\tif prec > 0 {\n\t\tdst = append(dst, '.')\n\t\tfor i := 0; i < prec; i++ {\n\t\t\tch := byte('0')\n\t\t\tif j := d.dp + i; 0 <= j && j < d.nd {\n\t\t\t\tch = d.d[j]\n\t\t\t}\n\t\t\tdst = append(dst, ch)\n\t\t}\n\t}\n\n\treturn dst\n}\n\n// %b: -ddddddddp\u00b1ddd\nfunc fmtB(dst []byte, neg bool, mant uint64, exp int, flt *floatInfo) []byte {\n\t// sign\n\tif neg {\n\t\tdst = append(dst, '-')\n\t}\n\n\t// mantissa\n\tdst, _ = formatBits(dst, mant, 10, false, true)\n\n\t// p\n\tdst = append(dst, 'p')\n\n\t// \u00b1exponent\n\texp -= int(flt.mantbits)\n\tif exp >= 0 {\n\t\tdst = append(dst, '+')\n\t}\n\tdst, _ = formatBits(dst, uint64(exp), 10, exp < 0, true)\n\n\treturn dst\n}\n\n// %x: -0x1.yyyyyyyyp\u00b1ddd or -0x0p+0. (y is hex digit, d is decimal digit)\nfunc fmtX(dst []byte, prec int, fmt byte, neg bool, mant uint64, exp int, flt *floatInfo) []byte {\n\tif mant == 0 {\n\t\texp = 0\n\t}\n\n\t// Shift digits so leading 1 (if any) is at bit 1<<60.\n\tmant <<= 60 - flt.mantbits\n\tfor mant != 0 && mant&(1<<60) == 0 {\n\t\tmant <<= 1\n\t\texp--\n\t}\n\n\t// Round if requested.\n\tif prec >= 0 && prec < 15 {\n\t\tshift := uint(prec * 4)\n\t\textra := (mant << shift) & (1<<60 - 1)\n\t\tmant >>= 60 - shift\n\t\tif extra|(mant&1) > 1<<59 {\n\t\t\tmant++\n\t\t}\n\t\tmant <<= 60 - shift\n\t\tif mant&(1<<61) != 0 {\n\t\t\t// Wrapped around.\n\t\t\tmant >>= 1\n\t\t\texp++\n\t\t}\n\t}\n\n\thex := lowerhex\n\tif fmt == 'X' {\n\t\thex = upperhex\n\t}\n\n\t// sign, 0x, leading digit\n\tif neg {\n\t\tdst = append(dst, '-')\n\t}\n\tdst = append(dst, '0', fmt, '0'+byte((mant>>60)&1))\n\n\t// .fraction\n\tmant <<= 4 // remove leading 0 or 1\n\tif prec < 0 && mant != 0 {\n\t\tdst = append(dst, '.')\n\t\tfor mant != 0 {\n\t\t\tdst = append(dst, hex[(mant>>60)&15])\n\t\t\tmant <<= 4\n\t\t}\n\t} else if prec > 0 {\n\t\tdst = append(dst, '.')\n\t\tfor i := 0; i < prec; i++ {\n\t\t\tdst = append(dst, hex[(mant>>60)&15])\n\t\t\tmant <<= 4\n\t\t}\n\t}\n\n\t// p\u00b1\n\tch := byte('P')\n\tif fmt == lower(fmt) {\n\t\tch = 'p'\n\t}\n\tdst = append(dst, ch)\n\tif exp < 0 {\n\t\tch = '-'\n\t\texp = -exp\n\t} else {\n\t\tch = '+'\n\t}\n\tdst = append(dst, ch)\n\n\t// dd or ddd or dddd\n\tswitch {\n\tcase exp < 100:\n\t\tdst = append(dst, byte(exp/10)+'0', byte(exp%10)+'0')\n\tcase exp < 1000:\n\t\tdst = append(dst, byte(exp/100)+'0', byte((exp/10)%10)+'0', byte(exp%10)+'0')\n\tdefault:\n\t\tdst = append(dst, byte(exp/1000)+'0', byte(exp/100)%10+'0', byte((exp/10)%10)+'0', byte(exp%10)+'0')\n\t}\n\n\treturn dst\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n","// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage strconv\n\nimport (\n\t\"math/bits\"\n)\n\n// binary to decimal conversion using the Ry\u016b algorithm.\n//\n// See Ulf Adams, \"Ry\u016b: Fast Float-to-String Conversion\" (doi:10.1145/3192366.3192369)\n//\n// Fixed precision formatting is a variant of the original paper's\n// algorithm, where a single multiplication by 10^k is required,\n// sharing the same rounding guarantees.\n\n// ryuFtoaFixed32 formats mant*(2^exp) with prec decimal digits.\nfunc ryuFtoaFixed32(d *decimalSlice, mant uint32, exp int, prec int) {\n\tif prec < 0 {\n\t\tpanic(\"ryuFtoaFixed32 called with negative prec\")\n\t}\n\tif prec > 9 {\n\t\tpanic(\"ryuFtoaFixed32 called with prec > 9\")\n\t}\n\t// Zero input.\n\tif mant == 0 {\n\t\td.nd, d.dp = 0, 0\n\t\treturn\n\t}\n\t// Renormalize to a 25-bit mantissa.\n\te2 := exp\n\tif b := bits.Len32(mant); b < 25 {\n\t\tmant <<= uint(25 - b)\n\t\te2 += int(b) - 25\n\t}\n\t// Choose an exponent such that rounded mant*(2^e2)*(10^q) has\n\t// at least prec decimal digits, i.e\n\t//     mant*(2^e2)*(10^q) >= 10^(prec-1)\n\t// Because mant >= 2^24, it is enough to choose:\n\t//     2^(e2+24) >= 10^(-q+prec-1)\n\t// or q = -mulByLog2Log10(e2+24) + prec - 1\n\tq := -mulByLog2Log10(e2+24) + prec - 1\n\n\t// Now compute mant*(2^e2)*(10^q).\n\t// Is it an exact computation?\n\t// Only small positive powers of 10 are exact (5^28 has 66 bits).\n\texact := q <= 27 && q >= 0\n\n\tdi, dexp2, d0 := mult64bitPow10(mant, e2, q)\n\tif dexp2 >= 0 {\n\t\tpanic(\"not enough significant bits after mult64bitPow10\")\n\t}\n\t// As a special case, computation might still be exact, if exponent\n\t// was negative and if it amounts to computing an exact division.\n\t// In that case, we ignore all lower bits.\n\t// Note that division by 10^11 cannot be exact as 5^11 has 26 bits.\n\tif q < 0 && q >= -10 && divisibleByPower5(uint64(mant), -q) {\n\t\texact = true\n\t\td0 = true\n\t}\n\t// Remove extra lower bits and keep rounding info.\n\textra := uint(-dexp2)\n\textraMask := uint32(1<<extra - 1)\n\n\tdi, dfrac := di>>extra, di&extraMask\n\troundUp := false\n\tif exact {\n\t\t// If we computed an exact product, d + 1/2\n\t\t// should round to d+1 if 'd' is odd.\n\t\troundUp = dfrac > 1<<(extra-1) ||\n\t\t\t(dfrac == 1<<(extra-1) && !d0) ||\n\t\t\t(dfrac == 1<<(extra-1) && d0 && di&1 == 1)\n\t} else {\n\t\t// otherwise, d+1/2 always rounds up because\n\t\t// we truncated below.\n\t\troundUp = dfrac>>(extra-1) == 1\n\t}\n\tif dfrac != 0 {\n\t\td0 = false\n\t}\n\t// Proceed to the requested number of digits\n\tformatDecimal(d, uint64(di), !d0, roundUp, prec)\n\t// Adjust exponent\n\td.dp -= q\n}\n\n// ryuFtoaFixed64 formats mant*(2^exp) with prec decimal digits.\nfunc ryuFtoaFixed64(d *decimalSlice, mant uint64, exp int, prec int) {\n\tif prec > 18 {\n\t\tpanic(\"ryuFtoaFixed64 called with prec > 18\")\n\t}\n\t// Zero input.\n\tif mant == 0 {\n\t\td.nd, d.dp = 0, 0\n\t\treturn\n\t}\n\t// Renormalize to a 55-bit mantissa.\n\te2 := exp\n\tif b := bits.Len64(mant); b < 55 {\n\t\tmant = mant << uint(55-b)\n\t\te2 += int(b) - 55\n\t}\n\t// Choose an exponent such that rounded mant*(2^e2)*(10^q) has\n\t// at least prec decimal digits, i.e\n\t//     mant*(2^e2)*(10^q) >= 10^(prec-1)\n\t// Because mant >= 2^54, it is enough to choose:\n\t//     2^(e2+54) >= 10^(-q+prec-1)\n\t// or q = -mulByLog2Log10(e2+54) + prec - 1\n\t//\n\t// The minimal required exponent is -mulByLog2Log10(1025)+18 = -291\n\t// The maximal required exponent is mulByLog2Log10(1074)+18 = 342\n\tq := -mulByLog2Log10(e2+54) + prec - 1\n\n\t// Now compute mant*(2^e2)*(10^q).\n\t// Is it an exact computation?\n\t// Only small positive powers of 10 are exact (5^55 has 128 bits).\n\texact := q <= 55 && q >= 0\n\n\tdi, dexp2, d0 := mult128bitPow10(mant, e2, q)\n\tif dexp2 >= 0 {\n\t\tpanic(\"not enough significant bits after mult128bitPow10\")\n\t}\n\t// As a special case, computation might still be exact, if exponent\n\t// was negative and if it amounts to computing an exact division.\n\t// In that case, we ignore all lower bits.\n\t// Note that division by 10^23 cannot be exact as 5^23 has 54 bits.\n\tif q < 0 && q >= -22 && divisibleByPower5(mant, -q) {\n\t\texact = true\n\t\td0 = true\n\t}\n\t// Remove extra lower bits and keep rounding info.\n\textra := uint(-dexp2)\n\textraMask := uint64(1<<extra - 1)\n\n\tdi, dfrac := di>>extra, di&extraMask\n\troundUp := false\n\tif exact {\n\t\t// If we computed an exact product, d + 1/2\n\t\t// should round to d+1 if 'd' is odd.\n\t\troundUp = dfrac > 1<<(extra-1) ||\n\t\t\t(dfrac == 1<<(extra-1) && !d0) ||\n\t\t\t(dfrac == 1<<(extra-1) && d0 && di&1 == 1)\n\t} else {\n\t\t// otherwise, d+1/2 always rounds up because\n\t\t// we truncated below.\n\t\troundUp = dfrac>>(extra-1) == 1\n\t}\n\tif dfrac != 0 {\n\t\td0 = false\n\t}\n\t// Proceed to the requested number of digits\n\tformatDecimal(d, di, !d0, roundUp, prec)\n\t// Adjust exponent\n\td.dp -= q\n}\n\nvar uint64pow10 = [...]uint64{\n\t1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n\t1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n}\n\n// formatDecimal fills d with at most prec decimal digits\n// of mantissa m. The boolean trunc indicates whether m\n// is truncated compared to the original number being formatted.\nfunc formatDecimal(d *decimalSlice, m uint64, trunc bool, roundUp bool, prec int) {\n\tmax := uint64pow10[prec]\n\ttrimmed := 0\n\tfor m >= max {\n\t\ta, b := m/10, m%10\n\t\tm = a\n\t\ttrimmed++\n\t\tif b > 5 {\n\t\t\troundUp = true\n\t\t} else if b < 5 {\n\t\t\troundUp = false\n\t\t} else { // b == 5\n\t\t\t// round up if there are trailing digits,\n\t\t\t// or if the new value of m is odd (round-to-even convention)\n\t\t\troundUp = trunc || m&1 == 1\n\t\t}\n\t\tif b != 0 {\n\t\t\ttrunc = true\n\t\t}\n\t}\n\tif roundUp {\n\t\tm++\n\t}\n\tif m >= max {\n\t\t// Happens if di was originally 99999....xx\n\t\tm /= 10\n\t\ttrimmed++\n\t}\n\t// render digits (similar to formatBits)\n\tn := uint(prec)\n\td.nd = int(prec)\n\tv := m\n\tfor v >= 100 {\n\t\tvar v1, v2 uint64\n\t\tif v>>32 == 0 {\n\t\t\tv1, v2 = uint64(uint32(v)/100), uint64(uint32(v)%100)\n\t\t} else {\n\t\t\tv1, v2 = v/100, v%100\n\t\t}\n\t\tn -= 2\n\t\td.d[n+1] = smallsString[2*v2+1]\n\t\td.d[n+0] = smallsString[2*v2+0]\n\t\tv = v1\n\t}\n\tif v > 0 {\n\t\tn--\n\t\td.d[n] = smallsString[2*v+1]\n\t}\n\tif v >= 10 {\n\t\tn--\n\t\td.d[n] = smallsString[2*v]\n\t}\n\tfor d.d[d.nd-1] == '0' {\n\t\td.nd--\n\t\ttrimmed++\n\t}\n\td.dp = d.nd + trimmed\n}\n\n// ryuFtoaShortest formats mant*2^exp with prec decimal digits.\nfunc ryuFtoaShortest(d *decimalSlice, mant uint64, exp int, flt *floatInfo) {\n\tif mant == 0 {\n\t\td.nd, d.dp = 0, 0\n\t\treturn\n\t}\n\t// If input is an exact integer with fewer bits than the mantissa,\n\t// the previous and next integer are not admissible representations.\n\tif exp <= 0 && bits.TrailingZeros64(mant) >= -exp {\n\t\tmant >>= uint(-exp)\n\t\tryuDigits(d, mant, mant, mant, true, false)\n\t\treturn\n\t}\n\tml, mc, mu, e2 := computeBounds(mant, exp, flt)\n\tif e2 == 0 {\n\t\tryuDigits(d, ml, mc, mu, true, false)\n\t\treturn\n\t}\n\t// Find 10^q *larger* than 2^-e2\n\tq := mulByLog2Log10(-e2) + 1\n\n\t// We are going to multiply by 10^q using 128-bit arithmetic.\n\t// The exponent is the same for all 3 numbers.\n\tvar dl, dc, du uint64\n\tvar dl0, dc0, du0 bool\n\tif flt == &float32info {\n\t\tvar dl32, dc32, du32 uint32\n\t\tdl32, _, dl0 = mult64bitPow10(uint32(ml), e2, q)\n\t\tdc32, _, dc0 = mult64bitPow10(uint32(mc), e2, q)\n\t\tdu32, e2, du0 = mult64bitPow10(uint32(mu), e2, q)\n\t\tdl, dc, du = uint64(dl32), uint64(dc32), uint64(du32)\n\t} else {\n\t\tdl, _, dl0 = mult128bitPow10(ml, e2, q)\n\t\tdc, _, dc0 = mult128bitPow10(mc, e2, q)\n\t\tdu, e2, du0 = mult128bitPow10(mu, e2, q)\n\t}\n\tif e2 >= 0 {\n\t\tpanic(\"not enough significant bits after mult128bitPow10\")\n\t}\n\t// Is it an exact computation?\n\tif q > 55 {\n\t\t// Large positive powers of ten are not exact\n\t\tdl0, dc0, du0 = false, false, false\n\t}\n\tif q < 0 && q >= -24 {\n\t\t// Division by a power of ten may be exact.\n\t\t// (note that 5^25 is a 59-bit number so division by 5^25 is never exact).\n\t\tif divisibleByPower5(ml, -q) {\n\t\t\tdl0 = true\n\t\t}\n\t\tif divisibleByPower5(mc, -q) {\n\t\t\tdc0 = true\n\t\t}\n\t\tif divisibleByPower5(mu, -q) {\n\t\t\tdu0 = true\n\t\t}\n\t}\n\t// Express the results (dl, dc, du)*2^e2 as integers.\n\t// Extra bits must be removed and rounding hints computed.\n\textra := uint(-e2)\n\textraMask := uint64(1<<extra - 1)\n\t// Now compute the floored, integral base 10 mantissas.\n\tdl, fracl := dl>>extra, dl&extraMask\n\tdc, fracc := dc>>extra, dc&extraMask\n\tdu, fracu := du>>extra, du&extraMask\n\t// Is it allowed to use 'du' as a result?\n\t// It is always allowed when it is truncated, but also\n\t// if it is exact and the original binary mantissa is even\n\t// When disallowed, we can substract 1.\n\tuok := !du0 || fracu > 0\n\tif du0 && fracu == 0 {\n\t\tuok = mant&1 == 0\n\t}\n\tif !uok {\n\t\tdu--\n\t}\n\t// Is 'dc' the correctly rounded base 10 mantissa?\n\t// The correct rounding might be dc+1\n\tcup := false // don't round up.\n\tif dc0 {\n\t\t// If we computed an exact product, the half integer\n\t\t// should round to next (even) integer if 'dc' is odd.\n\t\tcup = fracc > 1<<(extra-1) ||\n\t\t\t(fracc == 1<<(extra-1) && dc&1 == 1)\n\t} else {\n\t\t// otherwise, the result is a lower truncation of the ideal\n\t\t// result.\n\t\tcup = fracc>>(extra-1) == 1\n\t}\n\t// Is 'dl' an allowed representation?\n\t// Only if it is an exact value, and if the original binary mantissa\n\t// was even.\n\tlok := dl0 && fracl == 0 && (mant&1 == 0)\n\tif !lok {\n\t\tdl++\n\t}\n\t// We need to remember whether the trimmed digits of 'dc' are zero.\n\tc0 := dc0 && fracc == 0\n\t// render digits\n\tryuDigits(d, dl, dc, du, c0, cup)\n\td.dp -= q\n}\n\n// mulByLog2Log10 returns math.Floor(x * log(2)/log(10)) for an integer x in\n// the range -1600 <= x && x <= +1600.\n//\n// The range restriction lets us work in faster integer arithmetic instead of\n// slower floating point arithmetic. Correctness is verified by unit tests.\nfunc mulByLog2Log10(x int) int {\n\t// log(2)/log(10) \u2248 0.30102999566 \u2248 78913 / 2^18\n\treturn (x * 78913) >> 18\n}\n\n// mulByLog10Log2 returns math.Floor(x * log(10)/log(2)) for an integer x in\n// the range -500 <= x && x <= +500.\n//\n// The range restriction lets us work in faster integer arithmetic instead of\n// slower floating point arithmetic. Correctness is verified by unit tests.\nfunc mulByLog10Log2(x int) int {\n\t// log(10)/log(2) \u2248 3.32192809489 \u2248 108853 / 2^15\n\treturn (x * 108853) >> 15\n}\n\n// computeBounds returns a floating-point vector (l, c, u)\u00d72^e2\n// where the mantissas are 55-bit (or 26-bit) integers, describing the interval\n// represented by the input float64 or float32.\nfunc computeBounds(mant uint64, exp int, flt *floatInfo) (lower, central, upper uint64, e2 int) {\n\tif mant != 1<<flt.mantbits || exp == flt.bias+1-int(flt.mantbits) {\n\t\t// regular case (or denormals)\n\t\tlower, central, upper = 2*mant-1, 2*mant, 2*mant+1\n\t\te2 = exp - 1\n\t\treturn\n\t} else {\n\t\t// border of an exponent\n\t\tlower, central, upper = 4*mant-1, 4*mant, 4*mant+2\n\t\te2 = exp - 2\n\t\treturn\n\t}\n}\n\nfunc ryuDigits(d *decimalSlice, lower, central, upper uint64,\n\tc0, cup bool) {\n\tlhi, llo := divmod1e9(lower)\n\tchi, clo := divmod1e9(central)\n\tuhi, ulo := divmod1e9(upper)\n\tif uhi == 0 {\n\t\t// only low digits (for denormals)\n\t\tryuDigits32(d, llo, clo, ulo, c0, cup, 8)\n\t} else if lhi < uhi {\n\t\t// truncate 9 digits at once.\n\t\tif llo != 0 {\n\t\t\tlhi++\n\t\t}\n\t\tc0 = c0 && clo == 0\n\t\tcup = (clo > 5e8) || (clo == 5e8 && cup)\n\t\tryuDigits32(d, lhi, chi, uhi, c0, cup, 8)\n\t\td.dp += 9\n\t} else {\n\t\td.nd = 0\n\t\t// emit high part\n\t\tn := uint(9)\n\t\tfor v := chi; v > 0; {\n\t\t\tv1, v2 := v/10, v%10\n\t\t\tv = v1\n\t\t\tn--\n\t\t\td.d[n] = byte(v2 + '0')\n\t\t}\n\t\td.d = d.d[n:]\n\t\td.nd = int(9 - n)\n\t\t// emit low part\n\t\tryuDigits32(d, llo, clo, ulo,\n\t\t\tc0, cup, d.nd+8)\n\t}\n\t// trim trailing zeros\n\tfor d.nd > 0 && d.d[d.nd-1] == '0' {\n\t\td.nd--\n\t}\n\t// trim initial zeros\n\tfor d.nd > 0 && d.d[0] == '0' {\n\t\td.nd--\n\t\td.dp--\n\t\td.d = d.d[1:]\n\t}\n}\n\n// ryuDigits32 emits decimal digits for a number less than 1e9.\nfunc ryuDigits32(d *decimalSlice, lower, central, upper uint32,\n\tc0, cup bool, endindex int) {\n\tif upper == 0 {\n\t\td.dp = endindex + 1\n\t\treturn\n\t}\n\ttrimmed := 0\n\t// Remember last trimmed digit to check for round-up.\n\t// c0 will be used to remember zeroness of following digits.\n\tcNextDigit := 0\n\tfor upper > 0 {\n\t\t// Repeatedly compute:\n\t\t// l = Ceil(lower / 10^k)\n\t\t// c = Round(central / 10^k)\n\t\t// u = Floor(upper / 10^k)\n\t\t// and stop when c goes out of the (l, u) interval.\n\t\tl := (lower + 9) / 10\n\t\tc, cdigit := central/10, central%10\n\t\tu := upper / 10\n\t\tif l > u {\n\t\t\t// don't trim the last digit as it is forbidden to go below l\n\t\t\t// other, trim and exit now.\n\t\t\tbreak\n\t\t}\n\t\t// Check that we didn't cross the lower boundary.\n\t\t// The case where l < u but c == l-1 is essentially impossible,\n\t\t// but may happen if:\n\t\t//    lower   = ..11\n\t\t//    central = ..19\n\t\t//    upper   = ..31\n\t\t// and means that 'central' is very close but less than\n\t\t// an integer ending with many zeros, and usually\n\t\t// the \"round-up\" logic hides the problem.\n\t\tif l == c+1 && c < u {\n\t\t\tc++\n\t\t\tcdigit = 0\n\t\t\tcup = false\n\t\t}\n\t\ttrimmed++\n\t\t// Remember trimmed digits of c\n\t\tc0 = c0 && cNextDigit == 0\n\t\tcNextDigit = int(cdigit)\n\t\tlower, central, upper = l, c, u\n\t}\n\t// should we round up?\n\tif trimmed > 0 {\n\t\tcup = cNextDigit > 5 ||\n\t\t\t(cNextDigit == 5 && !c0) ||\n\t\t\t(cNextDigit == 5 && c0 && central&1 == 1)\n\t}\n\tif central < upper && cup {\n\t\tcentral++\n\t}\n\t// We know where the number ends, fill directly\n\tendindex -= trimmed\n\tv := central\n\tn := endindex\n\tfor n > d.nd {\n\t\tv1, v2 := v/100, v%100\n\t\td.d[n] = smallsString[2*v2+1]\n\t\td.d[n-1] = smallsString[2*v2+0]\n\t\tn -= 2\n\t\tv = v1\n\t}\n\tif n == d.nd {\n\t\td.d[n] = byte(v + '0')\n\t}\n\td.nd = endindex + 1\n\td.dp = d.nd + trimmed\n}\n\n// mult64bitPow10 takes a floating-point input with a 25-bit\n// mantissa and multiplies it with 10^q. The resulting mantissa\n// is m*P >> 57 where P is a 64-bit element of the detailedPowersOfTen tables.\n// It is typically 31 or 32-bit wide.\n// The returned boolean is true if all trimmed bits were zero.\n//\n// That is:\n//     m*2^e2 * round(10^q) = resM * 2^resE + \u03b5\n//     exact = \u03b5 == 0\nfunc mult64bitPow10(m uint32, e2, q int) (resM uint32, resE int, exact bool) {\n\tif q == 0 {\n\t\t// P == 1<<63\n\t\treturn m << 6, e2 - 6, true\n\t}\n\tif q < detailedPowersOfTenMinExp10 || detailedPowersOfTenMaxExp10 < q {\n\t\t// This never happens due to the range of float32/float64 exponent\n\t\tpanic(\"mult64bitPow10: power of 10 is out of range\")\n\t}\n\tpow := detailedPowersOfTen[q-detailedPowersOfTenMinExp10][1]\n\tif q < 0 {\n\t\t// Inverse powers of ten must be rounded up.\n\t\tpow += 1\n\t}\n\thi, lo := bits.Mul64(uint64(m), pow)\n\te2 += mulByLog10Log2(q) - 63 + 57\n\treturn uint32(hi<<7 | lo>>57), e2, lo<<7 == 0\n}\n\n// mult128bitPow10 takes a floating-point input with a 55-bit\n// mantissa and multiplies it with 10^q. The resulting mantissa\n// is m*P >> 119 where P is a 128-bit element of the detailedPowersOfTen tables.\n// It is typically 63 or 64-bit wide.\n// The returned boolean is true is all trimmed bits were zero.\n//\n// That is:\n//     m*2^e2 * round(10^q) = resM * 2^resE + \u03b5\n//     exact = \u03b5 == 0\nfunc mult128bitPow10(m uint64, e2, q int) (resM uint64, resE int, exact bool) {\n\tif q == 0 {\n\t\t// P == 1<<127\n\t\treturn m << 8, e2 - 8, true\n\t}\n\tif q < detailedPowersOfTenMinExp10 || detailedPowersOfTenMaxExp10 < q {\n\t\t// This never happens due to the range of float32/float64 exponent\n\t\tpanic(\"mult128bitPow10: power of 10 is out of range\")\n\t}\n\tpow := detailedPowersOfTen[q-detailedPowersOfTenMinExp10]\n\tif q < 0 {\n\t\t// Inverse powers of ten must be rounded up.\n\t\tpow[0] += 1\n\t}\n\te2 += mulByLog10Log2(q) - 127 + 119\n\n\t// long multiplication\n\tl1, l0 := bits.Mul64(m, pow[0])\n\th1, h0 := bits.Mul64(m, pow[1])\n\tmid, carry := bits.Add64(l1, h0, 0)\n\th1 += carry\n\treturn h1<<9 | mid>>55, e2, mid<<9 == 0 && l0 == 0\n}\n\nfunc divisibleByPower5(m uint64, k int) bool {\n\tif m == 0 {\n\t\treturn true\n\t}\n\tfor i := 0; i < k; i++ {\n\t\tif m%5 != 0 {\n\t\t\treturn false\n\t\t}\n\t\tm /= 5\n\t}\n\treturn true\n}\n\n// divmod1e9 computes quotient and remainder of division by 1e9,\n// avoiding runtime uint64 division on 32-bit platforms.\nfunc divmod1e9(x uint64) (uint32, uint32) {\n\tif !host32bit {\n\t\treturn uint32(x / 1e9), uint32(x % 1e9)\n\t}\n\t// Use the same sequence of operations as the amd64 compiler.\n\thi, _ := bits.Mul64(x>>1, 0x89705f4136b4a598) // binary digits of 1e-9\n\tq := hi >> 28\n\treturn uint32(q), uint32(x - q*1e9)\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage strconv\n\nimport \"errors\"\n\n// lower(c) is a lower-case letter if and only if\n// c is either that lower-case letter or the equivalent upper-case letter.\n// Instead of writing c == 'x' || c == 'X' one can write lower(c) == 'x'.\n// Note that lower of non-letters can produce other non-letters.\nfunc lower(c byte) byte {\n\treturn c | ('x' - 'X')\n}\n\n// ErrRange indicates that a value is out of range for the target type.\nvar ErrRange = errors.New(\"value out of range\")\n\n// ErrSyntax indicates that a value does not have the right syntax for the target type.\nvar ErrSyntax = errors.New(\"invalid syntax\")\n\n// A NumError records a failed conversion.\ntype NumError struct {\n\tFunc string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat, ParseComplex)\n\tNum  string // the input\n\tErr  error  // the reason the conversion failed (e.g. ErrRange, ErrSyntax, etc.)\n}\n\nfunc (e *NumError) Error() string {\n\treturn \"strconv.\" + e.Func + \": \" + \"parsing \" + Quote(e.Num) + \": \" + e.Err.Error()\n}\n\nfunc (e *NumError) Unwrap() error { return e.Err }\n\nfunc syntaxError(fn, str string) *NumError {\n\treturn &NumError{fn, str, ErrSyntax}\n}\n\nfunc rangeError(fn, str string) *NumError {\n\treturn &NumError{fn, str, ErrRange}\n}\n\nfunc baseError(fn, str string, base int) *NumError {\n\treturn &NumError{fn, str, errors.New(\"invalid base \" + Itoa(base))}\n}\n\nfunc bitSizeError(fn, str string, bitSize int) *NumError {\n\treturn &NumError{fn, str, errors.New(\"invalid bit size \" + Itoa(bitSize))}\n}\n\nconst intSize = 32 << (^uint(0) >> 63)\n\n// IntSize is the size in bits of an int or uint value.\nconst IntSize = intSize\n\nconst maxUint64 = 1<<64 - 1\n\n// ParseUint is like ParseInt but for unsigned numbers.\n//\n// A sign prefix is not permitted.\nfunc ParseUint(s string, base int, bitSize int) (uint64, error) {\n\tconst fnParseUint = \"ParseUint\"\n\n\tif s == \"\" {\n\t\treturn 0, syntaxError(fnParseUint, s)\n\t}\n\n\tbase0 := base == 0\n\n\ts0 := s\n\tswitch {\n\tcase 2 <= base && base <= 36:\n\t\t// valid base; nothing to do\n\n\tcase base == 0:\n\t\t// Look for octal, hex prefix.\n\t\tbase = 10\n\t\tif s[0] == '0' {\n\t\t\tswitch {\n\t\t\tcase len(s) >= 3 && lower(s[1]) == 'b':\n\t\t\t\tbase = 2\n\t\t\t\ts = s[2:]\n\t\t\tcase len(s) >= 3 && lower(s[1]) == 'o':\n\t\t\t\tbase = 8\n\t\t\t\ts = s[2:]\n\t\t\tcase len(s) >= 3 && lower(s[1]) == 'x':\n\t\t\t\tbase = 16\n\t\t\t\ts = s[2:]\n\t\t\tdefault:\n\t\t\t\tbase = 8\n\t\t\t\ts = s[1:]\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\treturn 0, baseError(fnParseUint, s0, base)\n\t}\n\n\tif bitSize == 0 {\n\t\tbitSize = IntSize\n\t} else if bitSize < 0 || bitSize > 64 {\n\t\treturn 0, bitSizeError(fnParseUint, s0, bitSize)\n\t}\n\n\t// Cutoff is the smallest number such that cutoff*base > maxUint64.\n\t// Use compile-time constants for common cases.\n\tvar cutoff uint64\n\tswitch base {\n\tcase 10:\n\t\tcutoff = maxUint64/10 + 1\n\tcase 16:\n\t\tcutoff = maxUint64/16 + 1\n\tdefault:\n\t\tcutoff = maxUint64/uint64(base) + 1\n\t}\n\n\tmaxVal := uint64(1)<<uint(bitSize) - 1\n\n\tunderscores := false\n\tvar n uint64\n\tfor _, c := range []byte(s) {\n\t\tvar d byte\n\t\tswitch {\n\t\tcase c == '_' && base0:\n\t\t\tunderscores = true\n\t\t\tcontinue\n\t\tcase '0' <= c && c <= '9':\n\t\t\td = c - '0'\n\t\tcase 'a' <= lower(c) && lower(c) <= 'z':\n\t\t\td = lower(c) - 'a' + 10\n\t\tdefault:\n\t\t\treturn 0, syntaxError(fnParseUint, s0)\n\t\t}\n\n\t\tif d >= byte(base) {\n\t\t\treturn 0, syntaxError(fnParseUint, s0)\n\t\t}\n\n\t\tif n >= cutoff {\n\t\t\t// n*base overflows\n\t\t\treturn maxVal, rangeError(fnParseUint, s0)\n\t\t}\n\t\tn *= uint64(base)\n\n\t\tn1 := n + uint64(d)\n\t\tif n1 < n || n1 > maxVal {\n\t\t\t// n+d overflows\n\t\t\treturn maxVal, rangeError(fnParseUint, s0)\n\t\t}\n\t\tn = n1\n\t}\n\n\tif underscores && !underscoreOK(s0) {\n\t\treturn 0, syntaxError(fnParseUint, s0)\n\t}\n\n\treturn n, nil\n}\n\n// ParseInt interprets a string s in the given base (0, 2 to 36) and\n// bit size (0 to 64) and returns the corresponding value i.\n//\n// The string may begin with a leading sign: \"+\" or \"-\".\n//\n// If the base argument is 0, the true base is implied by the string's\n// prefix following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\",\n// 16 for \"0x\", and 10 otherwise. Also, for argument base 0 only,\n// underscore characters are permitted as defined by the Go syntax for\n// integer literals.\n//\n// The bitSize argument specifies the integer type\n// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64\n// correspond to int, int8, int16, int32, and int64.\n// If bitSize is below 0 or above 64, an error is returned.\n//\n// The errors that ParseInt returns have concrete type *NumError\n// and include err.Num = s. If s is empty or contains invalid\n// digits, err.Err = ErrSyntax and the returned value is 0;\n// if the value corresponding to s cannot be represented by a\n// signed integer of the given size, err.Err = ErrRange and the\n// returned value is the maximum magnitude integer of the\n// appropriate bitSize and sign.\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error) {\n\tconst fnParseInt = \"ParseInt\"\n\n\tif s == \"\" {\n\t\treturn 0, syntaxError(fnParseInt, s)\n\t}\n\n\t// Pick off leading sign.\n\ts0 := s\n\tneg := false\n\tif s[0] == '+' {\n\t\ts = s[1:]\n\t} else if s[0] == '-' {\n\t\tneg = true\n\t\ts = s[1:]\n\t}\n\n\t// Convert unsigned and check range.\n\tvar un uint64\n\tun, err = ParseUint(s, base, bitSize)\n\tif err != nil && err.(*NumError).Err != ErrRange {\n\t\terr.(*NumError).Func = fnParseInt\n\t\terr.(*NumError).Num = s0\n\t\treturn 0, err\n\t}\n\n\tif bitSize == 0 {\n\t\tbitSize = IntSize\n\t}\n\n\tcutoff := uint64(1 << uint(bitSize-1))\n\tif !neg && un >= cutoff {\n\t\treturn int64(cutoff - 1), rangeError(fnParseInt, s0)\n\t}\n\tif neg && un > cutoff {\n\t\treturn -int64(cutoff), rangeError(fnParseInt, s0)\n\t}\n\tn := int64(un)\n\tif neg {\n\t\tn = -n\n\t}\n\treturn n, nil\n}\n\n// Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.\nfunc Atoi(s string) (int, error) {\n\tconst fnAtoi = \"Atoi\"\n\n\tsLen := len(s)\n\tif intSize == 32 && (0 < sLen && sLen < 10) ||\n\t\tintSize == 64 && (0 < sLen && sLen < 19) {\n\t\t// Fast path for small integers that fit int type.\n\t\ts0 := s\n\t\tif s[0] == '-' || s[0] == '+' {\n\t\t\ts = s[1:]\n\t\t\tif len(s) < 1 {\n\t\t\t\treturn 0, &NumError{fnAtoi, s0, ErrSyntax}\n\t\t\t}\n\t\t}\n\n\t\tn := 0\n\t\tfor _, ch := range []byte(s) {\n\t\t\tch -= '0'\n\t\t\tif ch > 9 {\n\t\t\t\treturn 0, &NumError{fnAtoi, s0, ErrSyntax}\n\t\t\t}\n\t\t\tn = n*10 + int(ch)\n\t\t}\n\t\tif s0[0] == '-' {\n\t\t\tn = -n\n\t\t}\n\t\treturn n, nil\n\t}\n\n\t// Slow path for invalid, big, or underscored integers.\n\ti64, err := ParseInt(s, 10, 0)\n\tif nerr, ok := err.(*NumError); ok {\n\t\tnerr.Func = fnAtoi\n\t}\n\treturn int(i64), err\n}\n\n// underscoreOK reports whether the underscores in s are allowed.\n// Checking them in this one function lets all the parsers skip over them simply.\n// Underscore must appear only between digits or between a base prefix and a digit.\nfunc underscoreOK(s string) bool {\n\t// saw tracks the last character (class) we saw:\n\t// ^ for beginning of number,\n\t// 0 for a digit or base prefix,\n\t// _ for an underscore,\n\t// ! for none of the above.\n\tsaw := '^'\n\ti := 0\n\n\t// Optional sign.\n\tif len(s) >= 1 && (s[0] == '-' || s[0] == '+') {\n\t\ts = s[1:]\n\t}\n\n\t// Optional base prefix.\n\thex := false\n\tif len(s) >= 2 && s[0] == '0' && (lower(s[1]) == 'b' || lower(s[1]) == 'o' || lower(s[1]) == 'x') {\n\t\ti = 2\n\t\tsaw = '0' // base prefix counts as a digit for \"underscore as digit separator\"\n\t\thex = lower(s[1]) == 'x'\n\t}\n\n\t// Number proper.\n\tfor ; i < len(s); i++ {\n\t\t// Digits are always okay.\n\t\tif '0' <= s[i] && s[i] <= '9' || hex && 'a' <= lower(s[i]) && lower(s[i]) <= 'f' {\n\t\t\tsaw = '0'\n\t\t\tcontinue\n\t\t}\n\t\t// Underscore must follow digit.\n\t\tif s[i] == '_' {\n\t\t\tif saw != '0' {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tsaw = '_'\n\t\t\tcontinue\n\t\t}\n\t\t// Underscore must also be followed by digit.\n\t\tif saw == '_' {\n\t\t\treturn false\n\t\t}\n\t\t// Saw non-digit, non-underscore.\n\t\tsaw = '!'\n\t}\n\treturn saw != '_'\n}\n","// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage fmt\n\nimport (\n\t\"strconv\"\n\t\"unicode/utf8\"\n)\n\nconst (\n\tldigits = \"0123456789abcdefx\"\n\tudigits = \"0123456789ABCDEFX\"\n)\n\nconst (\n\tsigned   = true\n\tunsigned = false\n)\n\n// flags placed in a separate struct for easy clearing.\ntype fmtFlags struct {\n\twidPresent  bool\n\tprecPresent bool\n\tminus       bool\n\tplus        bool\n\tsharp       bool\n\tspace       bool\n\tzero        bool\n\n\t// For the formats %+v %#v, we set the plusV/sharpV flags\n\t// and clear the plus/sharp flags since %+v and %#v are in effect\n\t// different, flagless formats set at the top level.\n\tplusV  bool\n\tsharpV bool\n}\n\n// A fmt is the raw formatter used by Printf etc.\n// It prints into a buffer that must be set up separately.\ntype fmt struct {\n\tbuf *buffer\n\n\tfmtFlags\n\n\twid  int // width\n\tprec int // precision\n\n\t// intbuf is large enough to store %b of an int64 with a sign and\n\t// avoids padding at the end of the struct on 32 bit architectures.\n\tintbuf [68]byte\n}\n\nfunc (f *fmt) clearflags() {\n\tf.fmtFlags = fmtFlags{}\n}\n\nfunc (f *fmt) init(buf *buffer) {\n\tf.buf = buf\n\tf.clearflags()\n}\n\n// writePadding generates n bytes of padding.\nfunc (f *fmt) writePadding(n int) {\n\tif n <= 0 { // No padding bytes needed.\n\t\treturn\n\t}\n\tbuf := *f.buf\n\toldLen := len(buf)\n\tnewLen := oldLen + n\n\t// Make enough room for padding.\n\tif newLen > cap(buf) {\n\t\tbuf = make(buffer, cap(buf)*2+n)\n\t\tcopy(buf, *f.buf)\n\t}\n\t// Decide which byte the padding should be filled with.\n\tpadByte := byte(' ')\n\tif f.zero {\n\t\tpadByte = byte('0')\n\t}\n\t// Fill padding with padByte.\n\tpadding := buf[oldLen:newLen]\n\tfor i := range padding {\n\t\tpadding[i] = padByte\n\t}\n\t*f.buf = buf[:newLen]\n}\n\n// pad appends b to f.buf, padded on left (!f.minus) or right (f.minus).\nfunc (f *fmt) pad(b []byte) {\n\tif !f.widPresent || f.wid == 0 {\n\t\tf.buf.write(b)\n\t\treturn\n\t}\n\twidth := f.wid - utf8.RuneCount(b)\n\tif !f.minus {\n\t\t// left padding\n\t\tf.writePadding(width)\n\t\tf.buf.write(b)\n\t} else {\n\t\t// right padding\n\t\tf.buf.write(b)\n\t\tf.writePadding(width)\n\t}\n}\n\n// padString appends s to f.buf, padded on left (!f.minus) or right (f.minus).\nfunc (f *fmt) padString(s string) {\n\tif !f.widPresent || f.wid == 0 {\n\t\tf.buf.writeString(s)\n\t\treturn\n\t}\n\twidth := f.wid - utf8.RuneCountInString(s)\n\tif !f.minus {\n\t\t// left padding\n\t\tf.writePadding(width)\n\t\tf.buf.writeString(s)\n\t} else {\n\t\t// right padding\n\t\tf.buf.writeString(s)\n\t\tf.writePadding(width)\n\t}\n}\n\n// fmtBoolean formats a boolean.\nfunc (f *fmt) fmtBoolean(v bool) {\n\tif v {\n\t\tf.padString(\"true\")\n\t} else {\n\t\tf.padString(\"false\")\n\t}\n}\n\n// fmtUnicode formats a uint64 as \"U+0078\" or with f.sharp set as \"U+0078 'x'\".\nfunc (f *fmt) fmtUnicode(u uint64) {\n\tbuf := f.intbuf[0:]\n\n\t// With default precision set the maximum needed buf length is 18\n\t// for formatting -1 with %#U (\"U+FFFFFFFFFFFFFFFF\") which fits\n\t// into the already allocated intbuf with a capacity of 68 bytes.\n\tprec := 4\n\tif f.precPresent && f.prec > 4 {\n\t\tprec = f.prec\n\t\t// Compute space needed for \"U+\" , number, \" '\", character, \"'\".\n\t\twidth := 2 + prec + 2 + utf8.UTFMax + 1\n\t\tif width > len(buf) {\n\t\t\tbuf = make([]byte, width)\n\t\t}\n\t}\n\n\t// Format into buf, ending at buf[i]. Formatting numbers is easier right-to-left.\n\ti := len(buf)\n\n\t// For %#U we want to add a space and a quoted character at the end of the buffer.\n\tif f.sharp && u <= utf8.MaxRune && strconv.IsPrint(rune(u)) {\n\t\ti--\n\t\tbuf[i] = '\\''\n\t\ti -= utf8.RuneLen(rune(u))\n\t\tutf8.EncodeRune(buf[i:], rune(u))\n\t\ti--\n\t\tbuf[i] = '\\''\n\t\ti--\n\t\tbuf[i] = ' '\n\t}\n\t// Format the Unicode code point u as a hexadecimal number.\n\tfor u >= 16 {\n\t\ti--\n\t\tbuf[i] = udigits[u&0xF]\n\t\tprec--\n\t\tu >>= 4\n\t}\n\ti--\n\tbuf[i] = udigits[u]\n\tprec--\n\t// Add zeros in front of the number until requested precision is reached.\n\tfor prec > 0 {\n\t\ti--\n\t\tbuf[i] = '0'\n\t\tprec--\n\t}\n\t// Add a leading \"U+\".\n\ti--\n\tbuf[i] = '+'\n\ti--\n\tbuf[i] = 'U'\n\n\toldZero := f.zero\n\tf.zero = false\n\tf.pad(buf[i:])\n\tf.zero = oldZero\n}\n\n// fmtInteger formats signed and unsigned integers.\nfunc (f *fmt) fmtInteger(u uint64, base int, isSigned bool, verb rune, digits string) {\n\tnegative := isSigned && int64(u) < 0\n\tif negative {\n\t\tu = -u\n\t}\n\n\tbuf := f.intbuf[0:]\n\t// The already allocated f.intbuf with a capacity of 68 bytes\n\t// is large enough for integer formatting when no precision or width is set.\n\tif f.widPresent || f.precPresent {\n\t\t// Account 3 extra bytes for possible addition of a sign and \"0x\".\n\t\twidth := 3 + f.wid + f.prec // wid and prec are always positive.\n\t\tif width > len(buf) {\n\t\t\t// We're going to need a bigger boat.\n\t\t\tbuf = make([]byte, width)\n\t\t}\n\t}\n\n\t// Two ways to ask for extra leading zero digits: %.3d or %03d.\n\t// If both are specified the f.zero flag is ignored and\n\t// padding with spaces is used instead.\n\tprec := 0\n\tif f.precPresent {\n\t\tprec = f.prec\n\t\t// Precision of 0 and value of 0 means \"print nothing\" but padding.\n\t\tif prec == 0 && u == 0 {\n\t\t\toldZero := f.zero\n\t\t\tf.zero = false\n\t\t\tf.writePadding(f.wid)\n\t\t\tf.zero = oldZero\n\t\t\treturn\n\t\t}\n\t} else if f.zero && f.widPresent {\n\t\tprec = f.wid\n\t\tif negative || f.plus || f.space {\n\t\t\tprec-- // leave room for sign\n\t\t}\n\t}\n\n\t// Because printing is easier right-to-left: format u into buf, ending at buf[i].\n\t// We could make things marginally faster by splitting the 32-bit case out\n\t// into a separate block but it's not worth the duplication, so u has 64 bits.\n\ti := len(buf)\n\t// Use constants for the division and modulo for more efficient code.\n\t// Switch cases ordered by popularity.\n\tswitch base {\n\tcase 10:\n\t\tfor u >= 10 {\n\t\t\ti--\n\t\t\tnext := u / 10\n\t\t\tbuf[i] = byte('0' + u - next*10)\n\t\t\tu = next\n\t\t}\n\tcase 16:\n\t\tfor u >= 16 {\n\t\t\ti--\n\t\t\tbuf[i] = digits[u&0xF]\n\t\t\tu >>= 4\n\t\t}\n\tcase 8:\n\t\tfor u >= 8 {\n\t\t\ti--\n\t\t\tbuf[i] = byte('0' + u&7)\n\t\t\tu >>= 3\n\t\t}\n\tcase 2:\n\t\tfor u >= 2 {\n\t\t\ti--\n\t\t\tbuf[i] = byte('0' + u&1)\n\t\t\tu >>= 1\n\t\t}\n\tdefault:\n\t\tpanic(\"fmt: unknown base; can't happen\")\n\t}\n\ti--\n\tbuf[i] = digits[u]\n\tfor i > 0 && prec > len(buf)-i {\n\t\ti--\n\t\tbuf[i] = '0'\n\t}\n\n\t// Various prefixes: 0x, -, etc.\n\tif f.sharp {\n\t\tswitch base {\n\t\tcase 2:\n\t\t\t// Add a leading 0b.\n\t\t\ti--\n\t\t\tbuf[i] = 'b'\n\t\t\ti--\n\t\t\tbuf[i] = '0'\n\t\tcase 8:\n\t\t\tif buf[i] != '0' {\n\t\t\t\ti--\n\t\t\t\tbuf[i] = '0'\n\t\t\t}\n\t\tcase 16:\n\t\t\t// Add a leading 0x or 0X.\n\t\t\ti--\n\t\t\tbuf[i] = digits[16]\n\t\t\ti--\n\t\t\tbuf[i] = '0'\n\t\t}\n\t}\n\tif verb == 'O' {\n\t\ti--\n\t\tbuf[i] = 'o'\n\t\ti--\n\t\tbuf[i] = '0'\n\t}\n\n\tif negative {\n\t\ti--\n\t\tbuf[i] = '-'\n\t} else if f.plus {\n\t\ti--\n\t\tbuf[i] = '+'\n\t} else if f.space {\n\t\ti--\n\t\tbuf[i] = ' '\n\t}\n\n\t// Left padding with zeros has already been handled like precision earlier\n\t// or the f.zero flag is ignored due to an explicitly set precision.\n\toldZero := f.zero\n\tf.zero = false\n\tf.pad(buf[i:])\n\tf.zero = oldZero\n}\n\n// truncateString truncates the string s to the specified precision, if present.\nfunc (f *fmt) truncateString(s string) string {\n\tif f.precPresent {\n\t\tn := f.prec\n\t\tfor i := range s {\n\t\t\tn--\n\t\t\tif n < 0 {\n\t\t\t\treturn s[:i]\n\t\t\t}\n\t\t}\n\t}\n\treturn s\n}\n\n// truncate truncates the byte slice b as a string of the specified precision, if present.\nfunc (f *fmt) truncate(b []byte) []byte {\n\tif f.precPresent {\n\t\tn := f.prec\n\t\tfor i := 0; i < len(b); {\n\t\t\tn--\n\t\t\tif n < 0 {\n\t\t\t\treturn b[:i]\n\t\t\t}\n\t\t\twid := 1\n\t\t\tif b[i] >= utf8.RuneSelf {\n\t\t\t\t_, wid = utf8.DecodeRune(b[i:])\n\t\t\t}\n\t\t\ti += wid\n\t\t}\n\t}\n\treturn b\n}\n\n// fmtS formats a string.\nfunc (f *fmt) fmtS(s string) {\n\ts = f.truncateString(s)\n\tf.padString(s)\n}\n\n// fmtBs formats the byte slice b as if it was formatted as string with fmtS.\nfunc (f *fmt) fmtBs(b []byte) {\n\tb = f.truncate(b)\n\tf.pad(b)\n}\n\n// fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes.\nfunc (f *fmt) fmtSbx(s string, b []byte, digits string) {\n\tlength := len(b)\n\tif b == nil {\n\t\t// No byte slice present. Assume string s should be encoded.\n\t\tlength = len(s)\n\t}\n\t// Set length to not process more bytes than the precision demands.\n\tif f.precPresent && f.prec < length {\n\t\tlength = f.prec\n\t}\n\t// Compute width of the encoding taking into account the f.sharp and f.space flag.\n\twidth := 2 * length\n\tif width > 0 {\n\t\tif f.space {\n\t\t\t// Each element encoded by two hexadecimals will get a leading 0x or 0X.\n\t\t\tif f.sharp {\n\t\t\t\twidth *= 2\n\t\t\t}\n\t\t\t// Elements will be separated by a space.\n\t\t\twidth += length - 1\n\t\t} else if f.sharp {\n\t\t\t// Only a leading 0x or 0X will be added for the whole string.\n\t\t\twidth += 2\n\t\t}\n\t} else { // The byte slice or string that should be encoded is empty.\n\t\tif f.widPresent {\n\t\t\tf.writePadding(f.wid)\n\t\t}\n\t\treturn\n\t}\n\t// Handle padding to the left.\n\tif f.widPresent && f.wid > width && !f.minus {\n\t\tf.writePadding(f.wid - width)\n\t}\n\t// Write the encoding directly into the output buffer.\n\tbuf := *f.buf\n\tif f.sharp {\n\t\t// Add leading 0x or 0X.\n\t\tbuf = append(buf, '0', digits[16])\n\t}\n\tvar c byte\n\tfor i := 0; i < length; i++ {\n\t\tif f.space && i > 0 {\n\t\t\t// Separate elements with a space.\n\t\t\tbuf = append(buf, ' ')\n\t\t\tif f.sharp {\n\t\t\t\t// Add leading 0x or 0X for each element.\n\t\t\t\tbuf = append(buf, '0', digits[16])\n\t\t\t}\n\t\t}\n\t\tif b != nil {\n\t\t\tc = b[i] // Take a byte from the input byte slice.\n\t\t} else {\n\t\t\tc = s[i] // Take a byte from the input string.\n\t\t}\n\t\t// Encode each byte as two hexadecimal digits.\n\t\tbuf = append(buf, digits[c>>4], digits[c&0xF])\n\t}\n\t*f.buf = buf\n\t// Handle padding to the right.\n\tif f.widPresent && f.wid > width && f.minus {\n\t\tf.writePadding(f.wid - width)\n\t}\n}\n\n// fmtSx formats a string as a hexadecimal encoding of its bytes.\nfunc (f *fmt) fmtSx(s, digits string) {\n\tf.fmtSbx(s, nil, digits)\n}\n\n// fmtBx formats a byte slice as a hexadecimal encoding of its bytes.\nfunc (f *fmt) fmtBx(b []byte, digits string) {\n\tf.fmtSbx(\"\", b, digits)\n}\n\n// fmtQ formats a string as a double-quoted, escaped Go string constant.\n// If f.sharp is set a raw (backquoted) string may be returned instead\n// if the string does not contain any control characters other than tab.\nfunc (f *fmt) fmtQ(s string) {\n\ts = f.truncateString(s)\n\tif f.sharp && strconv.CanBackquote(s) {\n\t\tf.padString(\"`\" + s + \"`\")\n\t\treturn\n\t}\n\tbuf := f.intbuf[:0]\n\tif f.plus {\n\t\tf.pad(strconv.AppendQuoteToASCII(buf, s))\n\t} else {\n\t\tf.pad(strconv.AppendQuote(buf, s))\n\t}\n}\n\n// fmtC formats an integer as a Unicode character.\n// If the character is not valid Unicode, it will print '\\ufffd'.\nfunc (f *fmt) fmtC(c uint64) {\n\tr := rune(c)\n\tif c > utf8.MaxRune {\n\t\tr = utf8.RuneError\n\t}\n\tbuf := f.intbuf[:0]\n\tw := utf8.EncodeRune(buf[:utf8.UTFMax], r)\n\tf.pad(buf[:w])\n}\n\n// fmtQc formats an integer as a single-quoted, escaped Go character constant.\n// If the character is not valid Unicode, it will print '\\ufffd'.\nfunc (f *fmt) fmtQc(c uint64) {\n\tr := rune(c)\n\tif c > utf8.MaxRune {\n\t\tr = utf8.RuneError\n\t}\n\tbuf := f.intbuf[:0]\n\tif f.plus {\n\t\tf.pad(strconv.AppendQuoteRuneToASCII(buf, r))\n\t} else {\n\t\tf.pad(strconv.AppendQuoteRune(buf, r))\n\t}\n}\n\n// fmtFloat formats a float64. It assumes that verb is a valid format specifier\n// for strconv.AppendFloat and therefore fits into a byte.\nfunc (f *fmt) fmtFloat(v float64, size int, verb rune, prec int) {\n\t// Explicit precision in format specifier overrules default precision.\n\tif f.precPresent {\n\t\tprec = f.prec\n\t}\n\t// Format number, reserving space for leading + sign if needed.\n\tnum := strconv.AppendFloat(f.intbuf[:1], v, byte(verb), prec, size)\n\tif num[1] == '-' || num[1] == '+' {\n\t\tnum = num[1:]\n\t} else {\n\t\tnum[0] = '+'\n\t}\n\t// f.space means to add a leading space instead of a \"+\" sign unless\n\t// the sign is explicitly asked for by f.plus.\n\tif f.space && num[0] == '+' && !f.plus {\n\t\tnum[0] = ' '\n\t}\n\t// Special handling for infinities and NaN,\n\t// which don't look like a number so shouldn't be padded with zeros.\n\tif num[1] == 'I' || num[1] == 'N' {\n\t\toldZero := f.zero\n\t\tf.zero = false\n\t\t// Remove sign before NaN if not asked for.\n\t\tif num[1] == 'N' && !f.space && !f.plus {\n\t\t\tnum = num[1:]\n\t\t}\n\t\tf.pad(num)\n\t\tf.zero = oldZero\n\t\treturn\n\t}\n\t// The sharp flag forces printing a decimal point for non-binary formats\n\t// and retains trailing zeros, which we may need to restore.\n\tif f.sharp && verb != 'b' {\n\t\tdigits := 0\n\t\tswitch verb {\n\t\tcase 'v', 'g', 'G', 'x':\n\t\t\tdigits = prec\n\t\t\t// If no precision is set explicitly use a precision of 6.\n\t\t\tif digits == -1 {\n\t\t\t\tdigits = 6\n\t\t\t}\n\t\t}\n\n\t\t// Buffer pre-allocated with enough room for\n\t\t// exponent notations of the form \"e+123\" or \"p-1023\".\n\t\tvar tailBuf [6]byte\n\t\ttail := tailBuf[:0]\n\n\t\thasDecimalPoint := false\n\t\tsawNonzeroDigit := false\n\t\t// Starting from i = 1 to skip sign at num[0].\n\t\tfor i := 1; i < len(num); i++ {\n\t\t\tswitch num[i] {\n\t\t\tcase '.':\n\t\t\t\thasDecimalPoint = true\n\t\t\tcase 'p', 'P':\n\t\t\t\ttail = append(tail, num[i:]...)\n\t\t\t\tnum = num[:i]\n\t\t\tcase 'e', 'E':\n\t\t\t\tif verb != 'x' && verb != 'X' {\n\t\t\t\t\ttail = append(tail, num[i:]...)\n\t\t\t\t\tnum = num[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfallthrough\n\t\t\tdefault:\n\t\t\t\tif num[i] != '0' {\n\t\t\t\t\tsawNonzeroDigit = true\n\t\t\t\t}\n\t\t\t\t// Count significant digits after the first non-zero digit.\n\t\t\t\tif sawNonzeroDigit {\n\t\t\t\t\tdigits--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !hasDecimalPoint {\n\t\t\t// Leading digit 0 should contribute once to digits.\n\t\t\tif len(num) == 2 && num[1] == '0' {\n\t\t\t\tdigits--\n\t\t\t}\n\t\t\tnum = append(num, '.')\n\t\t}\n\t\tfor digits > 0 {\n\t\t\tnum = append(num, '0')\n\t\t\tdigits--\n\t\t}\n\t\tnum = append(num, tail...)\n\t}\n\t// We want a sign if asked for and if the sign is not positive.\n\tif f.plus || num[0] != '+' {\n\t\t// If we're zero padding to the left we want the sign before the leading zeros.\n\t\t// Achieve this by writing the sign out and then padding the unsigned number.\n\t\tif f.zero && f.widPresent && f.wid > len(num) {\n\t\t\tf.buf.writeByte(num[0])\n\t\t\tf.writePadding(f.wid - len(num))\n\t\t\tf.buf.write(num[1:])\n\t\t\treturn\n\t\t}\n\t\tf.pad(num)\n\t\treturn\n\t}\n\t// No sign to show and the number is positive; just print the unsigned number.\n\tf.pad(num[1:])\n}\n","package sync\n\n// Pool is a very simple implementation of sync.Pool. It does not actually\n// implement a pool.\ntype Pool struct {\n\tNew func() interface{}\n}\n\n// Get returns the value of calling Pool.New().\nfunc (p *Pool) Get() interface{} {\n\tif p.New == nil {\n\t\treturn nil\n\t}\n\treturn p.New()\n}\n\n// Put drops the value put into the pool.\nfunc (p *Pool) Put(x interface{}) {\n}\n","// +build js\n\n// Package wsjs implements typed access to the browser javascript WebSocket API.\n//\n// https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\npackage wsjs\n\nimport (\n\t\"syscall/js\"\n)\n\nfunc handleJSError(err *error, onErr func()) {\n\tr := recover()\n\n\tif jsErr, ok := r.(js.Error); ok {\n\t\t*err = jsErr\n\n\t\tif onErr != nil {\n\t\t\tonErr()\n\t\t}\n\t\treturn\n\t}\n\n\tif r != nil {\n\t\tpanic(r)\n\t}\n}\n\n// New is a wrapper around the javascript WebSocket constructor.\nfunc New(url string, protocols []string) (c WebSocket, err error) {\n\tdefer handleJSError(&err, func() {\n\t\tc = WebSocket{}\n\t})\n\n\tjsProtocols := make([]interface{}, len(protocols))\n\tfor i, p := range protocols {\n\t\tjsProtocols[i] = p\n\t}\n\n\tc = WebSocket{\n\t\tv: js.Global().Get(\"WebSocket\").New(url, jsProtocols),\n\t}\n\n\tc.setBinaryType(\"arraybuffer\")\n\n\treturn c, nil\n}\n\n// WebSocket is a wrapper around a javascript WebSocket object.\ntype WebSocket struct {\n\tv js.Value\n}\n\nfunc (c WebSocket) setBinaryType(typ string) {\n\tc.v.Set(\"binaryType\", string(typ))\n}\n\nfunc (c WebSocket) addEventListener(eventType string, fn func(e js.Value)) func() {\n\tf := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tfn(args[0])\n\t\treturn nil\n\t})\n\tc.v.Call(\"addEventListener\", eventType, f)\n\n\treturn func() {\n\t\tc.v.Call(\"removeEventListener\", eventType, f)\n\t\tf.Release()\n\t}\n}\n\n// CloseEvent is the type passed to a WebSocket close handler.\ntype CloseEvent struct {\n\tCode     uint16\n\tReason   string\n\tWasClean bool\n}\n\n// OnClose registers a function to be called when the WebSocket is closed.\nfunc (c WebSocket) OnClose(fn func(CloseEvent)) (remove func()) {\n\treturn c.addEventListener(\"close\", func(e js.Value) {\n\t\tce := CloseEvent{\n\t\t\tCode:     uint16(e.Get(\"code\").Int()),\n\t\t\tReason:   e.Get(\"reason\").String(),\n\t\t\tWasClean: e.Get(\"wasClean\").Bool(),\n\t\t}\n\t\tfn(ce)\n\t})\n}\n\n// OnError registers a function to be called when there is an error\n// with the WebSocket.\nfunc (c WebSocket) OnError(fn func(e js.Value)) (remove func()) {\n\treturn c.addEventListener(\"error\", fn)\n}\n\n// MessageEvent is the type passed to a message handler.\ntype MessageEvent struct {\n\t// string or []byte.\n\tData interface{}\n\n\t// There are more fields to the interface but we don't use them.\n\t// See https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent\n}\n\n// OnMessage registers a function to be called when the WebSocket receives a message.\nfunc (c WebSocket) OnMessage(fn func(m MessageEvent)) (remove func()) {\n\treturn c.addEventListener(\"message\", func(e js.Value) {\n\t\tvar data interface{}\n\n\t\tarrayBuffer := e.Get(\"data\")\n\t\tif arrayBuffer.Type() == js.TypeString {\n\t\t\tdata = arrayBuffer.String()\n\t\t} else {\n\t\t\tdata = extractArrayBuffer(arrayBuffer)\n\t\t}\n\n\t\tme := MessageEvent{\n\t\t\tData: data,\n\t\t}\n\t\tfn(me)\n\n\t\treturn\n\t})\n}\n\n// Subprotocol returns the WebSocket subprotocol in use.\nfunc (c WebSocket) Subprotocol() string {\n\treturn c.v.Get(\"protocol\").String()\n}\n\n// OnOpen registers a function to be called when the WebSocket is opened.\nfunc (c WebSocket) OnOpen(fn func(e js.Value)) (remove func()) {\n\treturn c.addEventListener(\"open\", fn)\n}\n\n// Close closes the WebSocket with the given code and reason.\nfunc (c WebSocket) Close(code int, reason string) (err error) {\n\tdefer handleJSError(&err, nil)\n\tc.v.Call(\"close\", code, reason)\n\treturn err\n}\n\n// SendText sends the given string as a text message\n// on the WebSocket.\nfunc (c WebSocket) SendText(v string) (err error) {\n\tdefer handleJSError(&err, nil)\n\tc.v.Call(\"send\", v)\n\treturn err\n}\n\n// SendBytes sends the given message as a binary message\n// on the WebSocket.\nfunc (c WebSocket) SendBytes(v []byte) (err error) {\n\tdefer handleJSError(&err, nil)\n\tc.v.Call(\"send\", uint8Array(v))\n\treturn err\n}\n\nfunc extractArrayBuffer(arrayBuffer js.Value) []byte {\n\tuint8Array := js.Global().Get(\"Uint8Array\").New(arrayBuffer)\n\tdst := make([]byte, uint8Array.Length())\n\tjs.CopyBytesToGo(dst, uint8Array)\n\treturn dst\n}\n\nfunc uint8Array(src []byte) js.Value {\n\tuint8Array := js.Global().Get(\"Uint8Array\").New(len(src))\n\tjs.CopyBytesToJS(uint8Array, src)\n\treturn uint8Array\n}\n","package websocket // import \"nhooyr.io/websocket\"\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall/js\"\n\n\t\"nhooyr.io/websocket/internal/bpool\"\n\t\"nhooyr.io/websocket/internal/wsjs\"\n\t\"nhooyr.io/websocket/internal/xsync\"\n)\n\n// Conn provides a wrapper around the browser WebSocket API.\ntype Conn struct {\n\tws wsjs.WebSocket\n\n\t// read limit for a message in bytes.\n\tmsgReadLimit xsync.Int64\n\n\tclosingMu     sync.Mutex\n\tisReadClosed  xsync.Int64\n\tcloseOnce     sync.Once\n\tclosed        chan struct{}\n\tcloseErrOnce  sync.Once\n\tcloseErr      error\n\tcloseWasClean bool\n\n\treleaseOnClose   func()\n\treleaseOnMessage func()\n\n\treadSignal chan struct{}\n\treadBufMu  sync.Mutex\n\treadBuf    []wsjs.MessageEvent\n}\n\nfunc (c *Conn) close(err error, wasClean bool) {\n\tc.closeOnce.Do(func() {\n\t\truntime.SetFinalizer(c, nil)\n\n\t\tif !wasClean {\n\t\t\terr = fmt.Errorf(\"unclean connection close: %w\", err)\n\t\t}\n\t\tc.setCloseErr(err)\n\t\tc.closeWasClean = wasClean\n\t\tclose(c.closed)\n\t})\n}\n\nfunc (c *Conn) init() {\n\tc.closed = make(chan struct{})\n\tc.readSignal = make(chan struct{}, 1)\n\n\tc.msgReadLimit.Store(32768)\n\n\tc.releaseOnClose = c.ws.OnClose(func(e wsjs.CloseEvent) {\n\t\terr := CloseError{\n\t\t\tCode:   StatusCode(e.Code),\n\t\t\tReason: e.Reason,\n\t\t}\n\t\t// We do not know if we sent or received this close as\n\t\t// its possible the browser triggered it without us\n\t\t// explicitly sending it.\n\t\tc.close(err, e.WasClean)\n\n\t\tc.releaseOnClose()\n\t\tc.releaseOnMessage()\n\t})\n\n\tc.releaseOnMessage = c.ws.OnMessage(func(e wsjs.MessageEvent) {\n\t\tc.readBufMu.Lock()\n\t\tdefer c.readBufMu.Unlock()\n\n\t\tc.readBuf = append(c.readBuf, e)\n\n\t\t// Lets the read goroutine know there is definitely something in readBuf.\n\t\tselect {\n\t\tcase c.readSignal <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t})\n\n\truntime.SetFinalizer(c, func(c *Conn) {\n\t\tc.setCloseErr(errors.New(\"connection garbage collected\"))\n\t\tc.closeWithInternal()\n\t})\n}\n\nfunc (c *Conn) closeWithInternal() {\n\tc.Close(StatusInternalError, \"something went wrong\")\n}\n\n// Read attempts to read a message from the connection.\n// The maximum time spent waiting is bounded by the context.\nfunc (c *Conn) Read(ctx context.Context) (MessageType, []byte, error) {\n\tif c.isReadClosed.Load() == 1 {\n\t\treturn 0, nil, errors.New(\"WebSocket connection read closed\")\n\t}\n\n\ttyp, p, err := c.read(ctx)\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\tif int64(len(p)) > c.msgReadLimit.Load() {\n\t\terr := fmt.Errorf(\"read limited at %v bytes\", c.msgReadLimit.Load())\n\t\tc.Close(StatusMessageTooBig, err.Error())\n\t\treturn 0, nil, err\n\t}\n\treturn typ, p, nil\n}\n\nfunc (c *Conn) read(ctx context.Context) (MessageType, []byte, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\tc.Close(StatusPolicyViolation, \"read timed out\")\n\t\treturn 0, nil, ctx.Err()\n\tcase <-c.readSignal:\n\tcase <-c.closed:\n\t\treturn 0, nil, c.closeErr\n\t}\n\n\tc.readBufMu.Lock()\n\tdefer c.readBufMu.Unlock()\n\n\tme := c.readBuf[0]\n\t// We copy the messages forward and decrease the size\n\t// of the slice to avoid reallocating.\n\tcopy(c.readBuf, c.readBuf[1:])\n\tc.readBuf = c.readBuf[:len(c.readBuf)-1]\n\n\tif len(c.readBuf) > 0 {\n\t\t// Next time we read, we'll grab the message.\n\t\tselect {\n\t\tcase c.readSignal <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\n\tswitch p := me.Data.(type) {\n\tcase string:\n\t\treturn MessageText, []byte(p), nil\n\tcase []byte:\n\t\treturn MessageBinary, p, nil\n\tdefault:\n\t\tpanic(\"websocket: unexpected data type from wsjs OnMessage: \" + reflect.TypeOf(me.Data).String())\n\t}\n}\n\n// Ping is mocked out for Wasm.\nfunc (c *Conn) Ping(ctx context.Context) error {\n\treturn nil\n}\n\n// Write writes a message of the given type to the connection.\n// Always non blocking.\nfunc (c *Conn) Write(ctx context.Context, typ MessageType, p []byte) error {\n\terr := c.write(ctx, typ, p)\n\tif err != nil {\n\t\t// Have to ensure the WebSocket is closed after a write error\n\t\t// to match the Go API. It can only error if the message type\n\t\t// is unexpected or the passed bytes contain invalid UTF-8 for\n\t\t// MessageText.\n\t\terr := fmt.Errorf(\"failed to write: %w\", err)\n\t\tc.setCloseErr(err)\n\t\tc.closeWithInternal()\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) write(ctx context.Context, typ MessageType, p []byte) error {\n\tif c.isClosed() {\n\t\treturn c.closeErr\n\t}\n\tswitch typ {\n\tcase MessageBinary:\n\t\treturn c.ws.SendBytes(p)\n\tcase MessageText:\n\t\treturn c.ws.SendText(string(p))\n\tdefault:\n\t\treturn fmt.Errorf(\"unexpected message type: %v\", typ)\n\t}\n}\n\n// Close closes the WebSocket with the given code and reason.\n// It will wait until the peer responds with a close frame\n// or the connection is closed.\n// It thus performs the full WebSocket close handshake.\nfunc (c *Conn) Close(code StatusCode, reason string) error {\n\terr := c.exportedClose(code, reason)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to close WebSocket: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) exportedClose(code StatusCode, reason string) error {\n\tc.closingMu.Lock()\n\tdefer c.closingMu.Unlock()\n\n\tce := fmt.Errorf(\"sent close: %w\", CloseError{\n\t\tCode:   code,\n\t\tReason: reason,\n\t})\n\n\tif c.isClosed() {\n\t\treturn fmt.Errorf(\"tried to close with %q but connection already closed: %w\", ce, c.closeErr)\n\t}\n\n\tc.setCloseErr(ce)\n\terr := c.ws.Close(int(code), reason)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t<-c.closed\n\tif !c.closeWasClean {\n\t\treturn c.closeErr\n\t}\n\treturn nil\n}\n\n// Subprotocol returns the negotiated subprotocol.\n// An empty string means the default protocol.\nfunc (c *Conn) Subprotocol() string {\n\treturn c.ws.Subprotocol()\n}\n\n// DialOptions represents the options available to pass to Dial.\ntype DialOptions struct {\n\t// Subprotocols lists the subprotocols to negotiate with the server.\n\tSubprotocols []string\n}\n\n// Dial creates a new WebSocket connection to the given url with the given options.\n// The passed context bounds the maximum time spent waiting for the connection to open.\n// The returned *http.Response is always nil or a mock. It's only in the signature\n// to match the core API.\nfunc Dial(ctx context.Context, url string, opts *DialOptions) (*Conn, *http.Response, error) {\n\tc, resp, err := dial(ctx, url, opts)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to WebSocket dial %q: %w\", url, err)\n\t}\n\treturn c, resp, nil\n}\n\nfunc dial(ctx context.Context, url string, opts *DialOptions) (*Conn, *http.Response, error) {\n\tif opts == nil {\n\t\topts = &DialOptions{}\n\t}\n\n\turl = strings.Replace(url, \"http://\", \"ws://\", 1)\n\turl = strings.Replace(url, \"https://\", \"wss://\", 1)\n\n\tws, err := wsjs.New(url, opts.Subprotocols)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := &Conn{\n\t\tws: ws,\n\t}\n\tc.init()\n\n\topench := make(chan struct{})\n\treleaseOpen := ws.OnOpen(func(e js.Value) {\n\t\tclose(opench)\n\t})\n\tdefer releaseOpen()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tc.Close(StatusPolicyViolation, \"dial timed out\")\n\t\treturn nil, nil, ctx.Err()\n\tcase <-opench:\n\t\treturn c, &http.Response{\n\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t}, nil\n\tcase <-c.closed:\n\t\treturn nil, nil, c.closeErr\n\t}\n}\n\n// Reader attempts to read a message from the connection.\n// The maximum time spent waiting is bounded by the context.\nfunc (c *Conn) Reader(ctx context.Context) (MessageType, io.Reader, error) {\n\ttyp, p, err := c.Read(ctx)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\treturn typ, bytes.NewReader(p), nil\n}\n\n// Writer returns a writer to write a WebSocket data message to the connection.\n// It buffers the entire message in memory and then sends it when the writer\n// is closed.\nfunc (c *Conn) Writer(ctx context.Context, typ MessageType) (io.WriteCloser, error) {\n\treturn writer{\n\t\tc:   c,\n\t\tctx: ctx,\n\t\ttyp: typ,\n\t\tb:   bpool.Get(),\n\t}, nil\n}\n\ntype writer struct {\n\tclosed bool\n\n\tc   *Conn\n\tctx context.Context\n\ttyp MessageType\n\n\tb *bytes.Buffer\n}\n\nfunc (w writer) Write(p []byte) (int, error) {\n\tif w.closed {\n\t\treturn 0, errors.New(\"cannot write to closed writer\")\n\t}\n\tn, err := w.b.Write(p)\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"failed to write message: %w\", err)\n\t}\n\treturn n, nil\n}\n\nfunc (w writer) Close() error {\n\tif w.closed {\n\t\treturn errors.New(\"cannot close closed writer\")\n\t}\n\tw.closed = true\n\tdefer bpool.Put(w.b)\n\n\terr := w.c.Write(w.ctx, w.typ, w.b.Bytes())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to close writer: %w\", err)\n\t}\n\treturn nil\n}\n\n// CloseRead implements *Conn.CloseRead for wasm.\nfunc (c *Conn) CloseRead(ctx context.Context) context.Context {\n\tc.isReadClosed.Store(1)\n\n\tctx, cancel := context.WithCancel(ctx)\n\tgo func() {\n\t\tdefer cancel()\n\t\tc.read(ctx)\n\t\tc.Close(StatusPolicyViolation, \"unexpected data message\")\n\t}()\n\treturn ctx\n}\n\n// SetReadLimit implements *Conn.SetReadLimit for wasm.\nfunc (c *Conn) SetReadLimit(n int64) {\n\tc.msgReadLimit.Store(n)\n}\n\nfunc (c *Conn) setCloseErr(err error) {\n\tc.closeErrOnce.Do(func() {\n\t\tc.closeErr = fmt.Errorf(\"WebSocket closed: %w\", err)\n\t})\n}\n\nfunc (c *Conn) isClosed() bool {\n\tselect {\n\tcase <-c.closed:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","package xsync\n\nimport (\n\t\"sync/atomic\"\n)\n\n// Int64 represents an atomic int64.\ntype Int64 struct {\n\t// We do not use atomic.Load/StoreInt64 since it does not\n\t// work on 32 bit computers but we need 64 bit integers.\n\ti atomic.Value\n}\n\n// Load loads the int64.\nfunc (v *Int64) Load() int64 {\n\ti, _ := v.i.Load().(int64)\n\treturn i\n}\n\n// Store stores the int64.\nfunc (v *Int64) Store(i int64) {\n\tv.i.Store(i)\n}\n",".globaltype __stack_pointer, i32\n\n.functype start_unwind (i32) -> ()\n.import_module start_unwind, asyncify\n.functype stop_unwind () -> ()\n.import_module stop_unwind, asyncify\n.functype start_rewind (i32) -> ()\n.import_module start_rewind, asyncify\n.functype stop_rewind () -> ()\n.import_module stop_rewind, asyncify\n\n.global  tinygo_unwind\n.hidden  tinygo_unwind\n.type    tinygo_unwind,@function\ntinygo_unwind: // func (state *stackState) unwind()\n    .functype tinygo_unwind (i32) -> ()\n    // Check if we are rewinding.\n    i32.const 0\n    i32.load8_u tinygo_rewinding\n    if // if tinygo_rewinding {\n    // Stop rewinding.\n    call stop_rewind\n    i32.const 0\n    i32.const 0\n    i32.store8 tinygo_rewinding // tinygo_rewinding = false;\n    else\n    // Save the C stack pointer (destination structure pointer is in local 0).\n    local.get 0\n    global.get __stack_pointer\n    i32.store 4 // state.csp = getCurrentStackPointer()\n    // Ask asyncify to unwind.\n    // When resuming, asyncify will return this function with tinygo_rewinding set to true.\n    local.get 0\n    call start_unwind // asyncify.start_unwind(state)\n    end_if\n    return\n    end_function\n\n.global tinygo_launch\n.hidden tinygo_launch\n.type tinygo_launch,@function\ntinygo_launch: // func (state *state) launch()\n    .functype tinygo_launch (i32) -> ()\n    // Switch to the goroutine's C stack.\n    global.get __stack_pointer // prev := getCurrentStackPointer()\n    local.get 0\n    i32.load 12\n    global.set __stack_pointer // setStackPointer(state.csp)\n    // Get the argument pack and entry pointer.\n    local.get 0\n    i32.load 4 // args := state.args\n    local.get 0\n    i32.load 0 // fn := state.entry\n    // Launch the entry function.\n    call_indirect (i32) -> () // fn(args)\n    // Stop unwinding.\n    call stop_unwind\n    // Restore the C stack.\n    global.set __stack_pointer // setStackPointer(prev)\n    return\n    end_function\n\n.global  tinygo_rewind\n.hidden  tinygo_rewind\n.type    tinygo_rewind,@function\ntinygo_rewind: // func (state *state) rewind()\n    .functype tinygo_rewind (i32) -> ()\n    // Switch to the goroutine's C stack.\n    global.get __stack_pointer // prev := getCurrentStackPointer()\n    local.get 0\n    i32.load 12\n    global.set __stack_pointer // setStackPointer(state.csp)\n    // Get the argument pack and entry pointer.\n    local.get 0\n    i32.load 4 // args := state.args\n    local.get 0\n    i32.load 0 // fn := state.entry\n    // Prepare to rewind.\n    i32.const 0\n    i32.const 1\n    i32.store8 tinygo_rewinding // tinygo_rewinding = true;\n    local.get 0\n    i32.const 8\n    i32.add\n    call start_rewind // asyncify.start_rewind(&state.stackState)\n    // Launch the entry function.\n    // This will actually rewind the call stack.\n    call_indirect (i32) -> () // fn(args)\n    // Stop unwinding.\n    call stop_unwind\n    // Restore the C stack.\n    global.set __stack_pointer // setStackPointer(prev)\n    return\n    end_function\n\n        .hidden tinygo_rewinding                # @tinygo_rewinding\n        .type   tinygo_rewinding,@object\n        .section        .bss.tinygo_rewinding,\"\",@\n        .globl  tinygo_rewinding\ntinygo_rewinding:\n        .int8   0                               # 0x0\n        .size   tinygo_rewinding, 1\n",null,null,null,null],"mappings":"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"}